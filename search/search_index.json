{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#mujoco-mojo","title":"MuJoCo Mojo","text":"<p>Pythonic MJCF generation and validation toolkit built on Pydantic v2.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed MJCF models</li> <li>Compile-time XML validation</li> <li>NumPy vector support</li> <li>Automatic XML serialization</li> <li>MuJoCo compatible schema</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"Python<pre><code>from mujoco_mojo import Material\n\nmat = Material(name=\"steel\")\nprint(mat.to_xml())\n</code></pre>"},{"location":"user-guide/","title":"User Guide","text":"<p>Guide is coming soon...</p> <p>Default Values</p> <p>Some attributes in this package make use of default values. Wherever possible, the default values match what is stated in the XML Reference. The <code>to_xml</code> method found in all <code>XMLModel</code> (which is most) has an argument which will omit serializing fields set as default.</p> <p>If you have a specific use case which is dependent on a value you leave as default, it is highly recommended that you pin that value as opposed to use the default. MuJoCo may change their defaults, and this package may fall behind. In that case, you would be using a \"default\" which is no longer the default.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mujoco_mojo<ul> <li>base</li> <li>mjcf<ul> <li>defaults</li> <li>mujoco</li> <li>mujoco_attr<ul> <li>asset</li> <li>asset_attr<ul> <li>hfield</li> <li>material</li> <li>material_attr<ul> <li>layer</li> </ul> </li> <li>mesh</li> <li>model</li> <li>texture</li> </ul> </li> <li>body</li> <li>body_attr<ul> <li>attach</li> <li>camera</li> <li>composite</li> <li>composite_attr<ul> <li>geom</li> <li>joint</li> <li>site</li> <li>skin</li> </ul> </li> <li>flexcomp</li> <li>flexcomp_attr<ul> <li>contact</li> <li>edge</li> <li>elasticity</li> <li>pin</li> </ul> </li> <li>frame</li> <li>free_joint</li> <li>geom</li> <li>inertial</li> <li>joint</li> <li>light</li> <li>plugin</li> <li>site</li> </ul> </li> <li>compiler</li> <li>compiler_attr<ul> <li>lengthrange</li> </ul> </li> <li>option</li> <li>option_attr<ul> <li>flag</li> </ul> </li> <li>size</li> <li>statistic</li> </ul> </li> <li>orientation</li> <li>plugin</li> <li>position</li> </ul> </li> <li>typing</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/mujoco_mojo/","title":"mujoco_mojo","text":""},{"location":"reference/mujoco_mojo/#mujoco_mojo","title":"mujoco_mojo","text":"<p>mujoco_mojo is a collection of Python objects built to make working with MuJoCo via Python easier.</p> <p>It provides vast bindings for all MJCF XML schema objects, tools to convert to XML, run MuJoCo simulations, and more.</p>"},{"location":"reference/mujoco_mojo/base/","title":"base","text":""},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base","title":"base","text":""},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel","title":"XMLModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for most MuJoCo Mojo MJCF objects.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/typing/","title":"typing","text":""},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing","title":"typing","text":""},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.MeshName","title":"MeshName  <code>module-attribute</code>","text":"Python<pre><code>MeshName = NewType('MeshName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Mesh.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.HFieldName","title":"HFieldName  <code>module-attribute</code>","text":"Python<pre><code>HFieldName = NewType('HFieldName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of an HField.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.MaterialName","title":"MaterialName  <code>module-attribute</code>","text":"Python<pre><code>MaterialName = NewType('MaterialName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Material.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureName","title":"TextureName  <code>module-attribute</code>","text":"Python<pre><code>TextureName = NewType('TextureName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Texture.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ModelName","title":"ModelName  <code>module-attribute</code>","text":"Python<pre><code>ModelName = NewType('ModelName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Model.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.BodyName","title":"BodyName  <code>module-attribute</code>","text":"Python<pre><code>BodyName = NewType('BodyName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Body.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.JointName","title":"JointName  <code>module-attribute</code>","text":"Python<pre><code>JointName = NewType('JointName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Joint.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomName","title":"GeomName  <code>module-attribute</code>","text":"Python<pre><code>GeomName = NewType('GeomName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Geom.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.SiteName","title":"SiteName  <code>module-attribute</code>","text":"Python<pre><code>SiteName = NewType('SiteName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Site.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.CameraName","title":"CameraName  <code>module-attribute</code>","text":"Python<pre><code>CameraName = NewType('CameraName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Camera.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LightName","title":"LightName  <code>module-attribute</code>","text":"Python<pre><code>LightName = NewType('LightName', str)\n</code></pre> <p>Alias of string. Used to type hint a field is the name of a Light.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ActuatorGroup","title":"ActuatorGroup  <code>module-attribute</code>","text":"Python<pre><code>ActuatorGroup = Annotated[int, Field(ge=0, le=30)]\n</code></pre> <p>An integer representing an actuator group index. Must be between 0 and 30 inclusive.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomGroup","title":"GeomGroup  <code>module-attribute</code>","text":"Python<pre><code>GeomGroup = Annotated[int, Field(ge=0, le=30)]\n</code></pre> <p>An integer representing a geom group index. Must be between 0 and 30 inclusive.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.InertiaGroupRange","title":"InertiaGroupRange  <code>module-attribute</code>","text":"Python<pre><code>InertiaGroupRange = tuple[GeomGroup, GeomGroup]\n</code></pre> <p>A tuple specifying the inclusive range of geom groups used for inertia computation.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GridLayoutStr","title":"GridLayoutStr  <code>module-attribute</code>","text":"Python<pre><code>GridLayoutStr = Annotated[\n    str,\n    Field(\n        pattern=\"^[\\\\.RLUDFB]{9}$\",\n        description=\"String which may only use `'.'`, `'R'`, `'L'`, `'U'`, `'D'`, `'F'`, and `'B'`\",\n    ),\n]\n</code></pre> <p>A string used for texture grid layout. May only include <code>'.'</code>, <code>'R'</code>, <code>'L'</code>, <code>'U'</code>, <code>'D'</code>, <code>'F'</code>, and <code>'B'</code>.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Vec2","title":"Vec2  <code>module-attribute</code>","text":"Python<pre><code>Vec2 = Annotated[NDArray[Shape['2'], float | int], ...]\n</code></pre> <p>A 2-element numeric array.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Vec3","title":"Vec3  <code>module-attribute</code>","text":"Python<pre><code>Vec3 = Annotated[NDArray[Shape['3'], float | int], ...]\n</code></pre> <p>A 3-element numeric array, often used for positions or directions.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Vec4","title":"Vec4  <code>module-attribute</code>","text":"Python<pre><code>Vec4 = Annotated[NDArray[Shape['4'], float | int], ...]\n</code></pre> <p>A 4-element numeric array, often used for RGBA colors or quaternions.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Vec5","title":"Vec5  <code>module-attribute</code>","text":"Python<pre><code>Vec5 = Annotated[NDArray[Shape['5'], float | int], ...]\n</code></pre> <p>A 5-element numeric array.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Vec6","title":"Vec6  <code>module-attribute</code>","text":"Python<pre><code>Vec6 = Annotated[NDArray[Shape['6'], float | int], ...]\n</code></pre> <p>A 6-element numeric array.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.VecN","title":"VecN  <code>module-attribute</code>","text":"Python<pre><code>VecN = Annotated[NDArray[Shape['*'], float | int], ...]\n</code></pre> <p>An N-element numeric array of arbitrary length.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq","title":"EulerSeq","text":"<p>               Bases: <code>StrEnum</code></p> <p>Euler rotation sequences.</p> <ul> <li>Lowercase letters denote intrinsic rotations (about the rotating frame).</li> <li>Uppercase letters denote extrinsic rotations (about the fixed parent frame).</li> </ul>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.xyz","title":"xyz  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyz = 'xyz'\n</code></pre> <p>Intrinsic Tait-Bryan xyz sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.xzy","title":"xzy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xzy = 'xzy'\n</code></pre> <p>Intrinsic Tait-Bryan xzy sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.yxz","title":"yxz  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>yxz = 'yxz'\n</code></pre> <p>Intrinsic Tait-Bryan yxz sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.yzx","title":"yzx  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>yzx = 'yzx'\n</code></pre> <p>Intrinsic Tait-Bryan yzx sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.zxy","title":"zxy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zxy = 'zxy'\n</code></pre> <p>Intrinsic Tait-Bryan zxy sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.zyx","title":"zyx  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zyx = 'zyx'\n</code></pre> <p>Intrinsic Tait-Bryan zyx sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.xyx","title":"xyx  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyx = 'xyx'\n</code></pre> <p>Intrinsic proper Euler xyx sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.xzx","title":"xzx  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xzx = 'xzx'\n</code></pre> <p>Intrinsic proper Euler xzx sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.yxy","title":"yxy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>yxy = 'yxy'\n</code></pre> <p>Intrinsic proper Euler yxy sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.yzy","title":"yzy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>yzy = 'yzy'\n</code></pre> <p>Intrinsic proper Euler yzy sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.zxz","title":"zxz  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zxz = 'zxz'\n</code></pre> <p>Intrinsic proper Euler zxz sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.zyz","title":"zyz  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zyz = 'zyz'\n</code></pre> <p>Intrinsic proper Euler zyz sequence.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.XYZ","title":"XYZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>XYZ = 'XYZ'\n</code></pre> <p>Extrinsic Tait-Bryan XYZ sequence</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.XZY","title":"XZY  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>XZY = 'XZY'\n</code></pre> <p>Extrinsic Tait-Bryan XZY sequence</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.YXZ","title":"YXZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>YXZ = 'YXZ'\n</code></pre> <p>Extrinsic Tait-Bryan YXZ sequence</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.YZX","title":"YZX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>YZX = 'YZX'\n</code></pre> <p>Extrinsic Tait-Bryan YZX sequence</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.ZXY","title":"ZXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ZXY = 'ZXY'\n</code></pre> <p>Extrinsic Tait-Bryan ZXY sequence</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.ZYX","title":"ZYX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ZYX = 'ZYX'\n</code></pre> <p>Extrinsic Tait-Bryan ZYX sequence</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.XYX","title":"XYX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>XYX = 'XYX'\n</code></pre> <p>Extrinsic proper Euler XYX</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.XZX","title":"XZX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>XZX = 'XZX'\n</code></pre> <p>Extrinsic proper Euler XZX</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.YXY","title":"YXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>YXY = 'YXY'\n</code></pre> <p>Extrinsic proper Euler YXY</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.YZY","title":"YZY  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>YZY = 'YZY'\n</code></pre> <p>Extrinsic proper Euler YZY</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.ZXZ","title":"ZXZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ZXZ = 'ZXZ'\n</code></pre> <p>Extrinsic proper Euler ZXZ</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EulerSeq.ZYZ","title":"ZYZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ZYZ = 'ZYZ'\n</code></pre> <p>Extrinsic proper Euler ZYZ</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole","title":"LayerRole","text":"<p>               Bases: <code>StrEnum</code></p> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.RGB","title":"RGB  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>RGB = 'rgb'\n</code></pre> <p>3 channels. base color / albedo [red, green, blue].</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.NORMAL","title":"NORMAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>NORMAL = 'normal'\n</code></pre> <p>3 channels. bump map (surface normals).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.OCCLUSION","title":"OCCLUSION  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>OCCLUSION = 'occlusion'\n</code></pre> <p>1 channel. ambient occlusion.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.ROUGHNESS","title":"ROUGHNESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ROUGHNESS = 'roughness'\n</code></pre> <p>1 channel. roughness.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.METALLIC","title":"METALLIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>METALLIC = 'metallic'\n</code></pre> <p>1 channel. metallicity.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.OPACITY","title":"OPACITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>OPACITY = 'opacity'\n</code></pre> <p>1 channel. opacity (alpha channel).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.EMISSIVE","title":"EMISSIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>EMISSIVE = 'emissive'\n</code></pre> <p>4 channels. RGB light emmision intensity, exposure weight in 4th channel.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.ORM","title":"ORM  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ORM = 'orm'\n</code></pre> <p>3 channels. packed 3 channel [occlusion, roughness, metallic].</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LayerRole.RGBA","title":"RGBA  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>RGBA = 'rgba'\n</code></pre> <p>4 channels. packed 4 channel [red, green, blue, alpha].</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType","title":"GeomType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration of supported geometric types in MuJoCo.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.PLANE","title":"PLANE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>PLANE = 'plane'\n</code></pre> <p>Plane which is infinite for collision detection purposes.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.HFIELD","title":"HFIELD  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>HFIELD = 'hfield'\n</code></pre> <p>Height field geom.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.SPHERE","title":"SPHERE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SPHERE = 'sphere'\n</code></pre> <p>Sphere geom.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.CAPSULE","title":"CAPSULE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CAPSULE = 'capsule'\n</code></pre> <p>A capsule, which is a cylinder capped with two half-spheres.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.ELLIPSOID","title":"ELLIPSOID  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ELLIPSOID = 'ellipsoid'\n</code></pre> <p>Ellipoid geom.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.CYLINDER","title":"CYLINDER  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CYLINDER = 'cylinder'\n</code></pre> <p>Cylinder geom.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.BOX","title":"BOX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>BOX = 'box'\n</code></pre> <p>Box geom.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.MESH","title":"MESH  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>MESH = 'mesh'\n</code></pre> <p>Mesh geom.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.GeomType.SDF","title":"SDF  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SDF = 'sdf'\n</code></pre> <p>Signed distance field (SDF, also referred to as signed distance function).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Integrator","title":"Integrator","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration of simulation integrators.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Integrator.EULER","title":"EULER  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>EULER = 'Euler'\n</code></pre> <p>Semi-implicit with implicit joint damping (Euler).</p> <p>For this method, DD only includes derivatives of joint damping. Note that in this case DD is diagonal and Mhat is symmetric, so LT L decomposition (a variant of Cholesky) can be used. This factorization is stored mjData.qLD. If the model has no joint damping or the eulerdamp disable-flag is set, implicit damping is disabled and the semi-implicit update (3) is used, rather than (6), avoiding the additional factorization of Mhat (additional because MM is already factorized for the acceleration update (5)).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Integrator.RK4","title":"RK4  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>RK4 = 'RK4'\n</code></pre> <p>4th-order Runge-Kutta (RK4).</p> <p>One advantage of our continuous-time formulation is that we can use higher order integrators such as Runge-Kutta or multistep methods. The only such integrator currently implemented is the fixed-step 4th-order Runge-Kutta method, though users can easily implement other integrators by calling mj_forward and integrating accelerations themselves. We have observed that for energy-conserving systems (example), RK4 is qualitatively better than the single-step methods, both in terms of stability and accuracy, even when the timestep is decreased by a factor of 4 (so the computational effort is identical). In the presence of large velocity- dependent forces, if the chosen single-step method integrates those forces implicitly, single-step methods can be significantly more stable than RK4.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Integrator.IMPLICIT","title":"IMPLICIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>IMPLICIT = 'implicit'\n</code></pre> <p>Implicit-in-velocity (implicit).</p> <p>For this method, D includes derivatives of all forces except the constraint forces JTf(v). These are currently ignored since even though computing them is possible, it is complicated, and numerical tests show that including them does not confer much benefit. That said, analytical derivatives of constraint forces are planned for a future version. Additionally, we restrict D to have the same sparsity pattern as M, for computational efficiency. This restriction will exclude damping in tendons which connect bodies that are on different branches of the kinematic tree. Since D is not symmetric, we cannot use Cholesky factorization, but because D and M have the same sparsity pattern corresponding to the topology of the kinematic tree, reverse-order LU factorization of Mhat is guaranteed to have no fill-in. This factorization is stored mjData.qLU.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Integrator.IMPLICITFAST","title":"IMPLICITFAST  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>IMPLICITFAST = 'implicitfast'\n</code></pre> <p>Fast implicit-in-velocity (implicitfast).</p> <p>For this method, DD includes derivatives of all forces used in the implicit method, with the exception of the centripetal and Coriolis forces c(v) computed by the RNE algorithm. Additionally, it is symmetrized D\u2190(D+DT)/2. One reason for dropping the RNE derivatives is that they are the most expensive to compute. Second, these forces change rapidly only at high rotational velocities of complex pendula and spinning bodies, scenarios which are not common and already well-handled by the Runge-Kutta integrator (see below). Because the RNE derivatives are also the main source of asymmetry of D, by dropping them and symmetrizing, we can use the faster LTL rather than LU decomposition.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Cone","title":"Cone","text":"<p>               Bases: <code>StrEnum</code></p> <p>Cone types used in collision/contact modeling.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Cone.PYRAMIDAL","title":"PYRAMIDAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>PYRAMIDAL = 'pyramidal'\n</code></pre> <p>Sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Cone.ELLIPTIC","title":"ELLIPTIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ELLIPTIC = 'elliptic'\n</code></pre> <p>Better model of the physical reality.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Jacobian","title":"Jacobian","text":"<p>               Bases: <code>StrEnum</code></p> <p>Jacobian computation methods.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Jacobian.DENSE","title":"DENSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>DENSE = 'dense'\n</code></pre> <p>Dense jacobian.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Jacobian.SPARSE","title":"SPARSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SPARSE = 'sparse'\n</code></pre> <p>Sparse jacobian.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Jacobian.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AUTO = 'auto'\n</code></pre> <p>Resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Solver","title":"Solver","text":"<p>               Bases: <code>StrEnum</code></p> <p>Solver algorithms for constraint resolution.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Solver.PGS","title":"PGS  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>PGS = 'PGS'\n</code></pre> <p>Projected Gauss-Seidel method.</p> <p>This is the most common algorithm used in physics simulators, and used to be the default in MuJoCo, until we developed the Newton method which appears to be better in every way. PGS uses the dual formulation. Unlike gradient-based methods which improve the solution along oblique directions, Gauss-Seidel works on one scalar component at a time, and sets it to its optimal value given the current values of all other components. One sweep of PGS has the computational complexity of one matrix-vector multiplication (although the constants are larger). It has first-order convergence but nevertheless makes rapid progress in a few iterations.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Solver.CG","title":"CG  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CG = 'CG'\n</code></pre> <p>Conjugate gradient method.</p> <p>This algorithm uses the non-linear conjugate gradient method with the Polak-Ribiere-Plus formula. Line-search is exact, using Newton's method in one dimension, with analytical second derivatives.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Solver.NEWTON","title":"NEWTON  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>NEWTON = 'Newton'\n</code></pre> <p>Newton's method.</p> <p>This algorithm implements the exact Newton method, with analytical second-order derivatives and Cholesky factorization of the Hessian. The line-search is the same as in the CG method. It is the default solver.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EnableDisable","title":"EnableDisable","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enable or disable a feature.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EnableDisable.ENABLE","title":"ENABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ENABLE = 'enable'\n</code></pre> <p>Enable the feature.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.EnableDisable.DISABLE","title":"DISABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>DISABLE = 'disable'\n</code></pre> <p>Disable the feature.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Coordinate","title":"Coordinate","text":"<p>               Bases: <code>StrEnum</code></p> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Angle","title":"Angle","text":"<p>               Bases: <code>StrEnum</code></p> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.InertiaFromGeom","title":"InertiaFromGeom","text":"<p>               Bases: <code>StrEnum</code></p> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.InertiaFromGeom.FALSE","title":"FALSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FALSE = 'false'\n</code></pre> <p>No automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.InertiaFromGeom.TRUE","title":"TRUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TRUE = 'true'\n</code></pre> <p>The mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.InertiaFromGeom.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AUTO = 'auto'\n</code></pre> <p>Masses and inertias are inferred automatically only when the inertial element is missing in the body definition.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LengthRangeMode","title":"LengthRangeMode","text":"<p>               Bases: <code>StrEnum</code></p> <p>Determines the type of actuators to which length range computation is applied.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LengthRangeMode.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>NONE = 'none'\n</code></pre> <p>Disables this functionality.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LengthRangeMode.MUSCLE","title":"MUSCLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>MUSCLE = 'muscle'\n</code></pre> <p>Applies to actuators whose gaintype or biastype is set to <code>muscle</code></p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LengthRangeMode.MUSCLEUSER","title":"MUSCLEUSER  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>MUSCLEUSER = 'muscleuser'\n</code></pre> <p>Applies to actuators whose gaintype or biastype is set to either <code>muscle</code> or <code>user</code>.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LengthRangeMode.ALL","title":"ALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ALL = 'all'\n</code></pre> <p>Applies to all actuators.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Inertia","title":"Inertia","text":"<p>               Bases: <code>StrEnum</code></p> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Inertia.CONVEX","title":"CONVEX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CONVEX = 'convex'\n</code></pre> <p>Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Inertia.EXACT","title":"EXACT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>EXACT = 'exact'\n</code></pre> <p>Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Inertia.LEGACY","title":"LEGACY  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>LEGACY = 'legacy'\n</code></pre> <p>Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Inertia.SHELL","title":"SHELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SHELL = 'shell'\n</code></pre> <p>Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureType","title":"TextureType","text":"<p>               Bases: <code>StrEnum</code></p> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureType.D2","title":"D2  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>D2 = '2d'\n</code></pre> <p>Maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureType.CUBE","title":"CUBE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CUBE = 'cube'\n</code></pre> <p>Has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureType.SKYBOX","title":"SKYBOX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SKYBOX = 'skybox'\n</code></pre> <p>Very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ColorSpace","title":"ColorSpace","text":"<p>               Bases: <code>StrEnum</code></p> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ColorSpace.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AUTO = 'auto'\n</code></pre> <p>Color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ColorSpace.LINEAR","title":"LINEAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>LINEAR = 'linear'\n</code></pre> <p>Linear color space.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ColorSpace.SRGB","title":"SRGB  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SRGB = 'srgb'\n</code></pre> <p>SRGB color space.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureBuiltInType","title":"TextureBuiltInType","text":"<p>               Bases: <code>StrEnum</code></p> <p>This and the remaining attributes control the generation of procedural textures. If the value of this attribute is different from \"none\", the texture is treated as procedural and any file names are ignored.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureBuiltInType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>NONE = 'none'\n</code></pre> <p>No builtin texture.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureBuiltInType.GRADIENT","title":"GRADIENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>GRADIENT = 'gradient'\n</code></pre> <p>Generates a color gradient from rgb1 to rgb2. The interpolation in color space is done through a sigmoid function. For cube and skybox textures the gradient is along the +Y axis, i.e., from top to bottom for skybox rendering.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureBuiltInType.CHECKER","title":"CHECKER  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CHECKER = 'checker'\n</code></pre> <p>Generates a 2-by-2 checker pattern with alternating colors given by rgb1 and rgb2. This is suitable for rendering ground planes and also for marking objects with rotational symmetries. Note that 2d textures can be scaled so as to repeat the pattern as many times as necessary. For cube and skybox textures, the checker pattern is painted on each side of the cube.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TextureBuiltInType.FLAT","title":"FLAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FLAT = 'flat'\n</code></pre> <p>Fills the entire texture with rgb1, except for the bottom face of cube and skybox textures which is filled with rgb2.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Mark","title":"Mark","text":"<p>               Bases: <code>StrEnum</code></p> <p>Procedural textures can be marked with the markrgb color, on top of the colors determined by the builtin type. All markings are one-pixel wide, thus the markings appear larger and more diffuse on smaller textures.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Mark.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>NONE = 'none'\n</code></pre> <p>No marks.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Mark.EDGE","title":"EDGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>EDGE = 'edge'\n</code></pre> <p>Edges of all texture images are marked.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Mark.CROSS","title":"CROSS  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CROSS = 'cross'\n</code></pre> <p>A cross is marked in the middle of each image.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Mark.RANDOM","title":"RANDOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>RANDOM = 'random'\n</code></pre> <p>Randomly chosen pixels are marked.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Sleep","title":"Sleep","text":"<p>               Bases: <code>StrEnum</code></p> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Sleep.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AUTO = 'auto'\n</code></pre> <p>Compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Sleep.NEVER","title":"NEVER  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>NEVER = 'never'\n</code></pre> <p>Constitute user overrides of the automatic compiler policy.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Sleep.ALLOWED","title":"ALLOWED  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ALLOWED = 'allowed'\n</code></pre> <p>Constitute user overrides of the automatic compiler policy.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Sleep.INIT","title":"INIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>INIT = 'init'\n</code></pre> <p>Can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.JointType","title":"JointType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Types of joints supported in MuJoCo.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.JointType.FREE","title":"FREE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FREE = 'free'\n</code></pre> <p>Free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.JointType.BALL","title":"BALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>BALL = 'ball'\n</code></pre> <p>A ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.JointType.SLIDE","title":"SLIDE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SLIDE = 'slide'\n</code></pre> <p>A sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.JointType.HINGE","title":"HINGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>HINGE = 'hinge'\n</code></pre> <p>A hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Limited","title":"Limited","text":"<p>               Bases: <code>StrEnum</code></p> <p>Specifies if the joint has limits.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Limited.FALSE","title":"FALSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FALSE = 'false'\n</code></pre> <p>Joint limits are disabled.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Limited.TRUE","title":"TRUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TRUE = 'true'\n</code></pre> <p>Joint limits are enabled.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Limited.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AUTO = 'auto'\n</code></pre> <p>Joint limits will be enabled if range is defined (if autolimits is set in compiler).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ActuatorFrcLimited","title":"ActuatorFrcLimited","text":"<p>               Bases: <code>StrEnum</code></p> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ActuatorFrcLimited.FALSE","title":"FALSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FALSE = 'false'\n</code></pre> <p>Actuator force clamping is disabled.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ActuatorFrcLimited.TRUE","title":"TRUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TRUE = 'true'\n</code></pre> <p>Actuator force clamping is enabled.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.ActuatorFrcLimited.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AUTO = 'auto'\n</code></pre> <p>Actuator force clamping will be enabled if actuatorfrcrange is defined (if autolimits is set in compiler).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Align","title":"Align","text":"<p>               Bases: <code>StrEnum</code></p> <p>Specifies alignment options for aligning body frame and free joint.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Align.FALSE","title":"FALSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FALSE = 'false'\n</code></pre> <p>No alignment will occur between the body frame and free joint.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Align.TRUE","title":"TRUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TRUE = 'true'\n</code></pre> <p>Body frame and free joint will automatically be aligned with inertial frame.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.Align.AUTO","title":"AUTO  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AUTO = 'auto'\n</code></pre> <p>Compiler's alignfree global attribute will be respected.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FluidShape","title":"FluidShape","text":"<p>               Bases: <code>StrEnum</code></p> <p>Geometry-level fluid interaction model.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FluidShape.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>NONE = 'none'\n</code></pre> <p>I have no clue.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FluidShape.ELLIPSOID","title":"ELLIPSOID  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ELLIPSOID = 'ellipsoid'\n</code></pre> <p>Activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TrackingMode","title":"TrackingMode","text":"<p>               Bases: <code>StrEnum</code></p> <p>Specifies how the camera/light position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the camera/light sees).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TrackingMode.FIXED","title":"FIXED  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FIXED = 'fixed'\n</code></pre> <p>The position and orientation specified are fixed relative to the body where the camera/light is defined.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TrackingMode.TRACK","title":"TRACK  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TRACK = 'track'\n</code></pre> <p>The camera/light position is at a constant offset from the body in world coordinates, while the camera/light orientation is constant in world coordinates. These constants are determined by applying forward kinematics in qpos0 and treating the camera/light as fixed. Tracking can be used for example to position a camera/light above a body, point it down so it sees the body, and have it always remain above the body no matter how the body translates and rotates.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TrackingMode.TRACKCOM","title":"TRACKCOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TRACKCOM = 'trackcom'\n</code></pre> <p>similar to \"track\" but the constant spatial offset is defined relative to the center of mass of the kinematic subtree starting at the body in which the camera/light is defined. This can be used to keep an entire mechanism in view. Note that the subtree center of mass for the world body is the center of mass of the entire model. So if a camera/light is defined in the world body in mode \"trackcom\", it will track the entire model.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TrackingMode.TARGETBODY","title":"TARGETBODY  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TARGETBODY = 'targetbody'\n</code></pre> <p>The camera/light position is fixed in the body frame, while the camera/light orientation is adjusted so that it always points towards the targeted body (which is specified with the target attribute below). This can be used for example to model an eye that fixates a moving object; the object will be the target, and the camera/light/eye will be defined in the body corresponding to the head.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.TrackingMode.TARGETBODYCOM","title":"TARGETBODYCOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TARGETBODYCOM = 'targetbodycom'\n</code></pre> <p>The same as \"targetbody\" but the camera/light is oriented towards the center of mass of the subtree starting at the target body.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LightType","title":"LightType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Determines the type of light. Note that some light types may not be supported by some renderers (e.g. only spot and directional lights are supported by the default native renderer).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LightType.SPOT","title":"SPOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>SPOT = 'spot'\n</code></pre> <p>Supported by default native renderer</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LightType.DIRECTIONAL","title":"DIRECTIONAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>DIRECTIONAL = 'directional'\n</code></pre> <p>Supported by default native renderer</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LightType.POINT","title":"POINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>POINT = 'point'\n</code></pre> <p>Not supported by default native renderer</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.LightType.IMAGE","title":"IMAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>IMAGE = 'image'\n</code></pre> <p>Not supported by default native renderer</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompDOF","title":"FlexCompDOF","text":"<p>               Bases: <code>StrEnum</code></p> <p>The parametrization of the flex's degrees of freedom (dofs).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompDOF.FULL","title":"FULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>FULL = 'full'\n</code></pre> <p>Three translational dofs per vertex. This is the most expressive but also the most expensive option.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompDOF.RADIAL","title":"RADIAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>RADIAL = 'radial'\n</code></pre> <p>A single radial translational dof per vertex. Note that unlike in the \"full\" case, the radial parametrization requires a free joint at the flex's parent in order for free body motion to be possible. This type of parametrization is appropriate for shapes that are relatively spherical.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompDOF.TRILINEAR","title":"TRILINEAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>TRILINEAR = 'trilinear'\n</code></pre> <p>Three translational dofs at each corner of the bounding box of the flex, for a total of 24 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using trilinear interpolation over the bounding box.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType","title":"FlexCompType","text":"<p>               Bases: <code>StrEnum</code></p> <p>The type of flexcomp object.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.GRID","title":"GRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>GRID = 'grid'\n</code></pre> <p><code>grid</code> generates a rectangular grid of points in 1D, 2D or 3D as specified by dim. The number of points in each dimension is determined by count while the grid spacing in each dimension is determined by spacing. Make sure the spacing is sufficiently large relative to radius to avoid permanent contacts. In 2D and 3D the grid is automatically triangulated, and corresponding flex elements are created (triangles or tetrahedra). In 1D the elements are capsules connecting consecutive pairs of points.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.BOX","title":"BOX  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>BOX = 'box'\n</code></pre> <p><code>box</code> generates a 3D box object, however flex bodies are only generated on the outer shell. Each flex body has a radial slider joint allowing it to move in and out from the center of the box. The parent body would normally be a floating body. The box surface is triangulated, and each flex element is a tetrahedron connecting the center of the box with one triangle face. count and spacing determine the count and spacing of the flex bodies, similar to the grid type in 3D. Note that the resulting flex has the same topology as the box generated by composite.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.CYLINDER","title":"CYLINDER  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CYLINDER = 'cylinder'\n</code></pre> <p><code>cylinder</code> is the same as box, except the points are projected on the surface of a cylinder.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.ELLIPSOID","title":"ELLIPSOID  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ELLIPSOID = 'ellipsoid'\n</code></pre> <p><code>ellipsoid</code> is the same as box, except the points are projected on the surface of an ellipsoid.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.DISC","title":"DISC  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>DISC = 'disc'\n</code></pre> <p><code>disc</code> is the same as box, except the points are projected on the surface of a disc. It is only compatible with dim=2.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.CIRCLE","title":"CIRCLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>CIRCLE = 'circle'\n</code></pre> <p><code>circle</code> is the same as grid, except the points are sampled along a circle so that the first and last points are the same. The radius of the circle is computed such that each segment has the requested spacing. It is only compatible with dim=1.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.MESH","title":"MESH  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>MESH = 'mesh'\n</code></pre> <p><code>mesh</code> loads the flexcomp points and elements (i.e. triangles) from a mesh file, in the same file formats as mesh assets, excluding the legacy .msh format. A mesh asset is not actually added to the model. Instead the vertex and face data from the mesh file are used to populate the point and element data of the flexcomp. dim is automatically set to 2. Recall that a mesh asset in MuJoCo can be used as a rigid geom attached to a single body. In contrast, the flex generated here corresponds to a soft mesh with the same initial shape, where each vertex is a separate moving body (unless pinned).</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.GMSH","title":"GMSH  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>GMSH = 'gmsh'\n</code></pre> <p><code>gmsh</code> is similar to mesh, but it loads a GMSH file in format 4.1 and format 2.2 (ascii or binary). The file extension can be anything; the parser recognizes the format by examining the file header. This is a very rich file format, allowing all kinds of elements with different dimensionality and topology. MuJoCo only supports GMSH element types 1, 2, 4 which happen to correspond to our 1D, 2D and 3D flexes and assumes that the nodes are specified in a single block. Only the Nodes and Elements sections of the GMHS file are processed, and used to populate the point and element data of the flexcomp. The parser will generate an error if the GMSH file contains meshes that are not supported by MuJoCo. dim is automatically set to the dimensionality specified in the GMSH file. Presently this is the only mechanism to load a large tetrahedral mesh in MuJoCo and generate a corresponding soft entity. If such a mesh is available in a different file format, use the freely available GMSH software to convert it to GMSH in one of the supported versions.</p>"},{"location":"reference/mujoco_mojo/typing/#mujoco_mojo.typing.FlexCompType.DIRECT","title":"DIRECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>DIRECT = 'direct'\n</code></pre> <p><code>direct</code> allows the user to specify the point and element data of the flexcomp directly in the XML. Note that flexcomp will still generate moving bodies automatically, as well as automate other settings; so it still provides convenience compared to specifing the corresponding flex directly.</p>"},{"location":"reference/mujoco_mojo/utils/","title":"utils","text":""},{"location":"reference/mujoco_mojo/utils/#mujoco_mojo.utils","title":"utils","text":""},{"location":"reference/mujoco_mojo/mjcf/","title":"mjcf","text":""},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf","title":"mjcf","text":"<p>MJCF is a collection of classes made to make building your own MJCF easier with Python.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Orientation","title":"Orientation  <code>module-attribute</code>","text":"Python<pre><code>Orientation = Annotated[\n    Quat | AxisAngle | Euler | XYAxes | ZAxis,\n    Field(discriminator=\"type\"),\n]\n</code></pre> <p>Discriminated union for type hinting the various types of Orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco","title":"Mujoco","text":"<p>               Bases: <code>XMLModel</code></p> <p>The unique top-level element, identifying the XML file as an MJCF model file.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>model: ModelName = ModelName('MuJoCo Model')\n</code></pre> <p>The name of the model. This name is shown in the title bar of simulate.cc.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Asset","title":"Asset","text":"<p>               Bases: <code>XMLModel</code></p> <p>This is a grouping element for defining assets. It does not have attributes. Assets are created in the model so that they can be referenced from other model elements; recall the discussion of Assets in the Overview chapter. Assets opened from a file can be identified in two different ways: filename extensions or the content_type attribute. MuJoCo will attempt to open a file specified by the content type provided, and only defaults to the filename extension if no content_type attribute is specified. The content type is ignored if the asset isn't loaded from a file.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Asset.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Asset.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Asset.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Asset.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach","title":"Attach","text":"<p>               Bases: <code>XMLModel</code></p> <p>The attach element is used to insert a sub-tree of bodies from another model into this model's kinematic tree. Unlike include, which is implemented in the parser and is equivalent to copying and pasting XML from one file into another, attach is implemented in the model compiler. In order to use this element, the sub-model must first be defined as an asset. When creating an attachment, the top body of the attached subtree is specified, and all referencing elements outside the kinematic tree (e.g., sensors and actuators), are also copied into the top-level model. Additionally, any elements referenced from within the attached subtree (e.g. defaults and assets) will be copied in to the top-level model. attach is a Meta elements, so upon saving all attachments will appear in the saved XML file. Note that this element is a subset of the functionality of the procedural attachment functionality. As such, it shares the same limitations as described there. In addition, when the attach element is used, it is not possible to attach an entire model (i.e. including all elements, referenced or not).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach.model","title":"model  <code>instance-attribute</code>","text":"Python<pre><code>model: ModelName\n</code></pre> <p>The sub-model from which to attach a subtree.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach.body","title":"body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>body: BodyName | None = None\n</code></pre> <p>Name of the body in the sub-model to attach here. The body and its subtree will be attached. If this attribute is not specified, the contents of the world body will be attached in a new frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach.prefix","title":"prefix  <code>instance-attribute</code>","text":"Python<pre><code>prefix: str\n</code></pre> <p>Prefix to prepend to names of elements in the sub-model. This attribute is required to prevent name collisions with the parent or when attaching the same sub-tree multiple times.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Attach.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body","title":"Body","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: BodyName | None = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: str | None = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: bool = False\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: float = 0\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Sleep = AUTO\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.inertial","title":"inertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertial: Inertial | None = None\n</code></pre> <p>Inertial assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[Joint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.freejoints","title":"freejoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>freejoints: Sequence[FreeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Free joints assigned to body. Defining more than one free joint will not do anything</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.geoms","title":"geoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geoms: Sequence[Geom] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Geometries assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.sites","title":"sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sites: Sequence[Site] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Sites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.cameras","title":"cameras  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cameras: Sequence[Camera] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Cameras assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.lights","title":"lights  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>lights: Sequence[Light] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Lights assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.composites","title":"composites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>composites: Sequence[Composite] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.flexcomps","title":"flexcomps  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flexcomps: Sequence[FlexComp] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Flexible composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.attaches","title":"attaches  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attaches: Sequence[Attach] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Attach elements assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.frames","title":"frames  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frames: Sequence[float] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Frames assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.bodies","title":"bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bodies: Sequence[Body] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Bodies assigned to body. Handled recursively.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera","title":"Camera","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a camera, which moves with the body where it is defined. To create a fixed camera, define it in the world body. The cameras created here are in addition to the default free camera which is always defined and is adjusted via the visual element. Internally MuJoCo uses a flexible camera model, where the viewpoint and projection surface are adjusted independently so as to obtain oblique projections needed for virtual environments. This functionality however is not accessible through MJCF. Instead, the cameras created with this element (as well as the free camera) have a viewpoint that is always centered in front of the projection surface. The viewpoint coincides with the center of the camera frame. The camera is looking along the -Z axis of its frame. The +X axis points to the right, and the +Y axis points up. Thus the frame position and orientation are the key adjustments that need to be made here.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: CameraName | None = None\n</code></pre> <p>Name of the camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This attribute specifies how the camera position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the camera sees).</p> <ul> <li><code>fixed</code> means that the position and orientation specified below are fixed relative to the body where the camera is defined.</li> <li><code>track</code> means that the camera position is at a constant offset from the body in world coordinates, while the camera orientation is constant in world coordinates. These constants are determined by applying forward kinematics in qpos0 and treating the camera as fixed. Tracking can be used for example to position a camera above a body, point it down so it sees the body, and have it always remain above the body no matter how the body translates and rotates.</li> <li><code>trackcom</code> is similar to \"track\" but the constant spatial offset is defined relative to the center of mass of the kinematic subtree starting at the body in which the camera is defined. This can be used to keep an entire mechanism in view. Note that the subtree center of mass for the world body is the center of mass of the entire model. So if a camera is defined in the world body in mode \"trackcom\", it will track the entire model.</li> <li><code>targetbody</code> means that the camera position is fixed in the body frame, while the camera orientation is adjusted so that it always points towards the targeted body (which is specified with the target attribute below). This can be used for example to model an eye that fixates a moving object; the object will be the target, and the camera/eye will be defined in the body corresponding to the head.</li> <li><code>targetbodycom</code> is the same as \"targetbody\" but the camera is oriented towards the center of mass of the subtree starting at the target body.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>When the camera mode is \"targetbody\" or \"targetbodycom\", this attribute becomes required. It specifies which body should be targeted by the camera. In all other modes this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.orthographic","title":"orthographic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orthographic: bool = False\n</code></pre> <p>Whether the camera uses a perspective projection (the default) or an orthographic projection. Setting this attribute changes the semantic of the fovy attribute, see below.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.fovy","title":"fovy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fovy: float = 45\n</code></pre> <p>Vertical field-of-view of the camera. If the camera uses a perspective projection, the field-of-view is expressed in degrees, regardless of the global compiler/angle setting. If the camera uses an orthographic projection, the field-of-view is expressed in units of length; note that in this case the default of 45 is too large for most scenes and should likely be reduced. In either case, the horizontal field of view is computed automatically given the window size and the vertical field of view.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>resolution: tuple[int, int] = (1, 1)\n</code></pre> <p>Resolution of the camera in pixels [width height]. Note that these values are not used for rendering since those dimensions are determined by the size of the rendering context. This attribute serves as a convenient location to save the required resolution when creating a context.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.focal","title":"focal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focal: Vec2 = array((0, 0))\n</code></pre> <p>Focal length of the camera in length units. It is mutually exclusive with fovy. See Cameras for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.focalpixel","title":"focalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focalpixel: tuple[int, int] = (1, 1)\n</code></pre> <p>Focal length of the camera in pixel units. If both focal and focalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.principal","title":"principal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principal: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in length units. It is mutually exclusive with fovy.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.principalpixel","title":"principalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principalpixel: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in pixel units. If both principal and principalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.sensorsize","title":"sensorsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensorsize: Vec2 = array((0, 0))\n</code></pre> <p>Size of the camera sensor in length units. It is mutually exclusive with fovy. If specified, resolution and focal are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.ipd","title":"ipd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ipd: float = 0.068\n</code></pre> <p>Inter-pupilary distance. This attribute only has an effect during stereoscopic rendering. It specifies the distance between the left and right viewpoints. Each viewpoint is shifted by +/- half of the distance specified here, along the X axis of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the camera frame. See Frame orientations. Note that specifically for cameras, the xyaxes attribute is semantically convenient as the X and Y axes correspond to the directions \"right\" and \"up\" in pixel space, respectively.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Camera.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler","title":"Compiler","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.autolimits","title":"autolimits  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autolimits: bool = True\n</code></pre> <p>This attribute affects the behavior of attributes such as \"limited\" (on  or ), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on ). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.boundmass","title":"boundmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundmass: float = 0\n</code></pre> <p>This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.boundinertia","title":"boundinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundinertia: float = 0\n</code></pre> <p>This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.settotalmass","title":"settotalmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>settotalmass: float = -1\n</code></pre> <p>If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.balanceinertia","title":"balanceinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>balanceinertia: bool = False\n</code></pre> <p>A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.strippath","title":"strippath  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>strippath: bool = False\n</code></pre> <p>When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.coordinate","title":"coordinate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>coordinate: Coordinate = LOCAL\n</code></pre> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>angle: Angle = DEGREE\n</code></pre> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.fitaabb","title":"fitaabb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitaabb: bool = False\n</code></pre> <p>The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.eulerseq","title":"eulerseq  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerseq: EulerSeq | str = xyz\n</code></pre> <p>This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.meshdir","title":"meshdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meshdir: Path | None = None\n</code></pre> <p>This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.texturedir","title":"texturedir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texturedir: Path | None = None\n</code></pre> <p>This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.assetdir","title":"assetdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>assetdir: Path | None = None\n</code></pre> <p>This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.discardvisual","title":"discardvisual  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>discardvisual: bool = False\n</code></pre> <p>This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.</p> <ul> <li>All materials are discarded.</li> <li>All textures are discarded.</li> <li>All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.</li> <li>All meshes which are not referenced by any geom (in particular those discarded above) are discarded.</li> </ul> <p>The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.usethread","title":"usethread  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>usethread: bool = True\n</code></pre> <p>If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.fusestatic","title":"fusestatic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fusestatic: bool = False\n</code></pre> <p>This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless</p> <ul> <li>They are referenced by another element in the model.</li> <li>They contain a site which is referenced by a force or torque sensor.</li> </ul> <p>This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.inertiafromgeom","title":"inertiafromgeom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiafromgeom: InertiaFromGeom = AUTO\n</code></pre> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.alignfree","title":"alignfree  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>alignfree: bool = False\n</code></pre> <p>This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.inertiagrouprange","title":"inertiagrouprange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiagrouprange: InertiaGroupRange = (0, 5)\n</code></pre> <p>This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.saveinertial","title":"saveinertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>saveinertial: bool = False\n</code></pre> <p>If set to \"true\", the compiler will save explicit inertial clauses for all bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite","title":"Composite","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>prefix: str | None = None\n</code></pre> <p>All automatically generated model elements have names indicating the element type and index. For example, the body at coordinates (2, 0) in a 2D grid is named \"B2_0\" by default. If prefix=\"C\" is specified, the same body is named \"CB2_0\". The prefix is needed when multiple composite objects are used in the same model, to avoid name conflicts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: CompositeType = CABLE\n</code></pre> <p>This attribute determines the type of composite object. The only supported type is cable.</p> <p>The <code>cable</code> type creates a 1D chain of bodies connected with ball joints, each having a geom with user-defined type (cylinder, capsule or box). The geometry can either be defined with an array of 3D vertex coordinates vertex or with prescribed functions with the option curve. Currently, only linear and trigonometric functions are supported. For example, an helix can be obtained with curve=\"cos(s) sin(s) s\". The size is set with the option size, resulting in f(s)={size[1]\u22c5cos(2\u03c0\u22c5size[2]), size[1]\u22c5sin(2\u03c0\u22c5size[2]),  size[0]\u22c5s}.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.count","title":"count  <code>instance-attribute</code>","text":"Python<pre><code>count: Tuple[int] | Tuple[int, int] | Tuple[int, int, int]\n</code></pre> <p>The element count in each dimension of the grid. This can have 1, 2 or 3 numbers, specifying the element count along the X, Y and Z axis of the parent body frame within. Any missing numbers default to 1. If any of these numbers is 1, all subsequent numbers must also be 1, so that the leading dimensions of the grid are used. This means for example that a 1D grid will always extend along the X axis. To achieve a different orientation, rotate the frame of the parent body. Note that some types imply a grid of certain dimensionality, so the requirements for this attribute depend on the specified type.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>offset: Vec3 = array((0, 0, 0))\n</code></pre> <p>It specifies a 3D offset from the center of the parent body to the center of the first body of the cable. The offset is expressed in the local coordinate frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Quat = Quat(quat=array((1, 0, 0, 0)))\n</code></pre> <p>It specifies a quaternion that rotates the first body frame. The quaternion is expressed in the parent body frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: VecN | None = None\n</code></pre> <p>Vertex 3D positions in global coordinates.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.initial","title":"initial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>initial: CompositeInitial = NONE\n</code></pre> <p>Behavior of the first point. Free: free joint. Ball: ball joint. None: no dof.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.curve","title":"curve  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>curve: tuple[str, str, str] | None = None\n</code></pre> <p>Functions specifying the vertex positions. Available functions are s, cos(s), and sin(s), where s is the arc length parameter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: tuple[int, int, int] | None = None\n</code></pre> <p>Scaling of the curve functions. size[0] is the scaling of s, size[1] is the radius of cos(s) and sin(s), and size[2] is the speed of the argument (i.e. cos(2pisize[2]*s)).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[CompositeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.geom","title":"geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geom: CompositeGeom | None = None\n</code></pre> <p>Geometry assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.site","title":"site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>site: CompositeSite | None = None\n</code></pre> <p>Site assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.skin","title":"skin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>skin: Skin | None = None\n</code></pre> <p>Skin assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Composite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint","title":"CompositeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>Depending on the composite type, some joints are created automatically (e.g. the universal joints in rope) while other joints are optional (e.g. the stretch and twist joints in rope). This sub-element is used to specify which optional joints should be created, as well as to adjust the attributes of both automatic and optional joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.kind","title":"kind  <code>instance-attribute</code>","text":"Python<pre><code>kind: CompositeJointKind\n</code></pre> <p>The joint kind here is orthogonal to the joint type in the rest of MJCF. The joint kind refers to the function of the joint within the mechanism comprising the composite body, while the joint type (hinge or slide) is implied by the joint kind and composite body type.</p> <p>The main kind corresponds to the main joints forming each composite type. These joints are automatically included in the model even if the joint sub-element is missing. The main joints are 3D sliders for particle and grid; 1D sliders for box, cylinder and rope; universal joints for cloth, rope and loop. Even though the main joints are included automatically, this sub-element is still useful for adjusting their attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.solreffix","title":"solreffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffix: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.solimpfix","title":"solimpfix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfix: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Joint stiffness. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.</p> <p>Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite","title":"CompositeSite","text":"<p>               Bases: <code>SiteBase</code></p> <p>This sub-element adjusts the attributes of the sites in the composite object. Otherwise it is the same as geom above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>Sizes of the geometric shape representing the site. What shape it is I do not know.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.CompositeSite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: EnableDisable = ENABLE\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: EnableDisable = ENABLE\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: EnableDisable = ENABLE\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: EnableDisable = ENABLE\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: EnableDisable = ENABLE\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: EnableDisable = ENABLE\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: EnableDisable = ENABLE\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: EnableDisable = DISABLE\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: EnableDisable = DISABLE\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: EnableDisable = DISABLE\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p> <p>flag value at initialization time</p> <p>Unlike any other flag, the sleep flag has an effect during mjData initialization (mj_makeData or mj_resetData). First, it must be set at initialization time in order for the sleep-init policy to take effect. Second, it must be set in order for static quantities to be computed. See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp","title":"FlexComp","text":"<p>               Bases: <code>XMLModel</code></p> <p>Similar to composite, this element (new in MuJoCo 3.0) is not a model element, but rather a macro which expands into multiple model elements representing a deformable entity. In particular this macro creates one flex element, a number of bodies that are children of the body in which the flexcomp is defined, and optionally one flex equality which constrains all flex edges to their initial length. A number of attributes are specified here and then passed through to the automatically-constructed flex. The primary role of flexcomp is to automate the creation of a (possibly large) collection of moving bodies with corresponding joints, and connect them with stretchable flex elements. See flex and deformable objects documentation for specifics on how flexes work. Here we only describe the automated construction process.</p> <p>An important distinction between flex and flexcomp is that the flex references bodies and specifies vertex coordinates in the frames of those bodies, while the flexcomp defines points. Each flexcomp point corresponds to one body and one vertex in the underlying flex. If the flexcomp point is pinned, the corresponding flex body is the parent body of the flexcomp, while the corresponding flex vertex coordinates equal the flexcomp point coordinates. If the flexcomp point is not pinned, a new child body is created at the coordinates of the flexcomp point (within the flexcomp parent body), and then the coordinates of the flex vertex within that new body are (0,0,0). The mechanism for pinning flexcomp points is explained below.</p> <p>Composite objects (available prior to MuJoCo 3.0) needed bodies with geoms for collisions, and sites for connecting tendons which generated shape-preserving forces. In contrast, flexes generate their own collisions and shape-preserving forces (as well as rendering), thus the bodies created here are much simpler: no geoms, sites or tendons are needed. Most of the bodies created here have 3 orthogonal slider joints, corresponding to freely moving point masses. In some cases we generate radial slider joints, allowing only expansion and contraction. Since no geoms are generated, the bodies need to have explicit inertial parameters.</p> <p>Below is a simple example of a flexcomp, modeling a (somewhat flexible) double pendulum with one end pinned to the world:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;flexcomp name=\"FL\" type=\"grid\" dim=\"1\" count=\"3 1 1\" mass=\"3\" spacing=\"0.2 0.2 0.2\"&gt;\n            &lt;pin id=\"0\"/&gt;\n        &lt;/flexcomp&gt;\n    &lt;/worldbody&gt;\n&lt;/mujoco&gt;\n</code></pre> <p>This flexcomp has 3 points, however the first point is pinned to the world (i.e. the parent of the flexcomp) and so only two bodies are automatically created, namely FL_1 and FL_2. Here is what this flexcomp generates after loading and saving the XML:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"FL_1\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n        &lt;body name=\"FL_2\" pos=\"0.2 0 0\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n    &lt;deformable&gt;\n        &lt;flex name=\"FL\" dim=\"1\" body=\"world FL_1 FL_2\" vertex=\"-0.2 0 0 0 0 0 0 0 0\" element=\"0 1 1 2\"/&gt;\n    &lt;/deformable&gt;\n    &lt;equality&gt;\n        &lt;flex flex=\"FL\"/&gt;\n    &lt;/equality&gt;\n&lt;/mujoco&gt;\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>The name of the flex element being generated automatically. This name is used as a prefix for all bodies that are automatically generated here, and is also referenced by the corresponding flex equality constraint (if applicable).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dim: int | None = None\n</code></pre> <p>Dimensionality of the flex object. This value must be 1, 2 or 3. The flex elements are capsules in 1D, triangles with radius in 2D, and tetrahedra with radius in 3D. Certain flexcomp types imply a dimensionality, in which case the value specified here is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.dof","title":"dof  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dof: FlexCompDOF | None = None\n</code></pre> <p>The parametrization of the flex's degrees of freedom (dofs). See the video on the right illustrating the different parametrizations with deformable spheres. The three models in the video are respectively sphere_full, sphere_radial and sphere_trilinear.</p> <ul> <li><code>full</code>: Three translational dofs per vertex. This is the most expressive but also the most expensive option.</li> <li><code>radial</code>: A single radial translational dof per vertex. Note that unlike in the \"full\" case, the radial parametrization requires a free joint at the flex's parent in order for free body motion to be possible. This type of parametrization is appropriate for shapes that are relatively spherical.</li> <li><code>trilinear</code>: Three translational dofs at each corner of the bounding box of the flex, for a total of 24 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using trilinear interpolation over the bounding box.</li> </ul> <p>Trilinear and quadratic flexes are much faster than the previous two options, and are the preferred choice if the expected deformations can be captured by the reduced parametriation. For example, see the video on the right comparing full and trilinear flexes for modeling deformable gripper pads.</p> <p>Note that the choice of dof parametrization affects the deformation modes of the flex but has no effect on the accuracy of the collision geometry, which always takes into account the high-resolution mesh of the flex.</p> <ul> <li><code>quadratic</code>: Three translational dofs per corner, edge, face, and volume of the bounding box of the flex, for a total of 81 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using quadratic interpolation over the bounding box. While this option requires more degrees of freedom than trilinear flexes, it enables curved deformation modes, while the only modes achievable for trilinear flexes are strech/compression and shear.</li> </ul> <p>Note that a higher interpolation order generally requires a smaller time step for stability, although usually not as large as with the \"full\" option and a fine mesh.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: FlexCompType | None = None\n</code></pre> <p>This attribute determines the type of flexcomp object. The remaining attributes and sub-elements are then interpreted according to the type. Default settings are also adjusted depending on the type. Different types correspond to different methods for specifying the flexcomp points and the stretchable elements that connect them. They fall in three categories: direct specification entered in the XML, direct specification loaded from file, and automated generation from higher-level specification.</p> <p><code>grid</code> generates a rectangular grid of points in 1D, 2D or 3D as specified by dim. The number of points in each dimension is determined by count while the grid spacing in each dimension is determined by spacing. Make sure the spacing is sufficiently large relative to radius to avoid permanent contacts. In 2D and 3D the grid is automatically triangulated, and corresponding flex elements are created (triangles or tetrahedra). In 1D the elements are capsules connecting consecutive pairs of points.</p> <p><code>box</code> generates a 3D box object, however flex bodies are only generated on the outer shell. Each flex body has a radial slider joint allowing it to move in and out from the center of the box. The parent body would normally be a floating body. The box surface is triangulated, and each flex element is a tetrahedron connecting the center of the box with one triangle face. count and spacing determine the count and spacing of the flex bodies, similar to the grid type in 3D. Note that the resulting flex has the same topology as the box generated by composite.</p> <p><code>cylinder</code> is the same as box, except the points are projected on the surface of a cylinder.</p> <p><code>ellipsoid</code> is the same as box, except the points are projected on the surface of an ellipsoid.</p> <p><code>disc</code> is the same as box, except the points are projected on the surface of a disc. It is only compatible with dim=2.</p> <p><code>circle</code> is the same as grid, except the points are sampled along a circle so that the first and last points are the same. The radius of the circle is computed such that each segment has the requested spacing. It is only compatible with dim=1.</p> <p><code>mesh</code> loads the flexcomp points and elements (i.e. triangles) from a mesh file, in the same file formats as mesh assets, excluding the legacy .msh format. A mesh asset is not actually added to the model. Instead the vertex and face data from the mesh file are used to populate the point and element data of the flexcomp. dim is automatically set to 2. Recall that a mesh asset in MuJoCo can be used as a rigid geom attached to a single body. In contrast, the flex generated here corresponds to a soft mesh with the same initial shape, where each vertex is a separate moving body (unless pinned).</p> <p><code>gmsh</code> is similar to mesh, but it loads a GMSH file in format 4.1 and format 2.2 (ascii or binary). The file extension can be anything; the parser recognizes the format by examining the file header. This is a very rich file format, allowing all kinds of elements with different dimensionality and topology. MuJoCo only supports GMSH element types 1, 2, 4 which happen to correspond to our 1D, 2D and 3D flexes and assumes that the nodes are specified in a single block. Only the Nodes and Elements sections of the GMHS file are processed, and used to populate the point and element data of the flexcomp. The parser will generate an error if the GMSH file contains meshes that are not supported by MuJoCo. dim is automatically set to the dimensionality specified in the GMSH file. Presently this is the only mechanism to load a large tetrahedral mesh in MuJoCo and generate a corresponding soft entity. If such a mesh is available in a different file format, use the freely available GMSH software to convert it to GMSH in one of the supported versions.</p> <p><code>direct</code> allows the user to specify the point and element data of the flexcomp directly in the XML. Note that flexcomp will still generate moving bodies automatically, as well as automate other settings; so it still provides convenience compared to specifing the corresponding flex directly.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>count: tuple[int, int, int] | None = None\n</code></pre> <p>The number of automatically generated points in each dimension. This and the next attribute only apply to types grid, box, cylinder, ellipsoid.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.spacing","title":"spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spacing: Vec3 | None = None\n</code></pre> <p>The spacing between the automatically generated points in each dimension. The spacing should be sufficiently large compared to the radius, to avoid permanent contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.point","title":"point  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>point: VecN | None = None\n</code></pre> <p>The 3D coordinates of the points. This attribute is only used with type direct. All other flexcomp types generate their own points. The points are used to construct bodies and vertices as explained earlier.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.element","title":"element  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>element: tuple[int, ...] | None = None\n</code></pre> <p>The zero-based point ids forming each flex elements. This attribute is only used with type direct. All other flexcomp types generate their own elements. This data is passed through to the automatically-generated flex.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: VecN | None = None\n</code></pre> <p>Texture coordinates of each point, passed through to the automatically-generated flex. Note that flexcomp does not generate texture coordinates automatically, except for 2D grids, box, cylinder and ellipsoid. For all other types, the user can specify explicit texture coordinates here, even if the points themselves were generated automatically. This requires understanding of the layout of the automatically-generated points and how they correspond to the texture referenced by the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>The mass of each automatically-generated body equals this value divided by the number of points. Note that pinning some points does not affect the mass of the other bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.inertiabox","title":"inertiabox  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiabox: float | None = None\n</code></pre> <p>Even though the automatically-generated bodies have the physics of point masses, with slider joints, MuJoCo still requires each body to have rotational inertia. The inertias generated here are diagonal, and are computed such that the corresponding equivalent-inertia boxes have sides equal to this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The name of the file from which a surface (triangular) or volumetric (tetrahedral) mesh is loaded. For surface meshes, the file extension is used to determine the file format. Supported formats are GMSH and the formats specified in mesh assets, excluding the legacy .msh format. Volumetric meshes are supported only in GMSH format. See here for more information on GMSH files.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.rigid","title":"rigid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rigid: bool | None = None\n</code></pre> <p>If this is true, all points correspond to vertices within the parent body, and no new bodies are created. This is equivalent to pinning all points. Note that if all points are indeed pinned, the model compiler will detect that the flex is rigid (which behaves is a non-convex mesh in collision detection).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3 | None = None\n</code></pre> <p>This 3D vector translates all points relative to the frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>If using a quaternion, rotation of all points around the pos vector specified above. Together these two vectors define a pose transformation, used to position and orient the points as needed.</p> <p>Other orientations are options in place of quat.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 | None = None\n</code></pre> <p>Scaling of all point coordinates, for types that specify coordinates explicitly. Scaling is applied after the pose transformation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.radius","title":"radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>radius: float | None = None\n</code></pre> <p>Radius of all flex elements. It can be zero in 3D, but must be positive in 1D and 2D. The radius affects both collision detection and rendering. In 1D and 2D it is needed to make the elements volumetric.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the flex. Note that textures specified in the material will be applied only if the flex has explicit texture coordinates.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 | None = None\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int | None = None\n</code></pre> <p>Integer group to which the flex belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of flexes.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.flatskin","title":"flatskin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flatskin: bool | None = None\n</code></pre> <p>This attribute determines whether 2D and 3D flexes that are rendered in flexskin mode will use smooth or flat shading. The default smooth shading is suitable in most cases, however if the object is intended to have visible sharp edges (such as a cube) then flat shading is more natural.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.origin","title":"origin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>origin: Vec3 | None = None\n</code></pre> <p>The origin of the flexcomp. Used for generating a volumetric mesh from an OBJ surface mesh. Each surface triangle is connected to the origin to create a tetrahedron, so the resulting volumetric mesh is guaranteed to be well-formed only for convex shapes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FlexComp.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Align = AUTO\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox","title":"GeomBox","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a box geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule","title":"GeomCapsule","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a capsule geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder","title":"GeomCylinder","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a cylinder geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid","title":"GeomEllipsoid","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a ellipsoid geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField","title":"GeomHField","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a height field geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[HFIELD] = HFIELD\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>hfield</code> type defines a height field geom. The geom must reference the desired height field asset with the hfield attribute below. The position and orientation of the geom set the position and orientation of the height field. The size of the geom is ignored, and the size parameters of the height field asset are used instead. See the description of the hfield element. Similar to planes, height field geoms can only be attached to the world body or to static children of the world.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.hfield","title":"hfield  <code>instance-attribute</code>","text":"Python<pre><code>hfield: HFieldName\n</code></pre> <p>This attribute must be specified if and only if the geom type is \"hfield\". It references the height field asset to be instantiated at the position and orientation of the geom frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomHField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh","title":"GeomMesh","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a mesh geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[MESH] = MESH\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>mesh</code> type defines a mesh. The geom must reference the desired mesh asset with the mesh attribute. Note that mesh assets can also be referenced from other geom types, causing primitive shapes to be fitted; see below. The size is determined by the mesh asset and the geom size parameters are ignored. Unlike all other geoms, the position and orientation of mesh geoms after compilation do not equal the settings of the corresponding attributes here. Instead they are offset by the translation and rotation that were needed to center and align the mesh asset in its own coordinate frame. Recall the discussion of centering and alignment in the mesh element.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.mesh","title":"mesh  <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomMesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane","title":"GeomPlane","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a plane geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[PLANE] = PLANE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>plane</code> type defines a plane which is infinite for collision detection purposes. It can only be attached to the world body or static children of the world. The plane passes through a point specified via the pos attribute. It is normal to the Z axis of the geom's local frame. The +Z direction corresponds to empty space. Thus the position and orientation defaults of (0,0,0) and (1,0,0,0) would create a ground plane at Z=0 elevation, with +Z being the vertical direction in the world (which is MuJoCo's convention). Since the plane is infinite, it could have been defined using any other point in the plane. The specified position however has additional meaning with regard to rendering. If either of the first two size parameters are positive, the plane is rendered as a rectangle of finite size (in the positive dimensions). This rectangle is centered at the specified position. Three size parameters are required. The first two specify the half- size of the rectangle along the X and Y axes. The third size parameter is unusual: it specifies the spacing between the grid subdivisions of the plane for rendering purposes. The subdivisions are revealed in wireframe rendering mode, but in general they should not be used to paint a grid over the ground plane (textures should be used for that purpose). Instead their role is to improve lighting and shadows, similar to the subdivisions used to render boxes. When planes are viewed from the back, the are automatically made semi-transparent. Planes and the +Z faces of boxes are the only surfaces that can show reflections, if the material applied to the geom has positive reflection. To render an infinite plane, set the first two size parameters to zero.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; spacing between square grid lines for rendering. If either the X or Y half-size is 0, the plane is rendered as infinite in the dimension(s) with 0 size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomPlane.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF","title":"GeomSDF","text":"<p>               Bases: <code>GeomBase</code></p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SDF] = SDF\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>sdf</code> type defines a signed distance field (SDF, also referred to as signed distance function). In order to visualize the SDF, a custom mesh must be specified using the mesh/plugin attribute. See the model/plugin/sdf/ directory for example models with SDF geometries. For more details regarding SDF plugins, see the Extensions chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSDF.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere","title":"GeomSphere","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a sphere geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.GeomSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: HFieldName | None = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: int = 0\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: int = 0\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: VecN | None = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Vec3 | None = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Vec6 | None = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = HINGE\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = array((0, 0, 1))\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Vec2 = array((0, 0))\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = 0\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = array((0, 0))\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = AUTO\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Vec2 = array((0, 0))\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: ActuatorFrcLimited = AUTO\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: bool = False\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: float = 0\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: float = 0\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = 0\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = 0\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = 0\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: LayerRole\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: LengthRangeMode = MUSCLE\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: bool = True\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: bool = False\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: float = 20\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: float = 0\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: float = 1\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: float = 0.01\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: float = 10\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: float = 2\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: float = 0.05\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light","title":"Light","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a light, which moves with the body where it is defined. To create a fixed light, define it in the world body. The lights created here are in addition to the headlight which is always defined and is configured via the visual element. Lights shine along the direction specified by the dir attribute. They do not have a full spatial frame with three orthogonal axes.</p> <p>By default, MuJoCo uses the standard OpenGL (fixed functional) Phong lighting model for its rendering, with augmented with shadow mapping. (See the OpenGL documentation for more information, including details about various attributes.)</p> <p>MJCF also supports alternative lighting models (e.g. physically-based rendering) by providing additional attributes. Attributes may be applied or ignored depending on the lighting model being used.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: LightName | None = None\n</code></pre> <p>Name of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This is identical to the mode attribute of camera. It specifies the how the light position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the light illuminates).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>This is identical to the target attribute of camera above. It specifies which body should be targeted in \"targetbody\" and \"targetbodycom\" modes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: LightType = SPOT\n</code></pre> <p>Determines the type of light. Note that some light types may not be supported by some renderers (e.g. only spot and directional lights are supported by the default native renderer).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.directional","title":"directional  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>directional: bool = False\n</code></pre> <p>This is a deprecated legacy attribute. Please use light type instead. If set to \"true\", and no type is specified, this will change the light type to be directional.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.castshadow","title":"castshadow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>castshadow: bool = True\n</code></pre> <p>If this attribute is \"true\" the light will cast shadows. More precisely, the geoms illuminated by the light will cast shadows, however this is a property of lights rather than geoms. Since each shadow-casting light causes one extra rendering pass through all geoms, this attribute should be used with caution. Higher quality of the shadows is achieved by increasing the value of the shadowsize attribute of quality, as well as positioning spotlights closer to the surface on which shadows appear, and limiting the volume in which shadows are cast. For spotlights this volume is a cone, whose angle is the cutoff attribute below multiplied by the shadowscale attribute of map. For directional lights this volume is a box, whose half-sizes in the directions orthogonal to the light are the model extent multiplied by the shadowclip attribute of map. The model extent is computed by the compiler but can also be overridden by specifying the extent attribute of statistic. Internally the shadow-mapping mechanism renders the scene from the light viewpoint (as if it were a camera) into a depth texture, and then renders again from the camera viewpoint, using the depth texture to create shadows. The internal rendering pass uses the same near and far clipping planes as regular rendering, i.e., these clipping planes bound the cone or box shadow volume in the light direction. As a result, some shadows (especially those very close to the light) may be clipped.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.active","title":"active  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>active: bool = True\n</code></pre> <p>The light is active if this attribute is \"true\". This can be used at runtime to turn lights on and off.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the light. This attribute only affects the rendering for spotlights, but it should also be defined for directional lights because we render the cameras as decorative elements.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dir: Vec3 = array((0, 0, -1))\n</code></pre> <p>Direction of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.diffuse","title":"diffuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diffuse: Vec3 = array((0.7, 0.7, 0.7))\n</code></pre> <p>The color of the light. For the Phong (default) lighting model, this defines the diffuse color of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>The texture to use for image-based lighting. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.intensity","title":"intensity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>intensity: float = 0\n</code></pre> <p>The intensity of the light source, measured in candela, used for physically-based lighting models. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.ambient","title":"ambient  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ambient: Vec3 = array((0, 0, 0))\n</code></pre> <p>The ambient color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Vec3 = array((0.3, 0.3, 0.3))\n</code></pre> <p>The specular color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: float = 10\n</code></pre> <p>The effective range of the light. Objects further than this distance from the light position will not be illuminated by this light. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.bulbradius","title":"bulbradius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bulbradius: float = 0.02\n</code></pre> <p>The radius of the light source which can affect shadow softness depending on the renderer. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.attenuation","title":"attenuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attenuation: Vec3 = array((1, 0, 0))\n</code></pre> <p>These are the constant, linear and quadratic attenuation coefficients for Phong lighting. The default corresponds to no attenuation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.cutoff","title":"cutoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cutoff: float = 45\n</code></pre> <p>Cutoff angle for spotlights, always in degrees regardless of the global angle setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.exponent","title":"exponent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>exponent: float = 10\n</code></pre> <p>Exponent for spotlights. This setting controls the softness of the spotlight cutoff.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Light.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: MaterialName\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Vec2 = array((1, 1))\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: bool = False\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: float = 0\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: float = 0.5\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: float = 0.5\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: float = 0\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: float = -1\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: float = -1\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((1, 1, 1, 1))\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> <p>MuJoCo works with triangulated meshes. They can be loaded from binary STL files, OBJ files or MSH files with custom format described below, or vertex and face data specified directly in the XML. Software such as MeshLab can be used to convert from other mesh formats to STL or OBJ. While any collection of triangles can be loaded as a mesh and rendered, collision detection works with the convex hull of the mesh as explained in Collision detection. The mesh appearance (including texture mapping) is controlled by the material and rgba attributes of the referencing geom, similarly to height fields.</p> <p>Meshes can have explicit texture coordinates instead of relying on the automated texture mapping mechanism. When provided, these explicit coordinates have priority. Note that texture coordinates can be specified with OBJ files and MSH files, as well as explicitly in the XML with the texcoord attribute, but not via STL files. These mechanism cannot be mixed. So if you have an STL mesh, the only way to add texture coordinates to it is to convert to one of the other supported formats.</p> <p>Poorly designed meshes can display rendering artifacts. In particular, the shadow mapping mechanism relies on having some distance between front and back-facing triangle faces. If the faces are repeated, with opposite normals as determined by the vertex order in each triangle, this causes shadow aliasing. The solution is to remove the repeated faces (which can be done in MeshLab) or use a better designed mesh. Flipped faces are checked by MuJoCo for meshes specified as OBJ or XML and an error message is returned.</p> <p>The size of the mesh is determined by the 3D coordinates of the vertex data in the mesh file, multiplied by the components of the scale attribute below. Scaling is applied separately for each coordinate axis. Note that negative scaling values can be used to flip the mesh; this is a legitimate operation. The size parameters of the referencing geoms are ignored, similarly to height fields. We also provide a mechanism to translate and rotate the 3D coordinates, using the attributes refpos and refquat.</p> <p>A mesh can also be defined without faces (a point cloud essentially). In that case the convex hull is constructed automatically.This makes it easy to construct simple shapes directly in the XML. For example, a pyramid can be created as follows:</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh name=\"tetrahedron\" vertex=\"0 0 0  1 0 0  0 1 0  0 0 1\"/&gt;\n&lt;/asset&gt;\n</code></pre> <p>Positioning and orienting is complicated by the fact that vertex data in the source asset are often relative to coordinate frames whose origin is not inside the mesh. In contrast, MuJoCo expects the origin of a geom's local frame to coincide with the geometric center of the shape. We resolve this discrepancy by pre-processing the mesh in the compiler, so that it is centered around (0,0,0) and its principal axes of inertia are the coordinate axes. We save the translation and rotation offsets applied to the source asset in mjModel.mesh_pos and mjModel.mesh_quat; these are required if one reads vertex data from the source and needs to re-apply the transform. These offsets are then composed with the referencing geom's position and orientation; see also the mesh attribute of geom below. Fortunately most meshes used in robot models are designed in a coordinate frame centered at the joint. This makes the corresponding MJCF model intuitive: we set the body frame at the joint, so that the joint position is (0,0,0) in the body frame, and simply reference the mesh. Below is an MJCF model fragment of a forearm, containing all the information needed to put the mesh where one would expect it to be. The body position is specified relative to the parent body, namely the upper arm (not shown). It is offset by 35 cm which is the typical length of the human upper arm. If the mesh vertex data were not designed in the above convention, we would have to use the geom position and orientation (or the refpos, refquat mechanism) to compensate, but in practice this is rarely needed.</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh file=\"forearm.stl\"/&gt;\n&lt;/asset&gt;\n\n&lt;body pos=\"0 0 0.35\"/&gt;\n    &lt;joint type=\"hinge\" axis=\"1 0 0\"/&gt;\n    &lt;geom type=\"mesh\" mesh=\"forearm\"/&gt;\n&lt;/body&gt;\n</code></pre> <p>The inertial computation mentioned above is part of an algorithm used not only to center and align the mesh, but also to infer the mass and inertia of the body to which it is attached. This is done by computing the centroid of the triangle faces, connecting each face with the centroid to form a triangular pyramid, computing the mass and signed inertia of all pyramids (considered solid, or hollow if shellinertia is true) and accumulating them. The sign ensures that pyramids on the outside of the surfaces are subtracted, as can occur with concave geometries. This algorithm can be found in section 1.3.8 of Computational Geometry in C (Second Edition) by Joseph O'Rourke.</p> <p>The full list of processing steps applied by the compiler to each mesh is as follows:</p> <ol> <li>For STL meshes, remove any repeated vertices and re-index the faces if needed. If the mesh is not STL, we assume that the desired vertices and faces have already been generated and do not apply removal or re-indexing;</li> <li>If vertex normals are not provided, generate normals automatically, using a weighted average of the surrounding face normals. If sharp edges are encountered, the renderer uses the face normals to preserve the visual information about the edge, unless smoothnormal is true. Note that normals cannot be provided with STL meshes;</li> <li>Scale, translate and rotate the vertices and normals, re-normalize the normals in case of scaling. Save these transformations in mjModel.mesh_{pos, quat, scale}.</li> <li>Construct the convex hull if specified;</li> <li>Find the centroid of all triangle faces, and construct the union-of-pyramids representation. Triangles whose area is too small (below the mjMINVAL value of 1E-14) result in compile error;</li> <li>Compute the center of mass and inertia matrix of the union-of-pyramids. Use eigenvalue decomposition to find the principal axes of inertia. Center and align the mesh, saving the translational and rotational offsets for subsequent geom-related computations.</li> </ol>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: ModelName | None = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option","title":"Option","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: float = 0.002\n</code></pre> <p>Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.impratio","title":"impratio  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>impratio: float = 1\n</code></pre> <p>This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Vec3 = array((0, 0, -9.81))\n</code></pre> <p>Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>wind: Vec3 = array((0, 0, 0))\n</code></pre> <p>Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.magnetic","title":"magnetic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>magnetic: Vec3 = array((0, -0.5, 0))\n</code></pre> <p>Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 0\n</code></pre> <p>Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.viscosity","title":"viscosity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>viscosity: float = 0\n</code></pre> <p>Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_margin","title":"o_margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_margin: float = 0\n</code></pre> <p>This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_solref","title":"o_solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These attributes replace the solref parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_solimp","title":"o_solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These attributes replace the solimp parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_friction","title":"o_friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_friction: Vec3 = FRICTION_DEFAULT\n</code></pre> <p>These attributes replace the friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.integrator","title":"integrator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>integrator: Integrator = EULER\n</code></pre> <p>This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.cone","title":"cone  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cone: Cone = PYRAMIDAL\n</code></pre> <p>The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.jacobian","title":"jacobian  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>jacobian: Jacobian = AUTO\n</code></pre> <p>The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.solver","title":"solver  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solver: Solver = NEWTON\n</code></pre> <p>This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.iterations","title":"iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>iterations: int = 100\n</code></pre> <p>Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolerance: float = 1e-08\n</code></pre> <p>Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ls_iterations","title":"ls_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_iterations: int = 50\n</code></pre> <p>Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ls_tolerance","title":"ls_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_tolerance: float = 0.01\n</code></pre> <p>Tolerance threshold used for early termination of the linesearch algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.noslip_iterations","title":"noslip_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_iterations: int = 0\n</code></pre> <p>Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.noslip_tolerance","title":"noslip_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_tolerance: float = 1e-06\n</code></pre> <p>Tolerance threshold used for early termination of the Noslip solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ccd_iterations","title":"ccd_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_iterations: int = 50\n</code></pre> <p>Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ccd_tolerance","title":"ccd_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_tolerance: float = 1e-06\n</code></pre> <p>Tolerance threshold used for early termination of the convex collision algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.sleep_tolerance","title":"sleep_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep_tolerance: float = 0.0001\n</code></pre> <p>Velocity tolerance below which sleeping is allowed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.sdf_iterations","title":"sdf_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_iterations: int = 10\n</code></pre> <p>Number of iterations used for Signed Distance Field collisions (per initial point).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.sdf_initpoints","title":"sdf_initpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_initpoints: int = 40\n</code></pre> <p>Number of starting points used for finding contacts with Signed Distance Field collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.actuatorgroupdisable","title":"actuatorgroupdisable  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgroupdisable: set[ActuatorGroup] | None = None\n</code></pre> <p>List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox","title":"SiteBox","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a box site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule","title":"SiteCapsule","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a capsule site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder","title":"SiteCylinder","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a cylinder site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid","title":"SiteEllipsoid","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a ellipsoid site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere","title":"SiteSphere","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a sphere site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.SiteSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size","title":"Size","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>memory: str = '-1'\n</code></pre> <p>This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuserdata","title":"nuserdata  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuserdata: int = 0\n</code></pre> <p>The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nkey","title":"nkey  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nkey: int = 0\n</code></pre> <p>The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_body","title":"nuser_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_body: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_jnt","title":"nuser_jnt  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_jnt: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_geom","title":"nuser_geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_geom: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_site","title":"nuser_site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_site: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_cam","title":"nuser_cam  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_cam: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_tendon","title":"nuser_tendon  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_tendon: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each tendon.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_actuator","title":"nuser_actuator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_actuator: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each actuator.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_sensor","title":"nuser_sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_sensor: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each sensor.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin","title":"Skin","text":"<p>               Bases: <code>XMLModel</code></p> <p>If this element is included, the model compiler will generate a skinned mesh asset and attach it to the element bodies of the composite object. Skin can be attached to 2D grid, cloth, box, cylinder and ellipsoid. For other composite types it has no effect. Note that the skin created here is equivalent to a skin specified directly in the XML, as opposed to a skin loaded from file. So if the model is saved as XML, it will contain a large section describing the automatically-generated skin.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: bool = False\n</code></pre> <p>If this is true, explicit texture coordinates will be generated, mapping the skin to the unit square in texture space. This is needed when the material specifies a texture. If texcoord is false and the skin has texture, the texture will appear fixed to the world instead of the skin. The reason for having this attribute in the first place is because skins with texture coordinates upload these coordinates to the GPU even if no texture is applied later. So this attribute should be set to false in cases where no texture will be applied via the material attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.inflate","title":"inflate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inflate: float = 0\n</code></pre> <p>The default value of 0 means that the automatically-generated skin passes through the centers of the body elements comprising the composite object. Positive values offset each skin vertex by the specified amount, in the direction normal to the (non-inflated) skin at that vertex. This has two uses. First, in 2D objects, a small positive inflate factor is needed to avoid aliasing artifacts. Second, collisions are done with geoms that create some thickness, even for 2D objects. Inflating the skin with a value equal to the geom size will render the skin as a \"mattress\" that better represents the actual collision geometry. The value of this attribute is copied into the corresponding attribute of the skin asset being created.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.subgrid","title":"subgrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>subgrid: int = 0\n</code></pre> <p>This is only applicable to cloth and 2D grid types, and has no effect for any other composite type. The default value of 0 means that the skin has as many vertices as the number of element bodies. A positive value causes subdivision, with the specified number of (additional) grid lines. In this case the model compiler generates a denser skin using bi-cubic interpolation. This increases the quality of the rendering (especially in the absence of textures) but also slows down the renderer, so use it with caution. Values above 3 are unlikely to be needed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Skin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic","title":"Statistic","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.meanmass","title":"meanmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meanmass: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.meaninertia","title":"meaninertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meaninertia: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.meansize","title":"meansize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meansize: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>extent: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.center","title":"center  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>center: Vec3 | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: TextureName | None = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: TextureType = CUBE\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: ColorSpace = AUTO\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Path | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: tuple[int, int] = (1, 1)\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: GridLayoutStr = '............'\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {<code>'.'</code>, <code>'R'</code>, <code>'L'</code>, <code>'U'</code>, <code>'D'</code>, <code>'F'</code>, <code>'B'</code>}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The <code>'.'</code> character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody","title":"WorldBody","text":"<p>               Bases: <code>Body</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: BodyName | None = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: str | None = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: bool = False\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: float = 0\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Sleep = AUTO\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.inertial","title":"inertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertial: Inertial | None = None\n</code></pre> <p>Inertial assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[Joint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.freejoints","title":"freejoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>freejoints: Sequence[FreeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Free joints assigned to body. Defining more than one free joint will not do anything</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.geoms","title":"geoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geoms: Sequence[Geom] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Geometries assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.sites","title":"sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sites: Sequence[Site] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Sites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.cameras","title":"cameras  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cameras: Sequence[Camera] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Cameras assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.lights","title":"lights  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>lights: Sequence[Light] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Lights assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.composites","title":"composites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>composites: Sequence[Composite] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.flexcomps","title":"flexcomps  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flexcomps: Sequence[FlexComp] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Flexible composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.attaches","title":"attaches  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attaches: Sequence[Attach] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Attach elements assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.frames","title":"frames  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frames: Sequence[float] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Frames assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.bodies","title":"bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bodies: Sequence[Body] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Bodies assigned to body. Handled recursively.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.AxisAngle","title":"AxisAngle","text":"<p>               Bases: <code>OrientationBase</code></p> <p>These are the quantities (x,y,z,a) mentioned above. The last number is the angle of rotation, in degrees or radians as specified by the angle attribute of compiler. The first three numbers determine a 3D vector which is the rotation axis. This vector is normalized to unit length during compilation, so the user can specify a vector of any non-zero length. Keep in mind that the rotation is right-handed; if the direction of the vector (x,y,z) is reversed this will result in the opposite rotation. Changing the sign of aa can also be used to specify the opposite rotation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.AxisAngle.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.AxisAngle.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.AxisAngle.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Vec4 = array((1, 0, 0, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.AxisAngle.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.AxisAngle.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Euler","title":"Euler","text":"<p>               Bases: <code>OrientationBase</code></p> <p>Rotation angles around three coordinate axes. The sequence of axes around which these rotations are applied is determined by the eulerseq attribute of compiler and is the same for the entire model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Euler.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Euler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Euler.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Vec3 = array((0, 0, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations. The sequence of axes around which these rotations are applied is determined by the eulerseq attribute of compiler and is the same for the entire model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Euler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Euler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Quat","title":"Quat","text":"<p>               Bases: <code>OrientationBase</code></p> <p>If the quaternion is known, this is the preferred was to specify the frame orientation because it does not involve conversions. Instead it is normalized to unit length and copied into mjModel during compilation. When a model is saved as MJCF, all frame orientations are expressed as quaternions using this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Quat.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Quat.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Quat.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Vec4 = array((1, 0, 0, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations. Defined as (w, x, y, z) quaternion order (the same as MuJoCo convention).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Quat.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Quat.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.XYAxes","title":"XYAxes","text":"<p>               Bases: <code>OrientationBase</code></p> <p>The first 3 numbers are the X axis of the frame. The next 3 numbers are the Y axis of the frame, which is automatically made orthogonal to the X axis. The Z axis is then defined as the cross-product of the X and Y axes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.XYAxes.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.XYAxes.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.XYAxes.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Vec6 = array((1, 0, 0, 0, 1, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.XYAxes.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.XYAxes.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.ZAxis","title":"ZAxis","text":"<p>               Bases: <code>OrientationBase</code></p> <p>The Z axis of the frame. The compiler finds the minimal rotation that maps the vector (0,0,1) into the vector specified here. This determines the X and Y axes of the frame implicitly. This is useful for geoms with rotational symmetry around the Z axis, as well as lights - which are oriented along the Z axis of their frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.ZAxis.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.ZAxis.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.ZAxis.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Vec3 = array((0, 0, 1))\n</code></pre> <p>Orientation of the frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.ZAxis.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.ZAxis.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: str | None = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: str | None = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Pos","title":"Pos","text":"<p>               Bases: <code>XMLModel</code></p> <p>Defines a model for positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Pos.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Pos.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Pos.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Pos.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3 = array((0, 0, 0))\n</code></pre> <p>Position (in (x, y, z))</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Pos.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Pos.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/defaults/","title":"defaults","text":""},{"location":"reference/mujoco_mojo/mjcf/defaults/#mujoco_mojo.mjcf.defaults","title":"defaults","text":""},{"location":"reference/mujoco_mojo/mjcf/defaults/#mujoco_mojo.mjcf.defaults.SOLIMP_DEFAULT","title":"SOLIMP_DEFAULT  <code>module-attribute</code>","text":"Python<pre><code>SOLIMP_DEFAULT: Vec5 = array((0.9, 0.95, 0.001, 0.5, 2))\n</code></pre> <p>Default value of <code>solimp</code> parameters. The values are <code>d0</code>, <code>dwidth</code>, <code>width</code>, <code>midpoint</code>, and <code>power</code>.</p>"},{"location":"reference/mujoco_mojo/mjcf/defaults/#mujoco_mojo.mjcf.defaults.SOLREF_DEFAULT","title":"SOLREF_DEFAULT  <code>module-attribute</code>","text":"Python<pre><code>SOLREF_DEFAULT: Vec2 = array((0.02, 1))\n</code></pre> <p>Default value of <code>solimp</code> parameters. The two numbers are <code>timeconst</code> and <code>dampratio</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/","title":"mujoco","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco","title":"mujoco","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco","title":"Mujoco","text":"<p>               Bases: <code>XMLModel</code></p> <p>The unique top-level element, identifying the XML file as an MJCF model file.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>model: ModelName = ModelName('MuJoCo Model')\n</code></pre> <p>The name of the model. This name is shown in the title bar of simulate.cc.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/","title":"orientation","text":""},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation","title":"orientation","text":""},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Orientation","title":"Orientation  <code>module-attribute</code>","text":"Python<pre><code>Orientation = Annotated[\n    Quat | AxisAngle | Euler | XYAxes | ZAxis,\n    Field(discriminator=\"type\"),\n]\n</code></pre> <p>Discriminated union for type hinting the various types of Orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationType","title":"OrientationType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Defines the type field for orientation types (used for discriminated union).</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationType.QUAT","title":"QUAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>QUAT = auto()\n</code></pre> <p>Quaternion type.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationType.AXISANGLE","title":"AXISANGLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>AXISANGLE = auto()\n</code></pre> <p>Axis angle type.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationType.XYAXES","title":"XYAXES  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>XYAXES = auto()\n</code></pre> <p>XY axes type.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationType.ZAXIS","title":"ZAXIS  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ZAXIS = auto()\n</code></pre> <p>Z axis type.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationType.EULER","title":"EULER  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>EULER = auto()\n</code></pre> <p>Euler angle type.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationBase","title":"OrientationBase","text":"<p>               Bases: <code>XMLModel</code></p> <p>Defines the base model for orientations.</p> <p>Several model elements have right-handed spatial frames associated with them. These are all the elements defined in the kinematic tree except for joints. A spatial frame is defined by its position and orientation. Specifying 3D positions is straightforward, but specifying 3D orientations can be challenging. This is why MJCF provides several alternative mechanisms. No matter which mechanism the user chooses, the frame orientation is always converted internally to a unit quaternion. Recall that a 3D rotation by angle aa around axis given by the unit vector (x,y,z) corresponds to the quaternion ((cos(a/2),sin(a/2)\u22c5(x,y,z)). Also recall that every 3D orientation can be uniquely specified by a single 3D rotation by some angle around some axis.</p> <p>All MJCF elements that have spatial frames allow the five attributes listed below. The frame orientation is specified using at most one of these attributes. The quat attribute has a default value corresponding to the null rotation, while the others are initialized in the special undefined state. Thus if none of these attributes are specified by the user, the frame is not rotated.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationBase.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationBase.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationBase.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.OrientationBase.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Quat","title":"Quat","text":"<p>               Bases: <code>OrientationBase</code></p> <p>If the quaternion is known, this is the preferred was to specify the frame orientation because it does not involve conversions. Instead it is normalized to unit length and copied into mjModel during compilation. When a model is saved as MJCF, all frame orientations are expressed as quaternions using this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Quat.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Vec4 = array((1, 0, 0, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations. Defined as (w, x, y, z) quaternion order (the same as MuJoCo convention).</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Quat.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Quat.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Quat.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Quat.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.AxisAngle","title":"AxisAngle","text":"<p>               Bases: <code>OrientationBase</code></p> <p>These are the quantities (x,y,z,a) mentioned above. The last number is the angle of rotation, in degrees or radians as specified by the angle attribute of compiler. The first three numbers determine a 3D vector which is the rotation axis. This vector is normalized to unit length during compilation, so the user can specify a vector of any non-zero length. Keep in mind that the rotation is right-handed; if the direction of the vector (x,y,z) is reversed this will result in the opposite rotation. Changing the sign of aa can also be used to specify the opposite rotation.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.AxisAngle.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Vec4 = array((1, 0, 0, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.AxisAngle.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.AxisAngle.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.AxisAngle.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.AxisAngle.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Euler","title":"Euler","text":"<p>               Bases: <code>OrientationBase</code></p> <p>Rotation angles around three coordinate axes. The sequence of axes around which these rotations are applied is determined by the eulerseq attribute of compiler and is the same for the entire model.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Euler.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Vec3 = array((0, 0, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations. The sequence of axes around which these rotations are applied is determined by the eulerseq attribute of compiler and is the same for the entire model.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Euler.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Euler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Euler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.Euler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.XYAxes","title":"XYAxes","text":"<p>               Bases: <code>OrientationBase</code></p> <p>The first 3 numbers are the X axis of the frame. The next 3 numbers are the Y axis of the frame, which is automatically made orthogonal to the X axis. The Z axis is then defined as the cross-product of the X and Y axes.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.XYAxes.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Vec6 = array((1, 0, 0, 0, 1, 0))\n</code></pre> <p>Orientation of the frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.XYAxes.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.XYAxes.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.XYAxes.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.XYAxes.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.ZAxis","title":"ZAxis","text":"<p>               Bases: <code>OrientationBase</code></p> <p>The Z axis of the frame. The compiler finds the minimal rotation that maps the vector (0,0,1) into the vector specified here. This determines the X and Y axes of the frame implicitly. This is useful for geoms with rotational symmetry around the Z axis, as well as lights - which are oriented along the Z axis of their frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.ZAxis.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Vec3 = array((0, 0, 1))\n</code></pre> <p>Orientation of the frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.ZAxis.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.ZAxis.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.ZAxis.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/orientation/#mujoco_mojo.mjcf.orientation.ZAxis.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/plugin/","title":"plugin","text":""},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin","title":"plugin","text":""},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: str | None = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: str | None = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/plugin/#mujoco_mojo.mjcf.plugin.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/position/","title":"position","text":""},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position","title":"position","text":""},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position.Pos","title":"Pos","text":"<p>               Bases: <code>XMLModel</code></p> <p>Defines a model for positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position.Pos.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3 = array((0, 0, 0))\n</code></pre> <p>Position (in (x, y, z))</p>"},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position.Pos.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position.Pos.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position.Pos.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position.Pos.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/position/#mujoco_mojo.mjcf.position.Pos.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/","title":"mujoco_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr","title":"mujoco_attr","text":"<p>Defines child attributes of the Mujoco class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Asset","title":"Asset","text":"<p>               Bases: <code>XMLModel</code></p> <p>This is a grouping element for defining assets. It does not have attributes. Assets are created in the model so that they can be referenced from other model elements; recall the discussion of Assets in the Overview chapter. Assets opened from a file can be identified in two different ways: filename extensions or the content_type attribute. MuJoCo will attempt to open a file specified by the content type provided, and only defaults to the filename extension if no content_type attribute is specified. The content type is ignored if the asset isn't loaded from a file.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Asset.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Asset.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Asset.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Asset.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: HFieldName | None = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: int = 0\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: int = 0\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: VecN | None = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: LayerRole\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: MaterialName\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Vec2 = array((1, 1))\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: bool = False\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: float = 0\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: float = 0.5\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: float = 0.5\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: float = 0\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: float = -1\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: float = -1\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((1, 1, 1, 1))\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> <p>MuJoCo works with triangulated meshes. They can be loaded from binary STL files, OBJ files or MSH files with custom format described below, or vertex and face data specified directly in the XML. Software such as MeshLab can be used to convert from other mesh formats to STL or OBJ. While any collection of triangles can be loaded as a mesh and rendered, collision detection works with the convex hull of the mesh as explained in Collision detection. The mesh appearance (including texture mapping) is controlled by the material and rgba attributes of the referencing geom, similarly to height fields.</p> <p>Meshes can have explicit texture coordinates instead of relying on the automated texture mapping mechanism. When provided, these explicit coordinates have priority. Note that texture coordinates can be specified with OBJ files and MSH files, as well as explicitly in the XML with the texcoord attribute, but not via STL files. These mechanism cannot be mixed. So if you have an STL mesh, the only way to add texture coordinates to it is to convert to one of the other supported formats.</p> <p>Poorly designed meshes can display rendering artifacts. In particular, the shadow mapping mechanism relies on having some distance between front and back-facing triangle faces. If the faces are repeated, with opposite normals as determined by the vertex order in each triangle, this causes shadow aliasing. The solution is to remove the repeated faces (which can be done in MeshLab) or use a better designed mesh. Flipped faces are checked by MuJoCo for meshes specified as OBJ or XML and an error message is returned.</p> <p>The size of the mesh is determined by the 3D coordinates of the vertex data in the mesh file, multiplied by the components of the scale attribute below. Scaling is applied separately for each coordinate axis. Note that negative scaling values can be used to flip the mesh; this is a legitimate operation. The size parameters of the referencing geoms are ignored, similarly to height fields. We also provide a mechanism to translate and rotate the 3D coordinates, using the attributes refpos and refquat.</p> <p>A mesh can also be defined without faces (a point cloud essentially). In that case the convex hull is constructed automatically.This makes it easy to construct simple shapes directly in the XML. For example, a pyramid can be created as follows:</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh name=\"tetrahedron\" vertex=\"0 0 0  1 0 0  0 1 0  0 0 1\"/&gt;\n&lt;/asset&gt;\n</code></pre> <p>Positioning and orienting is complicated by the fact that vertex data in the source asset are often relative to coordinate frames whose origin is not inside the mesh. In contrast, MuJoCo expects the origin of a geom's local frame to coincide with the geometric center of the shape. We resolve this discrepancy by pre-processing the mesh in the compiler, so that it is centered around (0,0,0) and its principal axes of inertia are the coordinate axes. We save the translation and rotation offsets applied to the source asset in mjModel.mesh_pos and mjModel.mesh_quat; these are required if one reads vertex data from the source and needs to re-apply the transform. These offsets are then composed with the referencing geom's position and orientation; see also the mesh attribute of geom below. Fortunately most meshes used in robot models are designed in a coordinate frame centered at the joint. This makes the corresponding MJCF model intuitive: we set the body frame at the joint, so that the joint position is (0,0,0) in the body frame, and simply reference the mesh. Below is an MJCF model fragment of a forearm, containing all the information needed to put the mesh where one would expect it to be. The body position is specified relative to the parent body, namely the upper arm (not shown). It is offset by 35 cm which is the typical length of the human upper arm. If the mesh vertex data were not designed in the above convention, we would have to use the geom position and orientation (or the refpos, refquat mechanism) to compensate, but in practice this is rarely needed.</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh file=\"forearm.stl\"/&gt;\n&lt;/asset&gt;\n\n&lt;body pos=\"0 0 0.35\"/&gt;\n    &lt;joint type=\"hinge\" axis=\"1 0 0\"/&gt;\n    &lt;geom type=\"mesh\" mesh=\"forearm\"/&gt;\n&lt;/body&gt;\n</code></pre> <p>The inertial computation mentioned above is part of an algorithm used not only to center and align the mesh, but also to infer the mass and inertia of the body to which it is attached. This is done by computing the centroid of the triangle faces, connecting each face with the centroid to form a triangular pyramid, computing the mass and signed inertia of all pyramids (considered solid, or hollow if shellinertia is true) and accumulating them. The sign ensures that pyramids on the outside of the surfaces are subtracted, as can occur with concave geometries. This algorithm can be found in section 1.3.8 of Computational Geometry in C (Second Edition) by Joseph O'Rourke.</p> <p>The full list of processing steps applied by the compiler to each mesh is as follows:</p> <ol> <li>For STL meshes, remove any repeated vertices and re-index the faces if needed. If the mesh is not STL, we assume that the desired vertices and faces have already been generated and do not apply removal or re-indexing;</li> <li>If vertex normals are not provided, generate normals automatically, using a weighted average of the surrounding face normals. If sharp edges are encountered, the renderer uses the face normals to preserve the visual information about the edge, unless smoothnormal is true. Note that normals cannot be provided with STL meshes;</li> <li>Scale, translate and rotate the vertices and normals, re-normalize the normals in case of scaling. Save these transformations in mjModel.mesh_{pos, quat, scale}.</li> <li>Construct the convex hull if specified;</li> <li>Find the centroid of all triangle faces, and construct the union-of-pyramids representation. Triangles whose area is too small (below the mjMINVAL value of 1E-14) result in compile error;</li> <li>Compute the center of mass and inertia matrix of the union-of-pyramids. Use eigenvalue decomposition to find the principal axes of inertia. Center and align the mesh, saving the translational and rotational offsets for subsequent geom-related computations.</li> </ol>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: ModelName | None = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: TextureName | None = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: TextureType = CUBE\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: ColorSpace = AUTO\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Path | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: tuple[int, int] = (1, 1)\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: GridLayoutStr = '............'\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {<code>'.'</code>, <code>'R'</code>, <code>'L'</code>, <code>'U'</code>, <code>'D'</code>, <code>'F'</code>, <code>'B'</code>}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The <code>'.'</code> character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body","title":"Body","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: BodyName | None = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: str | None = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: bool = False\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: float = 0\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Sleep = AUTO\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.inertial","title":"inertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertial: Inertial | None = None\n</code></pre> <p>Inertial assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[Joint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.freejoints","title":"freejoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>freejoints: Sequence[FreeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Free joints assigned to body. Defining more than one free joint will not do anything</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.geoms","title":"geoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geoms: Sequence[Geom] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Geometries assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.sites","title":"sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sites: Sequence[Site] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Sites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.cameras","title":"cameras  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cameras: Sequence[Camera] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Cameras assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.lights","title":"lights  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>lights: Sequence[Light] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Lights assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.composites","title":"composites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>composites: Sequence[Composite] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.flexcomps","title":"flexcomps  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flexcomps: Sequence[FlexComp] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Flexible composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.attaches","title":"attaches  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attaches: Sequence[Attach] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Attach elements assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.frames","title":"frames  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frames: Sequence[float] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Frames assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.bodies","title":"bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bodies: Sequence[Body] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Bodies assigned to body. Handled recursively.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody","title":"WorldBody","text":"<p>               Bases: <code>Body</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: BodyName | None = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: str | None = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: bool = False\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: float = 0\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Sleep = AUTO\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.inertial","title":"inertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertial: Inertial | None = None\n</code></pre> <p>Inertial assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[Joint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.freejoints","title":"freejoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>freejoints: Sequence[FreeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Free joints assigned to body. Defining more than one free joint will not do anything</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.geoms","title":"geoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geoms: Sequence[Geom] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Geometries assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.sites","title":"sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sites: Sequence[Site] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Sites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.cameras","title":"cameras  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cameras: Sequence[Camera] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Cameras assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.lights","title":"lights  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>lights: Sequence[Light] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Lights assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.composites","title":"composites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>composites: Sequence[Composite] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.flexcomps","title":"flexcomps  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flexcomps: Sequence[FlexComp] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Flexible composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.attaches","title":"attaches  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attaches: Sequence[Attach] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Attach elements assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.frames","title":"frames  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frames: Sequence[float] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Frames assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.bodies","title":"bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bodies: Sequence[Body] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Bodies assigned to body. Handled recursively.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach","title":"Attach","text":"<p>               Bases: <code>XMLModel</code></p> <p>The attach element is used to insert a sub-tree of bodies from another model into this model's kinematic tree. Unlike include, which is implemented in the parser and is equivalent to copying and pasting XML from one file into another, attach is implemented in the model compiler. In order to use this element, the sub-model must first be defined as an asset. When creating an attachment, the top body of the attached subtree is specified, and all referencing elements outside the kinematic tree (e.g., sensors and actuators), are also copied into the top-level model. Additionally, any elements referenced from within the attached subtree (e.g. defaults and assets) will be copied in to the top-level model. attach is a Meta elements, so upon saving all attachments will appear in the saved XML file. Note that this element is a subset of the functionality of the procedural attachment functionality. As such, it shares the same limitations as described there. In addition, when the attach element is used, it is not possible to attach an entire model (i.e. including all elements, referenced or not).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach.model","title":"model  <code>instance-attribute</code>","text":"Python<pre><code>model: ModelName\n</code></pre> <p>The sub-model from which to attach a subtree.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach.body","title":"body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>body: BodyName | None = None\n</code></pre> <p>Name of the body in the sub-model to attach here. The body and its subtree will be attached. If this attribute is not specified, the contents of the world body will be attached in a new frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach.prefix","title":"prefix  <code>instance-attribute</code>","text":"Python<pre><code>prefix: str\n</code></pre> <p>Prefix to prepend to names of elements in the sub-model. This attribute is required to prevent name collisions with the parent or when attaching the same sub-tree multiple times.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Attach.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera","title":"Camera","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a camera, which moves with the body where it is defined. To create a fixed camera, define it in the world body. The cameras created here are in addition to the default free camera which is always defined and is adjusted via the visual element. Internally MuJoCo uses a flexible camera model, where the viewpoint and projection surface are adjusted independently so as to obtain oblique projections needed for virtual environments. This functionality however is not accessible through MJCF. Instead, the cameras created with this element (as well as the free camera) have a viewpoint that is always centered in front of the projection surface. The viewpoint coincides with the center of the camera frame. The camera is looking along the -Z axis of its frame. The +X axis points to the right, and the +Y axis points up. Thus the frame position and orientation are the key adjustments that need to be made here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: CameraName | None = None\n</code></pre> <p>Name of the camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This attribute specifies how the camera position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the camera sees).</p> <ul> <li><code>fixed</code> means that the position and orientation specified below are fixed relative to the body where the camera is defined.</li> <li><code>track</code> means that the camera position is at a constant offset from the body in world coordinates, while the camera orientation is constant in world coordinates. These constants are determined by applying forward kinematics in qpos0 and treating the camera as fixed. Tracking can be used for example to position a camera above a body, point it down so it sees the body, and have it always remain above the body no matter how the body translates and rotates.</li> <li><code>trackcom</code> is similar to \"track\" but the constant spatial offset is defined relative to the center of mass of the kinematic subtree starting at the body in which the camera is defined. This can be used to keep an entire mechanism in view. Note that the subtree center of mass for the world body is the center of mass of the entire model. So if a camera is defined in the world body in mode \"trackcom\", it will track the entire model.</li> <li><code>targetbody</code> means that the camera position is fixed in the body frame, while the camera orientation is adjusted so that it always points towards the targeted body (which is specified with the target attribute below). This can be used for example to model an eye that fixates a moving object; the object will be the target, and the camera/eye will be defined in the body corresponding to the head.</li> <li><code>targetbodycom</code> is the same as \"targetbody\" but the camera is oriented towards the center of mass of the subtree starting at the target body.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>When the camera mode is \"targetbody\" or \"targetbodycom\", this attribute becomes required. It specifies which body should be targeted by the camera. In all other modes this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.orthographic","title":"orthographic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orthographic: bool = False\n</code></pre> <p>Whether the camera uses a perspective projection (the default) or an orthographic projection. Setting this attribute changes the semantic of the fovy attribute, see below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.fovy","title":"fovy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fovy: float = 45\n</code></pre> <p>Vertical field-of-view of the camera. If the camera uses a perspective projection, the field-of-view is expressed in degrees, regardless of the global compiler/angle setting. If the camera uses an orthographic projection, the field-of-view is expressed in units of length; note that in this case the default of 45 is too large for most scenes and should likely be reduced. In either case, the horizontal field of view is computed automatically given the window size and the vertical field of view.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>resolution: tuple[int, int] = (1, 1)\n</code></pre> <p>Resolution of the camera in pixels [width height]. Note that these values are not used for rendering since those dimensions are determined by the size of the rendering context. This attribute serves as a convenient location to save the required resolution when creating a context.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.focal","title":"focal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focal: Vec2 = array((0, 0))\n</code></pre> <p>Focal length of the camera in length units. It is mutually exclusive with fovy. See Cameras for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.focalpixel","title":"focalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focalpixel: tuple[int, int] = (1, 1)\n</code></pre> <p>Focal length of the camera in pixel units. If both focal and focalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.principal","title":"principal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principal: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in length units. It is mutually exclusive with fovy.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.principalpixel","title":"principalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principalpixel: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in pixel units. If both principal and principalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.sensorsize","title":"sensorsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensorsize: Vec2 = array((0, 0))\n</code></pre> <p>Size of the camera sensor in length units. It is mutually exclusive with fovy. If specified, resolution and focal are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.ipd","title":"ipd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ipd: float = 0.068\n</code></pre> <p>Inter-pupilary distance. This attribute only has an effect during stereoscopic rendering. It specifies the distance between the left and right viewpoints. Each viewpoint is shifted by +/- half of the distance specified here, along the X axis of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the camera frame. See Frame orientations. Note that specifically for cameras, the xyaxes attribute is semantically convenient as the X and Y axes correspond to the directions \"right\" and \"up\" in pixel space, respectively.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Camera.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite","title":"Composite","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>prefix: str | None = None\n</code></pre> <p>All automatically generated model elements have names indicating the element type and index. For example, the body at coordinates (2, 0) in a 2D grid is named \"B2_0\" by default. If prefix=\"C\" is specified, the same body is named \"CB2_0\". The prefix is needed when multiple composite objects are used in the same model, to avoid name conflicts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: CompositeType = CABLE\n</code></pre> <p>This attribute determines the type of composite object. The only supported type is cable.</p> <p>The <code>cable</code> type creates a 1D chain of bodies connected with ball joints, each having a geom with user-defined type (cylinder, capsule or box). The geometry can either be defined with an array of 3D vertex coordinates vertex or with prescribed functions with the option curve. Currently, only linear and trigonometric functions are supported. For example, an helix can be obtained with curve=\"cos(s) sin(s) s\". The size is set with the option size, resulting in f(s)={size[1]\u22c5cos(2\u03c0\u22c5size[2]), size[1]\u22c5sin(2\u03c0\u22c5size[2]),  size[0]\u22c5s}.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.count","title":"count  <code>instance-attribute</code>","text":"Python<pre><code>count: Tuple[int] | Tuple[int, int] | Tuple[int, int, int]\n</code></pre> <p>The element count in each dimension of the grid. This can have 1, 2 or 3 numbers, specifying the element count along the X, Y and Z axis of the parent body frame within. Any missing numbers default to 1. If any of these numbers is 1, all subsequent numbers must also be 1, so that the leading dimensions of the grid are used. This means for example that a 1D grid will always extend along the X axis. To achieve a different orientation, rotate the frame of the parent body. Note that some types imply a grid of certain dimensionality, so the requirements for this attribute depend on the specified type.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>offset: Vec3 = array((0, 0, 0))\n</code></pre> <p>It specifies a 3D offset from the center of the parent body to the center of the first body of the cable. The offset is expressed in the local coordinate frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Quat = Quat(quat=array((1, 0, 0, 0)))\n</code></pre> <p>It specifies a quaternion that rotates the first body frame. The quaternion is expressed in the parent body frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: VecN | None = None\n</code></pre> <p>Vertex 3D positions in global coordinates.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.initial","title":"initial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>initial: CompositeInitial = NONE\n</code></pre> <p>Behavior of the first point. Free: free joint. Ball: ball joint. None: no dof.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.curve","title":"curve  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>curve: tuple[str, str, str] | None = None\n</code></pre> <p>Functions specifying the vertex positions. Available functions are s, cos(s), and sin(s), where s is the arc length parameter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: tuple[int, int, int] | None = None\n</code></pre> <p>Scaling of the curve functions. size[0] is the scaling of s, size[1] is the radius of cos(s) and sin(s), and size[2] is the speed of the argument (i.e. cos(2pisize[2]*s)).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[CompositeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.geom","title":"geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geom: CompositeGeom | None = None\n</code></pre> <p>Geometry assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.site","title":"site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>site: CompositeSite | None = None\n</code></pre> <p>Site assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.skin","title":"skin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>skin: Skin | None = None\n</code></pre> <p>Skin assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Composite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint","title":"CompositeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>Depending on the composite type, some joints are created automatically (e.g. the universal joints in rope) while other joints are optional (e.g. the stretch and twist joints in rope). This sub-element is used to specify which optional joints should be created, as well as to adjust the attributes of both automatic and optional joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.kind","title":"kind  <code>instance-attribute</code>","text":"Python<pre><code>kind: CompositeJointKind\n</code></pre> <p>The joint kind here is orthogonal to the joint type in the rest of MJCF. The joint kind refers to the function of the joint within the mechanism comprising the composite body, while the joint type (hinge or slide) is implied by the joint kind and composite body type.</p> <p>The main kind corresponds to the main joints forming each composite type. These joints are automatically included in the model even if the joint sub-element is missing. The main joints are 3D sliders for particle and grid; 1D sliders for box, cylinder and rope; universal joints for cloth, rope and loop. Even though the main joints are included automatically, this sub-element is still useful for adjusting their attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.solreffix","title":"solreffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffix: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.solimpfix","title":"solimpfix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfix: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Joint stiffness. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.</p> <p>Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite","title":"CompositeSite","text":"<p>               Bases: <code>SiteBase</code></p> <p>This sub-element adjusts the attributes of the sites in the composite object. Otherwise it is the same as geom above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>Sizes of the geometric shape representing the site. What shape it is I do not know.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.CompositeSite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp","title":"FlexComp","text":"<p>               Bases: <code>XMLModel</code></p> <p>Similar to composite, this element (new in MuJoCo 3.0) is not a model element, but rather a macro which expands into multiple model elements representing a deformable entity. In particular this macro creates one flex element, a number of bodies that are children of the body in which the flexcomp is defined, and optionally one flex equality which constrains all flex edges to their initial length. A number of attributes are specified here and then passed through to the automatically-constructed flex. The primary role of flexcomp is to automate the creation of a (possibly large) collection of moving bodies with corresponding joints, and connect them with stretchable flex elements. See flex and deformable objects documentation for specifics on how flexes work. Here we only describe the automated construction process.</p> <p>An important distinction between flex and flexcomp is that the flex references bodies and specifies vertex coordinates in the frames of those bodies, while the flexcomp defines points. Each flexcomp point corresponds to one body and one vertex in the underlying flex. If the flexcomp point is pinned, the corresponding flex body is the parent body of the flexcomp, while the corresponding flex vertex coordinates equal the flexcomp point coordinates. If the flexcomp point is not pinned, a new child body is created at the coordinates of the flexcomp point (within the flexcomp parent body), and then the coordinates of the flex vertex within that new body are (0,0,0). The mechanism for pinning flexcomp points is explained below.</p> <p>Composite objects (available prior to MuJoCo 3.0) needed bodies with geoms for collisions, and sites for connecting tendons which generated shape-preserving forces. In contrast, flexes generate their own collisions and shape-preserving forces (as well as rendering), thus the bodies created here are much simpler: no geoms, sites or tendons are needed. Most of the bodies created here have 3 orthogonal slider joints, corresponding to freely moving point masses. In some cases we generate radial slider joints, allowing only expansion and contraction. Since no geoms are generated, the bodies need to have explicit inertial parameters.</p> <p>Below is a simple example of a flexcomp, modeling a (somewhat flexible) double pendulum with one end pinned to the world:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;flexcomp name=\"FL\" type=\"grid\" dim=\"1\" count=\"3 1 1\" mass=\"3\" spacing=\"0.2 0.2 0.2\"&gt;\n            &lt;pin id=\"0\"/&gt;\n        &lt;/flexcomp&gt;\n    &lt;/worldbody&gt;\n&lt;/mujoco&gt;\n</code></pre> <p>This flexcomp has 3 points, however the first point is pinned to the world (i.e. the parent of the flexcomp) and so only two bodies are automatically created, namely FL_1 and FL_2. Here is what this flexcomp generates after loading and saving the XML:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"FL_1\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n        &lt;body name=\"FL_2\" pos=\"0.2 0 0\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n    &lt;deformable&gt;\n        &lt;flex name=\"FL\" dim=\"1\" body=\"world FL_1 FL_2\" vertex=\"-0.2 0 0 0 0 0 0 0 0\" element=\"0 1 1 2\"/&gt;\n    &lt;/deformable&gt;\n    &lt;equality&gt;\n        &lt;flex flex=\"FL\"/&gt;\n    &lt;/equality&gt;\n&lt;/mujoco&gt;\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>The name of the flex element being generated automatically. This name is used as a prefix for all bodies that are automatically generated here, and is also referenced by the corresponding flex equality constraint (if applicable).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dim: int | None = None\n</code></pre> <p>Dimensionality of the flex object. This value must be 1, 2 or 3. The flex elements are capsules in 1D, triangles with radius in 2D, and tetrahedra with radius in 3D. Certain flexcomp types imply a dimensionality, in which case the value specified here is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.dof","title":"dof  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dof: FlexCompDOF | None = None\n</code></pre> <p>The parametrization of the flex's degrees of freedom (dofs). See the video on the right illustrating the different parametrizations with deformable spheres. The three models in the video are respectively sphere_full, sphere_radial and sphere_trilinear.</p> <ul> <li><code>full</code>: Three translational dofs per vertex. This is the most expressive but also the most expensive option.</li> <li><code>radial</code>: A single radial translational dof per vertex. Note that unlike in the \"full\" case, the radial parametrization requires a free joint at the flex's parent in order for free body motion to be possible. This type of parametrization is appropriate for shapes that are relatively spherical.</li> <li><code>trilinear</code>: Three translational dofs at each corner of the bounding box of the flex, for a total of 24 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using trilinear interpolation over the bounding box.</li> </ul> <p>Trilinear and quadratic flexes are much faster than the previous two options, and are the preferred choice if the expected deformations can be captured by the reduced parametriation. For example, see the video on the right comparing full and trilinear flexes for modeling deformable gripper pads.</p> <p>Note that the choice of dof parametrization affects the deformation modes of the flex but has no effect on the accuracy of the collision geometry, which always takes into account the high-resolution mesh of the flex.</p> <ul> <li><code>quadratic</code>: Three translational dofs per corner, edge, face, and volume of the bounding box of the flex, for a total of 81 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using quadratic interpolation over the bounding box. While this option requires more degrees of freedom than trilinear flexes, it enables curved deformation modes, while the only modes achievable for trilinear flexes are strech/compression and shear.</li> </ul> <p>Note that a higher interpolation order generally requires a smaller time step for stability, although usually not as large as with the \"full\" option and a fine mesh.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: FlexCompType | None = None\n</code></pre> <p>This attribute determines the type of flexcomp object. The remaining attributes and sub-elements are then interpreted according to the type. Default settings are also adjusted depending on the type. Different types correspond to different methods for specifying the flexcomp points and the stretchable elements that connect them. They fall in three categories: direct specification entered in the XML, direct specification loaded from file, and automated generation from higher-level specification.</p> <p><code>grid</code> generates a rectangular grid of points in 1D, 2D or 3D as specified by dim. The number of points in each dimension is determined by count while the grid spacing in each dimension is determined by spacing. Make sure the spacing is sufficiently large relative to radius to avoid permanent contacts. In 2D and 3D the grid is automatically triangulated, and corresponding flex elements are created (triangles or tetrahedra). In 1D the elements are capsules connecting consecutive pairs of points.</p> <p><code>box</code> generates a 3D box object, however flex bodies are only generated on the outer shell. Each flex body has a radial slider joint allowing it to move in and out from the center of the box. The parent body would normally be a floating body. The box surface is triangulated, and each flex element is a tetrahedron connecting the center of the box with one triangle face. count and spacing determine the count and spacing of the flex bodies, similar to the grid type in 3D. Note that the resulting flex has the same topology as the box generated by composite.</p> <p><code>cylinder</code> is the same as box, except the points are projected on the surface of a cylinder.</p> <p><code>ellipsoid</code> is the same as box, except the points are projected on the surface of an ellipsoid.</p> <p><code>disc</code> is the same as box, except the points are projected on the surface of a disc. It is only compatible with dim=2.</p> <p><code>circle</code> is the same as grid, except the points are sampled along a circle so that the first and last points are the same. The radius of the circle is computed such that each segment has the requested spacing. It is only compatible with dim=1.</p> <p><code>mesh</code> loads the flexcomp points and elements (i.e. triangles) from a mesh file, in the same file formats as mesh assets, excluding the legacy .msh format. A mesh asset is not actually added to the model. Instead the vertex and face data from the mesh file are used to populate the point and element data of the flexcomp. dim is automatically set to 2. Recall that a mesh asset in MuJoCo can be used as a rigid geom attached to a single body. In contrast, the flex generated here corresponds to a soft mesh with the same initial shape, where each vertex is a separate moving body (unless pinned).</p> <p><code>gmsh</code> is similar to mesh, but it loads a GMSH file in format 4.1 and format 2.2 (ascii or binary). The file extension can be anything; the parser recognizes the format by examining the file header. This is a very rich file format, allowing all kinds of elements with different dimensionality and topology. MuJoCo only supports GMSH element types 1, 2, 4 which happen to correspond to our 1D, 2D and 3D flexes and assumes that the nodes are specified in a single block. Only the Nodes and Elements sections of the GMHS file are processed, and used to populate the point and element data of the flexcomp. The parser will generate an error if the GMSH file contains meshes that are not supported by MuJoCo. dim is automatically set to the dimensionality specified in the GMSH file. Presently this is the only mechanism to load a large tetrahedral mesh in MuJoCo and generate a corresponding soft entity. If such a mesh is available in a different file format, use the freely available GMSH software to convert it to GMSH in one of the supported versions.</p> <p><code>direct</code> allows the user to specify the point and element data of the flexcomp directly in the XML. Note that flexcomp will still generate moving bodies automatically, as well as automate other settings; so it still provides convenience compared to specifing the corresponding flex directly.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>count: tuple[int, int, int] | None = None\n</code></pre> <p>The number of automatically generated points in each dimension. This and the next attribute only apply to types grid, box, cylinder, ellipsoid.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.spacing","title":"spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spacing: Vec3 | None = None\n</code></pre> <p>The spacing between the automatically generated points in each dimension. The spacing should be sufficiently large compared to the radius, to avoid permanent contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.point","title":"point  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>point: VecN | None = None\n</code></pre> <p>The 3D coordinates of the points. This attribute is only used with type direct. All other flexcomp types generate their own points. The points are used to construct bodies and vertices as explained earlier.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.element","title":"element  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>element: tuple[int, ...] | None = None\n</code></pre> <p>The zero-based point ids forming each flex elements. This attribute is only used with type direct. All other flexcomp types generate their own elements. This data is passed through to the automatically-generated flex.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: VecN | None = None\n</code></pre> <p>Texture coordinates of each point, passed through to the automatically-generated flex. Note that flexcomp does not generate texture coordinates automatically, except for 2D grids, box, cylinder and ellipsoid. For all other types, the user can specify explicit texture coordinates here, even if the points themselves were generated automatically. This requires understanding of the layout of the automatically-generated points and how they correspond to the texture referenced by the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>The mass of each automatically-generated body equals this value divided by the number of points. Note that pinning some points does not affect the mass of the other bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.inertiabox","title":"inertiabox  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiabox: float | None = None\n</code></pre> <p>Even though the automatically-generated bodies have the physics of point masses, with slider joints, MuJoCo still requires each body to have rotational inertia. The inertias generated here are diagonal, and are computed such that the corresponding equivalent-inertia boxes have sides equal to this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The name of the file from which a surface (triangular) or volumetric (tetrahedral) mesh is loaded. For surface meshes, the file extension is used to determine the file format. Supported formats are GMSH and the formats specified in mesh assets, excluding the legacy .msh format. Volumetric meshes are supported only in GMSH format. See here for more information on GMSH files.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.rigid","title":"rigid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rigid: bool | None = None\n</code></pre> <p>If this is true, all points correspond to vertices within the parent body, and no new bodies are created. This is equivalent to pinning all points. Note that if all points are indeed pinned, the model compiler will detect that the flex is rigid (which behaves is a non-convex mesh in collision detection).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3 | None = None\n</code></pre> <p>This 3D vector translates all points relative to the frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>If using a quaternion, rotation of all points around the pos vector specified above. Together these two vectors define a pose transformation, used to position and orient the points as needed.</p> <p>Other orientations are options in place of quat.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 | None = None\n</code></pre> <p>Scaling of all point coordinates, for types that specify coordinates explicitly. Scaling is applied after the pose transformation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.radius","title":"radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>radius: float | None = None\n</code></pre> <p>Radius of all flex elements. It can be zero in 3D, but must be positive in 1D and 2D. The radius affects both collision detection and rendering. In 1D and 2D it is needed to make the elements volumetric.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the flex. Note that textures specified in the material will be applied only if the flex has explicit texture coordinates.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 | None = None\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int | None = None\n</code></pre> <p>Integer group to which the flex belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of flexes.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.flatskin","title":"flatskin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flatskin: bool | None = None\n</code></pre> <p>This attribute determines whether 2D and 3D flexes that are rendered in flexskin mode will use smooth or flat shading. The default smooth shading is suitable in most cases, however if the object is intended to have visible sharp edges (such as a cube) then flat shading is more natural.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.origin","title":"origin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>origin: Vec3 | None = None\n</code></pre> <p>The origin of the flexcomp. Used for generating a volumetric mesh from an OBJ surface mesh. Each surface triangle is connected to the origin to create a tetrahedron, so the resulting volumetric mesh is guaranteed to be well-formed only for convex shapes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FlexComp.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Align = AUTO\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox","title":"GeomBox","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a box geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule","title":"GeomCapsule","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a capsule geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder","title":"GeomCylinder","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a cylinder geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid","title":"GeomEllipsoid","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a ellipsoid geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField","title":"GeomHField","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a height field geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[HFIELD] = HFIELD\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>hfield</code> type defines a height field geom. The geom must reference the desired height field asset with the hfield attribute below. The position and orientation of the geom set the position and orientation of the height field. The size of the geom is ignored, and the size parameters of the height field asset are used instead. See the description of the hfield element. Similar to planes, height field geoms can only be attached to the world body or to static children of the world.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.hfield","title":"hfield  <code>instance-attribute</code>","text":"Python<pre><code>hfield: HFieldName\n</code></pre> <p>This attribute must be specified if and only if the geom type is \"hfield\". It references the height field asset to be instantiated at the position and orientation of the geom frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomHField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh","title":"GeomMesh","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a mesh geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[MESH] = MESH\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>mesh</code> type defines a mesh. The geom must reference the desired mesh asset with the mesh attribute. Note that mesh assets can also be referenced from other geom types, causing primitive shapes to be fitted; see below. The size is determined by the mesh asset and the geom size parameters are ignored. Unlike all other geoms, the position and orientation of mesh geoms after compilation do not equal the settings of the corresponding attributes here. Instead they are offset by the translation and rotation that were needed to center and align the mesh asset in its own coordinate frame. Recall the discussion of centering and alignment in the mesh element.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.mesh","title":"mesh  <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomMesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane","title":"GeomPlane","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a plane geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[PLANE] = PLANE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>plane</code> type defines a plane which is infinite for collision detection purposes. It can only be attached to the world body or static children of the world. The plane passes through a point specified via the pos attribute. It is normal to the Z axis of the geom's local frame. The +Z direction corresponds to empty space. Thus the position and orientation defaults of (0,0,0) and (1,0,0,0) would create a ground plane at Z=0 elevation, with +Z being the vertical direction in the world (which is MuJoCo's convention). Since the plane is infinite, it could have been defined using any other point in the plane. The specified position however has additional meaning with regard to rendering. If either of the first two size parameters are positive, the plane is rendered as a rectangle of finite size (in the positive dimensions). This rectangle is centered at the specified position. Three size parameters are required. The first two specify the half- size of the rectangle along the X and Y axes. The third size parameter is unusual: it specifies the spacing between the grid subdivisions of the plane for rendering purposes. The subdivisions are revealed in wireframe rendering mode, but in general they should not be used to paint a grid over the ground plane (textures should be used for that purpose). Instead their role is to improve lighting and shadows, similar to the subdivisions used to render boxes. When planes are viewed from the back, the are automatically made semi-transparent. Planes and the +Z faces of boxes are the only surfaces that can show reflections, if the material applied to the geom has positive reflection. To render an infinite plane, set the first two size parameters to zero.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; spacing between square grid lines for rendering. If either the X or Y half-size is 0, the plane is rendered as infinite in the dimension(s) with 0 size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomPlane.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF","title":"GeomSDF","text":"<p>               Bases: <code>GeomBase</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SDF] = SDF\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>sdf</code> type defines a signed distance field (SDF, also referred to as signed distance function). In order to visualize the SDF, a custom mesh must be specified using the mesh/plugin attribute. See the model/plugin/sdf/ directory for example models with SDF geometries. For more details regarding SDF plugins, see the Extensions chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSDF.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere","title":"GeomSphere","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a sphere geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.GeomSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Vec3 | None = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Vec6 | None = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = HINGE\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = array((0, 0, 1))\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Vec2 = array((0, 0))\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = 0\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = array((0, 0))\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = AUTO\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Vec2 = array((0, 0))\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: ActuatorFrcLimited = AUTO\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: bool = False\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: float = 0\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: float = 0\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = 0\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = 0\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = 0\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light","title":"Light","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a light, which moves with the body where it is defined. To create a fixed light, define it in the world body. The lights created here are in addition to the headlight which is always defined and is configured via the visual element. Lights shine along the direction specified by the dir attribute. They do not have a full spatial frame with three orthogonal axes.</p> <p>By default, MuJoCo uses the standard OpenGL (fixed functional) Phong lighting model for its rendering, with augmented with shadow mapping. (See the OpenGL documentation for more information, including details about various attributes.)</p> <p>MJCF also supports alternative lighting models (e.g. physically-based rendering) by providing additional attributes. Attributes may be applied or ignored depending on the lighting model being used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: LightName | None = None\n</code></pre> <p>Name of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This is identical to the mode attribute of camera. It specifies the how the light position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the light illuminates).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>This is identical to the target attribute of camera above. It specifies which body should be targeted in \"targetbody\" and \"targetbodycom\" modes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: LightType = SPOT\n</code></pre> <p>Determines the type of light. Note that some light types may not be supported by some renderers (e.g. only spot and directional lights are supported by the default native renderer).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.directional","title":"directional  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>directional: bool = False\n</code></pre> <p>This is a deprecated legacy attribute. Please use light type instead. If set to \"true\", and no type is specified, this will change the light type to be directional.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.castshadow","title":"castshadow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>castshadow: bool = True\n</code></pre> <p>If this attribute is \"true\" the light will cast shadows. More precisely, the geoms illuminated by the light will cast shadows, however this is a property of lights rather than geoms. Since each shadow-casting light causes one extra rendering pass through all geoms, this attribute should be used with caution. Higher quality of the shadows is achieved by increasing the value of the shadowsize attribute of quality, as well as positioning spotlights closer to the surface on which shadows appear, and limiting the volume in which shadows are cast. For spotlights this volume is a cone, whose angle is the cutoff attribute below multiplied by the shadowscale attribute of map. For directional lights this volume is a box, whose half-sizes in the directions orthogonal to the light are the model extent multiplied by the shadowclip attribute of map. The model extent is computed by the compiler but can also be overridden by specifying the extent attribute of statistic. Internally the shadow-mapping mechanism renders the scene from the light viewpoint (as if it were a camera) into a depth texture, and then renders again from the camera viewpoint, using the depth texture to create shadows. The internal rendering pass uses the same near and far clipping planes as regular rendering, i.e., these clipping planes bound the cone or box shadow volume in the light direction. As a result, some shadows (especially those very close to the light) may be clipped.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.active","title":"active  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>active: bool = True\n</code></pre> <p>The light is active if this attribute is \"true\". This can be used at runtime to turn lights on and off.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the light. This attribute only affects the rendering for spotlights, but it should also be defined for directional lights because we render the cameras as decorative elements.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dir: Vec3 = array((0, 0, -1))\n</code></pre> <p>Direction of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.diffuse","title":"diffuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diffuse: Vec3 = array((0.7, 0.7, 0.7))\n</code></pre> <p>The color of the light. For the Phong (default) lighting model, this defines the diffuse color of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>The texture to use for image-based lighting. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.intensity","title":"intensity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>intensity: float = 0\n</code></pre> <p>The intensity of the light source, measured in candela, used for physically-based lighting models. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.ambient","title":"ambient  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ambient: Vec3 = array((0, 0, 0))\n</code></pre> <p>The ambient color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Vec3 = array((0.3, 0.3, 0.3))\n</code></pre> <p>The specular color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: float = 10\n</code></pre> <p>The effective range of the light. Objects further than this distance from the light position will not be illuminated by this light. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.bulbradius","title":"bulbradius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bulbradius: float = 0.02\n</code></pre> <p>The radius of the light source which can affect shadow softness depending on the renderer. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.attenuation","title":"attenuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attenuation: Vec3 = array((1, 0, 0))\n</code></pre> <p>These are the constant, linear and quadratic attenuation coefficients for Phong lighting. The default corresponds to no attenuation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.cutoff","title":"cutoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cutoff: float = 45\n</code></pre> <p>Cutoff angle for spotlights, always in degrees regardless of the global angle setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.exponent","title":"exponent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>exponent: float = 10\n</code></pre> <p>Exponent for spotlights. This setting controls the softness of the spotlight cutoff.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Light.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox","title":"SiteBox","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a box site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule","title":"SiteCapsule","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a capsule site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder","title":"SiteCylinder","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a cylinder site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid","title":"SiteEllipsoid","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a ellipsoid site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere","title":"SiteSphere","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a sphere site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.SiteSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin","title":"Skin","text":"<p>               Bases: <code>XMLModel</code></p> <p>If this element is included, the model compiler will generate a skinned mesh asset and attach it to the element bodies of the composite object. Skin can be attached to 2D grid, cloth, box, cylinder and ellipsoid. For other composite types it has no effect. Note that the skin created here is equivalent to a skin specified directly in the XML, as opposed to a skin loaded from file. So if the model is saved as XML, it will contain a large section describing the automatically-generated skin.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: bool = False\n</code></pre> <p>If this is true, explicit texture coordinates will be generated, mapping the skin to the unit square in texture space. This is needed when the material specifies a texture. If texcoord is false and the skin has texture, the texture will appear fixed to the world instead of the skin. The reason for having this attribute in the first place is because skins with texture coordinates upload these coordinates to the GPU even if no texture is applied later. So this attribute should be set to false in cases where no texture will be applied via the material attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.inflate","title":"inflate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inflate: float = 0\n</code></pre> <p>The default value of 0 means that the automatically-generated skin passes through the centers of the body elements comprising the composite object. Positive values offset each skin vertex by the specified amount, in the direction normal to the (non-inflated) skin at that vertex. This has two uses. First, in 2D objects, a small positive inflate factor is needed to avoid aliasing artifacts. Second, collisions are done with geoms that create some thickness, even for 2D objects. Inflating the skin with a value equal to the geom size will render the skin as a \"mattress\" that better represents the actual collision geometry. The value of this attribute is copied into the corresponding attribute of the skin asset being created.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.subgrid","title":"subgrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>subgrid: int = 0\n</code></pre> <p>This is only applicable to cloth and 2D grid types, and has no effect for any other composite type. The default value of 0 means that the skin has as many vertices as the number of element bodies. A positive value causes subdivision, with the specified number of (additional) grid lines. In this case the model compiler generates a denser skin using bi-cubic interpolation. This increases the quality of the rendering (especially in the absence of textures) but also slows down the renderer, so use it with caution. Values above 3 are unlikely to be needed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Skin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler","title":"Compiler","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.autolimits","title":"autolimits  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autolimits: bool = True\n</code></pre> <p>This attribute affects the behavior of attributes such as \"limited\" (on  or ), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on ). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.boundmass","title":"boundmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundmass: float = 0\n</code></pre> <p>This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.boundinertia","title":"boundinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundinertia: float = 0\n</code></pre> <p>This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.settotalmass","title":"settotalmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>settotalmass: float = -1\n</code></pre> <p>If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.balanceinertia","title":"balanceinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>balanceinertia: bool = False\n</code></pre> <p>A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.strippath","title":"strippath  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>strippath: bool = False\n</code></pre> <p>When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.coordinate","title":"coordinate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>coordinate: Coordinate = LOCAL\n</code></pre> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>angle: Angle = DEGREE\n</code></pre> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.fitaabb","title":"fitaabb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitaabb: bool = False\n</code></pre> <p>The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.eulerseq","title":"eulerseq  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerseq: EulerSeq | str = xyz\n</code></pre> <p>This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.meshdir","title":"meshdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meshdir: Path | None = None\n</code></pre> <p>This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.texturedir","title":"texturedir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texturedir: Path | None = None\n</code></pre> <p>This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.assetdir","title":"assetdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>assetdir: Path | None = None\n</code></pre> <p>This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.discardvisual","title":"discardvisual  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>discardvisual: bool = False\n</code></pre> <p>This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.</p> <ul> <li>All materials are discarded.</li> <li>All textures are discarded.</li> <li>All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.</li> <li>All meshes which are not referenced by any geom (in particular those discarded above) are discarded.</li> </ul> <p>The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.usethread","title":"usethread  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>usethread: bool = True\n</code></pre> <p>If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.fusestatic","title":"fusestatic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fusestatic: bool = False\n</code></pre> <p>This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless</p> <ul> <li>They are referenced by another element in the model.</li> <li>They contain a site which is referenced by a force or torque sensor.</li> </ul> <p>This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.inertiafromgeom","title":"inertiafromgeom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiafromgeom: InertiaFromGeom = AUTO\n</code></pre> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.alignfree","title":"alignfree  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>alignfree: bool = False\n</code></pre> <p>This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.inertiagrouprange","title":"inertiagrouprange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiagrouprange: InertiaGroupRange = (0, 5)\n</code></pre> <p>This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.saveinertial","title":"saveinertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>saveinertial: bool = False\n</code></pre> <p>If set to \"true\", the compiler will save explicit inertial clauses for all bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: LengthRangeMode = MUSCLE\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: bool = True\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: bool = False\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: float = 20\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: float = 0\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: float = 1\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: float = 0.01\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: float = 10\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: float = 2\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: float = 0.05\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option","title":"Option","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: float = 0.002\n</code></pre> <p>Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.impratio","title":"impratio  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>impratio: float = 1\n</code></pre> <p>This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Vec3 = array((0, 0, -9.81))\n</code></pre> <p>Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>wind: Vec3 = array((0, 0, 0))\n</code></pre> <p>Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.magnetic","title":"magnetic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>magnetic: Vec3 = array((0, -0.5, 0))\n</code></pre> <p>Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 0\n</code></pre> <p>Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.viscosity","title":"viscosity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>viscosity: float = 0\n</code></pre> <p>Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_margin","title":"o_margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_margin: float = 0\n</code></pre> <p>This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_solref","title":"o_solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These attributes replace the solref parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_solimp","title":"o_solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These attributes replace the solimp parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_friction","title":"o_friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_friction: Vec3 = FRICTION_DEFAULT\n</code></pre> <p>These attributes replace the friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.integrator","title":"integrator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>integrator: Integrator = EULER\n</code></pre> <p>This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.cone","title":"cone  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cone: Cone = PYRAMIDAL\n</code></pre> <p>The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.jacobian","title":"jacobian  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>jacobian: Jacobian = AUTO\n</code></pre> <p>The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.solver","title":"solver  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solver: Solver = NEWTON\n</code></pre> <p>This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.iterations","title":"iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>iterations: int = 100\n</code></pre> <p>Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolerance: float = 1e-08\n</code></pre> <p>Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ls_iterations","title":"ls_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_iterations: int = 50\n</code></pre> <p>Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ls_tolerance","title":"ls_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_tolerance: float = 0.01\n</code></pre> <p>Tolerance threshold used for early termination of the linesearch algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.noslip_iterations","title":"noslip_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_iterations: int = 0\n</code></pre> <p>Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.noslip_tolerance","title":"noslip_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_tolerance: float = 1e-06\n</code></pre> <p>Tolerance threshold used for early termination of the Noslip solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ccd_iterations","title":"ccd_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_iterations: int = 50\n</code></pre> <p>Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ccd_tolerance","title":"ccd_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_tolerance: float = 1e-06\n</code></pre> <p>Tolerance threshold used for early termination of the convex collision algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.sleep_tolerance","title":"sleep_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep_tolerance: float = 0.0001\n</code></pre> <p>Velocity tolerance below which sleeping is allowed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.sdf_iterations","title":"sdf_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_iterations: int = 10\n</code></pre> <p>Number of iterations used for Signed Distance Field collisions (per initial point).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.sdf_initpoints","title":"sdf_initpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_initpoints: int = 40\n</code></pre> <p>Number of starting points used for finding contacts with Signed Distance Field collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.actuatorgroupdisable","title":"actuatorgroupdisable  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgroupdisable: set[ActuatorGroup] | None = None\n</code></pre> <p>List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: EnableDisable = ENABLE\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: EnableDisable = ENABLE\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: EnableDisable = ENABLE\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: EnableDisable = ENABLE\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: EnableDisable = ENABLE\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: EnableDisable = ENABLE\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: EnableDisable = ENABLE\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: EnableDisable = DISABLE\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: EnableDisable = DISABLE\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: EnableDisable = DISABLE\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p> <p>flag value at initialization time</p> <p>Unlike any other flag, the sleep flag has an effect during mjData initialization (mj_makeData or mj_resetData). First, it must be set at initialization time in order for the sleep-init policy to take effect. Second, it must be set in order for static quantities to be computed. See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size","title":"Size","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>memory: str = '-1'\n</code></pre> <p>This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuserdata","title":"nuserdata  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuserdata: int = 0\n</code></pre> <p>The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nkey","title":"nkey  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nkey: int = 0\n</code></pre> <p>The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_body","title":"nuser_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_body: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_jnt","title":"nuser_jnt  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_jnt: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_geom","title":"nuser_geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_geom: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_site","title":"nuser_site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_site: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_cam","title":"nuser_cam  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_cam: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_tendon","title":"nuser_tendon  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_tendon: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each tendon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_actuator","title":"nuser_actuator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_actuator: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each actuator.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_sensor","title":"nuser_sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_sensor: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each sensor.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic","title":"Statistic","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.meanmass","title":"meanmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meanmass: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.meaninertia","title":"meaninertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meaninertia: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.meansize","title":"meansize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meansize: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>extent: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.center","title":"center  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>center: Vec3 | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/","title":"asset","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset","title":"asset","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset","title":"Asset","text":"<p>               Bases: <code>XMLModel</code></p> <p>This is a grouping element for defining assets. It does not have attributes. Assets are created in the model so that they can be referenced from other model elements; recall the discussion of Assets in the Overview chapter. Assets opened from a file can be identified in two different ways: filename extensions or the content_type attribute. MuJoCo will attempt to open a file specified by the content type provided, and only defaults to the filename extension if no content_type attribute is specified. The content type is ignored if the asset isn't loaded from a file.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/","title":"body","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body","title":"body","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body","title":"Body","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: BodyName | None = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: str | None = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: bool = False\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: float = 0\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Sleep = AUTO\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.inertial","title":"inertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertial: Inertial | None = None\n</code></pre> <p>Inertial assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[Joint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.freejoints","title":"freejoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>freejoints: Sequence[FreeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Free joints assigned to body. Defining more than one free joint will not do anything</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.geoms","title":"geoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geoms: Sequence[Geom] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Geometries assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.sites","title":"sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sites: Sequence[Site] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Sites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.cameras","title":"cameras  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cameras: Sequence[Camera] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Cameras assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.lights","title":"lights  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>lights: Sequence[Light] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Lights assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.composites","title":"composites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>composites: Sequence[Composite] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.flexcomps","title":"flexcomps  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flexcomps: Sequence[FlexComp] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Flexible composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.attaches","title":"attaches  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attaches: Sequence[Attach] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Attach elements assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.frames","title":"frames  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frames: Sequence[float] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Frames assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.bodies","title":"bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bodies: Sequence[Body] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Bodies assigned to body. Handled recursively.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody","title":"WorldBody","text":"<p>               Bases: <code>Body</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: BodyName | None = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: str | None = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: bool = False\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: float = 0\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Sleep = AUTO\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.inertial","title":"inertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertial: Inertial | None = None\n</code></pre> <p>Inertial assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[Joint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.freejoints","title":"freejoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>freejoints: Sequence[FreeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Free joints assigned to body. Defining more than one free joint will not do anything</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.geoms","title":"geoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geoms: Sequence[Geom] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Geometries assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.sites","title":"sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sites: Sequence[Site] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Sites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.cameras","title":"cameras  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cameras: Sequence[Camera] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Cameras assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.lights","title":"lights  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>lights: Sequence[Light] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Lights assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.composites","title":"composites  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>composites: Sequence[Composite] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.flexcomps","title":"flexcomps  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flexcomps: Sequence[FlexComp] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Flexible composites assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.attaches","title":"attaches  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attaches: Sequence[Attach] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Attach elements assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.frames","title":"frames  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frames: Sequence[float] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Frames assigned to body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.bodies","title":"bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bodies: Sequence[Body] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Bodies assigned to body. Handled recursively.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/","title":"compiler","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler","title":"compiler","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler","title":"Compiler","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.autolimits","title":"autolimits  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autolimits: bool = True\n</code></pre> <p>This attribute affects the behavior of attributes such as \"limited\" (on  or ), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on ). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.boundmass","title":"boundmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundmass: float = 0\n</code></pre> <p>This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.boundinertia","title":"boundinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundinertia: float = 0\n</code></pre> <p>This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.settotalmass","title":"settotalmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>settotalmass: float = -1\n</code></pre> <p>If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.balanceinertia","title":"balanceinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>balanceinertia: bool = False\n</code></pre> <p>A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.strippath","title":"strippath  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>strippath: bool = False\n</code></pre> <p>When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.coordinate","title":"coordinate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>coordinate: Coordinate = LOCAL\n</code></pre> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>angle: Angle = DEGREE\n</code></pre> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.fitaabb","title":"fitaabb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitaabb: bool = False\n</code></pre> <p>The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.eulerseq","title":"eulerseq  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerseq: EulerSeq | str = xyz\n</code></pre> <p>This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.meshdir","title":"meshdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meshdir: Path | None = None\n</code></pre> <p>This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.texturedir","title":"texturedir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texturedir: Path | None = None\n</code></pre> <p>This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.assetdir","title":"assetdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>assetdir: Path | None = None\n</code></pre> <p>This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.discardvisual","title":"discardvisual  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>discardvisual: bool = False\n</code></pre> <p>This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.</p> <ul> <li>All materials are discarded.</li> <li>All textures are discarded.</li> <li>All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.</li> <li>All meshes which are not referenced by any geom (in particular those discarded above) are discarded.</li> </ul> <p>The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.usethread","title":"usethread  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>usethread: bool = True\n</code></pre> <p>If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.fusestatic","title":"fusestatic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fusestatic: bool = False\n</code></pre> <p>This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless</p> <ul> <li>They are referenced by another element in the model.</li> <li>They contain a site which is referenced by a force or torque sensor.</li> </ul> <p>This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.inertiafromgeom","title":"inertiafromgeom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiafromgeom: InertiaFromGeom = AUTO\n</code></pre> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.alignfree","title":"alignfree  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>alignfree: bool = False\n</code></pre> <p>This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.inertiagrouprange","title":"inertiagrouprange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiagrouprange: InertiaGroupRange = (0, 5)\n</code></pre> <p>This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.saveinertial","title":"saveinertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>saveinertial: bool = False\n</code></pre> <p>If set to \"true\", the compiler will save explicit inertial clauses for all bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/","title":"option","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option","title":"option","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option","title":"Option","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: float = 0.002\n</code></pre> <p>Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.impratio","title":"impratio  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>impratio: float = 1\n</code></pre> <p>This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Vec3 = array((0, 0, -9.81))\n</code></pre> <p>Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>wind: Vec3 = array((0, 0, 0))\n</code></pre> <p>Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.magnetic","title":"magnetic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>magnetic: Vec3 = array((0, -0.5, 0))\n</code></pre> <p>Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 0\n</code></pre> <p>Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.viscosity","title":"viscosity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>viscosity: float = 0\n</code></pre> <p>Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_margin","title":"o_margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_margin: float = 0\n</code></pre> <p>This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_solref","title":"o_solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These attributes replace the solref parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_solimp","title":"o_solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These attributes replace the solimp parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_friction","title":"o_friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_friction: Vec3 = FRICTION_DEFAULT\n</code></pre> <p>These attributes replace the friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.integrator","title":"integrator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>integrator: Integrator = EULER\n</code></pre> <p>This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.cone","title":"cone  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cone: Cone = PYRAMIDAL\n</code></pre> <p>The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.jacobian","title":"jacobian  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>jacobian: Jacobian = AUTO\n</code></pre> <p>The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.solver","title":"solver  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solver: Solver = NEWTON\n</code></pre> <p>This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.iterations","title":"iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>iterations: int = 100\n</code></pre> <p>Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolerance: float = 1e-08\n</code></pre> <p>Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ls_iterations","title":"ls_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_iterations: int = 50\n</code></pre> <p>Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ls_tolerance","title":"ls_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_tolerance: float = 0.01\n</code></pre> <p>Tolerance threshold used for early termination of the linesearch algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.noslip_iterations","title":"noslip_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_iterations: int = 0\n</code></pre> <p>Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.noslip_tolerance","title":"noslip_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_tolerance: float = 1e-06\n</code></pre> <p>Tolerance threshold used for early termination of the Noslip solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ccd_iterations","title":"ccd_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_iterations: int = 50\n</code></pre> <p>Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ccd_tolerance","title":"ccd_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_tolerance: float = 1e-06\n</code></pre> <p>Tolerance threshold used for early termination of the convex collision algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.sleep_tolerance","title":"sleep_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep_tolerance: float = 0.0001\n</code></pre> <p>Velocity tolerance below which sleeping is allowed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.sdf_iterations","title":"sdf_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_iterations: int = 10\n</code></pre> <p>Number of iterations used for Signed Distance Field collisions (per initial point).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.sdf_initpoints","title":"sdf_initpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_initpoints: int = 40\n</code></pre> <p>Number of starting points used for finding contacts with Signed Distance Field collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.actuatorgroupdisable","title":"actuatorgroupdisable  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgroupdisable: set[ActuatorGroup] | None = None\n</code></pre> <p>List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/","title":"size","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size","title":"size","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size","title":"Size","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>memory: str = '-1'\n</code></pre> <p>This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuserdata","title":"nuserdata  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuserdata: int = 0\n</code></pre> <p>The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nkey","title":"nkey  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nkey: int = 0\n</code></pre> <p>The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_body","title":"nuser_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_body: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_jnt","title":"nuser_jnt  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_jnt: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_geom","title":"nuser_geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_geom: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_site","title":"nuser_site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_site: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_cam","title":"nuser_cam  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_cam: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_tendon","title":"nuser_tendon  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_tendon: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each tendon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_actuator","title":"nuser_actuator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_actuator: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each actuator.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_sensor","title":"nuser_sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_sensor: int = -1\n</code></pre> <p>The number of custom user parameters added to the definition of each sensor.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/","title":"statistic","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic","title":"statistic","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic","title":"Statistic","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.meanmass","title":"meanmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meanmass: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.meaninertia","title":"meaninertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meaninertia: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.meansize","title":"meansize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meansize: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>extent: float | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.center","title":"center  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>center: Vec3 | None = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/","title":"asset_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr","title":"asset_attr","text":"<p>Defines child attributes of the Asset class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: HFieldName | None = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: int = 0\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: int = 0\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: VecN | None = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: MaterialName\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Vec2 = array((1, 1))\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: bool = False\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: float = 0\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: float = 0.5\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: float = 0.5\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: float = 0\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: float = -1\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: float = -1\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((1, 1, 1, 1))\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: LayerRole\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> <p>MuJoCo works with triangulated meshes. They can be loaded from binary STL files, OBJ files or MSH files with custom format described below, or vertex and face data specified directly in the XML. Software such as MeshLab can be used to convert from other mesh formats to STL or OBJ. While any collection of triangles can be loaded as a mesh and rendered, collision detection works with the convex hull of the mesh as explained in Collision detection. The mesh appearance (including texture mapping) is controlled by the material and rgba attributes of the referencing geom, similarly to height fields.</p> <p>Meshes can have explicit texture coordinates instead of relying on the automated texture mapping mechanism. When provided, these explicit coordinates have priority. Note that texture coordinates can be specified with OBJ files and MSH files, as well as explicitly in the XML with the texcoord attribute, but not via STL files. These mechanism cannot be mixed. So if you have an STL mesh, the only way to add texture coordinates to it is to convert to one of the other supported formats.</p> <p>Poorly designed meshes can display rendering artifacts. In particular, the shadow mapping mechanism relies on having some distance between front and back-facing triangle faces. If the faces are repeated, with opposite normals as determined by the vertex order in each triangle, this causes shadow aliasing. The solution is to remove the repeated faces (which can be done in MeshLab) or use a better designed mesh. Flipped faces are checked by MuJoCo for meshes specified as OBJ or XML and an error message is returned.</p> <p>The size of the mesh is determined by the 3D coordinates of the vertex data in the mesh file, multiplied by the components of the scale attribute below. Scaling is applied separately for each coordinate axis. Note that negative scaling values can be used to flip the mesh; this is a legitimate operation. The size parameters of the referencing geoms are ignored, similarly to height fields. We also provide a mechanism to translate and rotate the 3D coordinates, using the attributes refpos and refquat.</p> <p>A mesh can also be defined without faces (a point cloud essentially). In that case the convex hull is constructed automatically.This makes it easy to construct simple shapes directly in the XML. For example, a pyramid can be created as follows:</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh name=\"tetrahedron\" vertex=\"0 0 0  1 0 0  0 1 0  0 0 1\"/&gt;\n&lt;/asset&gt;\n</code></pre> <p>Positioning and orienting is complicated by the fact that vertex data in the source asset are often relative to coordinate frames whose origin is not inside the mesh. In contrast, MuJoCo expects the origin of a geom's local frame to coincide with the geometric center of the shape. We resolve this discrepancy by pre-processing the mesh in the compiler, so that it is centered around (0,0,0) and its principal axes of inertia are the coordinate axes. We save the translation and rotation offsets applied to the source asset in mjModel.mesh_pos and mjModel.mesh_quat; these are required if one reads vertex data from the source and needs to re-apply the transform. These offsets are then composed with the referencing geom's position and orientation; see also the mesh attribute of geom below. Fortunately most meshes used in robot models are designed in a coordinate frame centered at the joint. This makes the corresponding MJCF model intuitive: we set the body frame at the joint, so that the joint position is (0,0,0) in the body frame, and simply reference the mesh. Below is an MJCF model fragment of a forearm, containing all the information needed to put the mesh where one would expect it to be. The body position is specified relative to the parent body, namely the upper arm (not shown). It is offset by 35 cm which is the typical length of the human upper arm. If the mesh vertex data were not designed in the above convention, we would have to use the geom position and orientation (or the refpos, refquat mechanism) to compensate, but in practice this is rarely needed.</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh file=\"forearm.stl\"/&gt;\n&lt;/asset&gt;\n\n&lt;body pos=\"0 0 0.35\"/&gt;\n    &lt;joint type=\"hinge\" axis=\"1 0 0\"/&gt;\n    &lt;geom type=\"mesh\" mesh=\"forearm\"/&gt;\n&lt;/body&gt;\n</code></pre> <p>The inertial computation mentioned above is part of an algorithm used not only to center and align the mesh, but also to infer the mass and inertia of the body to which it is attached. This is done by computing the centroid of the triangle faces, connecting each face with the centroid to form a triangular pyramid, computing the mass and signed inertia of all pyramids (considered solid, or hollow if shellinertia is true) and accumulating them. The sign ensures that pyramids on the outside of the surfaces are subtracted, as can occur with concave geometries. This algorithm can be found in section 1.3.8 of Computational Geometry in C (Second Edition) by Joseph O'Rourke.</p> <p>The full list of processing steps applied by the compiler to each mesh is as follows:</p> <ol> <li>For STL meshes, remove any repeated vertices and re-index the faces if needed. If the mesh is not STL, we assume that the desired vertices and faces have already been generated and do not apply removal or re-indexing;</li> <li>If vertex normals are not provided, generate normals automatically, using a weighted average of the surrounding face normals. If sharp edges are encountered, the renderer uses the face normals to preserve the visual information about the edge, unless smoothnormal is true. Note that normals cannot be provided with STL meshes;</li> <li>Scale, translate and rotate the vertices and normals, re-normalize the normals in case of scaling. Save these transformations in mjModel.mesh_{pos, quat, scale}.</li> <li>Construct the convex hull if specified;</li> <li>Find the centroid of all triangle faces, and construct the union-of-pyramids representation. Triangles whose area is too small (below the mjMINVAL value of 1E-14) result in compile error;</li> <li>Compute the center of mass and inertia matrix of the union-of-pyramids. Use eigenvalue decomposition to find the principal axes of inertia. Center and align the mesh, saving the translational and rotational offsets for subsequent geom-related computations.</li> </ol>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: ModelName | None = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: TextureName | None = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: TextureType = CUBE\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: ColorSpace = AUTO\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Path | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: tuple[int, int] = (1, 1)\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: GridLayoutStr = '............'\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {<code>'.'</code>, <code>'R'</code>, <code>'L'</code>, <code>'U'</code>, <code>'D'</code>, <code>'F'</code>, <code>'B'</code>}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The <code>'.'</code> character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/","title":"hfield","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield","title":"hfield","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: HFieldName | None = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: int = 0\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: int = 0\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: VecN | None = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/","title":"material","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material","title":"material","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: MaterialName\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Vec2 = array((1, 1))\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: bool = False\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: float = 0\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: float = 0.5\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: float = 0.5\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: float = 0\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: float = -1\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: float = -1\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((1, 1, 1, 1))\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/","title":"mesh","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh","title":"mesh","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> <p>MuJoCo works with triangulated meshes. They can be loaded from binary STL files, OBJ files or MSH files with custom format described below, or vertex and face data specified directly in the XML. Software such as MeshLab can be used to convert from other mesh formats to STL or OBJ. While any collection of triangles can be loaded as a mesh and rendered, collision detection works with the convex hull of the mesh as explained in Collision detection. The mesh appearance (including texture mapping) is controlled by the material and rgba attributes of the referencing geom, similarly to height fields.</p> <p>Meshes can have explicit texture coordinates instead of relying on the automated texture mapping mechanism. When provided, these explicit coordinates have priority. Note that texture coordinates can be specified with OBJ files and MSH files, as well as explicitly in the XML with the texcoord attribute, but not via STL files. These mechanism cannot be mixed. So if you have an STL mesh, the only way to add texture coordinates to it is to convert to one of the other supported formats.</p> <p>Poorly designed meshes can display rendering artifacts. In particular, the shadow mapping mechanism relies on having some distance between front and back-facing triangle faces. If the faces are repeated, with opposite normals as determined by the vertex order in each triangle, this causes shadow aliasing. The solution is to remove the repeated faces (which can be done in MeshLab) or use a better designed mesh. Flipped faces are checked by MuJoCo for meshes specified as OBJ or XML and an error message is returned.</p> <p>The size of the mesh is determined by the 3D coordinates of the vertex data in the mesh file, multiplied by the components of the scale attribute below. Scaling is applied separately for each coordinate axis. Note that negative scaling values can be used to flip the mesh; this is a legitimate operation. The size parameters of the referencing geoms are ignored, similarly to height fields. We also provide a mechanism to translate and rotate the 3D coordinates, using the attributes refpos and refquat.</p> <p>A mesh can also be defined without faces (a point cloud essentially). In that case the convex hull is constructed automatically.This makes it easy to construct simple shapes directly in the XML. For example, a pyramid can be created as follows:</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh name=\"tetrahedron\" vertex=\"0 0 0  1 0 0  0 1 0  0 0 1\"/&gt;\n&lt;/asset&gt;\n</code></pre> <p>Positioning and orienting is complicated by the fact that vertex data in the source asset are often relative to coordinate frames whose origin is not inside the mesh. In contrast, MuJoCo expects the origin of a geom's local frame to coincide with the geometric center of the shape. We resolve this discrepancy by pre-processing the mesh in the compiler, so that it is centered around (0,0,0) and its principal axes of inertia are the coordinate axes. We save the translation and rotation offsets applied to the source asset in mjModel.mesh_pos and mjModel.mesh_quat; these are required if one reads vertex data from the source and needs to re-apply the transform. These offsets are then composed with the referencing geom's position and orientation; see also the mesh attribute of geom below. Fortunately most meshes used in robot models are designed in a coordinate frame centered at the joint. This makes the corresponding MJCF model intuitive: we set the body frame at the joint, so that the joint position is (0,0,0) in the body frame, and simply reference the mesh. Below is an MJCF model fragment of a forearm, containing all the information needed to put the mesh where one would expect it to be. The body position is specified relative to the parent body, namely the upper arm (not shown). It is offset by 35 cm which is the typical length of the human upper arm. If the mesh vertex data were not designed in the above convention, we would have to use the geom position and orientation (or the refpos, refquat mechanism) to compensate, but in practice this is rarely needed.</p> XML<pre><code>&lt;asset&gt;\n    &lt;mesh file=\"forearm.stl\"/&gt;\n&lt;/asset&gt;\n\n&lt;body pos=\"0 0 0.35\"/&gt;\n    &lt;joint type=\"hinge\" axis=\"1 0 0\"/&gt;\n    &lt;geom type=\"mesh\" mesh=\"forearm\"/&gt;\n&lt;/body&gt;\n</code></pre> <p>The inertial computation mentioned above is part of an algorithm used not only to center and align the mesh, but also to infer the mass and inertia of the body to which it is attached. This is done by computing the centroid of the triangle faces, connecting each face with the centroid to form a triangular pyramid, computing the mass and signed inertia of all pyramids (considered solid, or hollow if shellinertia is true) and accumulating them. The sign ensures that pyramids on the outside of the surfaces are subtracted, as can occur with concave geometries. This algorithm can be found in section 1.3.8 of Computational Geometry in C (Second Edition) by Joseph O'Rourke.</p> <p>The full list of processing steps applied by the compiler to each mesh is as follows:</p> <ol> <li>For STL meshes, remove any repeated vertices and re-index the faces if needed. If the mesh is not STL, we assume that the desired vertices and faces have already been generated and do not apply removal or re-indexing;</li> <li>If vertex normals are not provided, generate normals automatically, using a weighted average of the surrounding face normals. If sharp edges are encountered, the renderer uses the face normals to preserve the visual information about the edge, unless smoothnormal is true. Note that normals cannot be provided with STL meshes;</li> <li>Scale, translate and rotate the vertices and normals, re-normalize the normals in case of scaling. Save these transformations in mjModel.mesh_{pos, quat, scale}.</li> <li>Construct the convex hull if specified;</li> <li>Find the centroid of all triangle faces, and construct the union-of-pyramids representation. Triangles whose area is too small (below the mjMINVAL value of 1E-14) result in compile error;</li> <li>Compute the center of mass and inertia matrix of the union-of-pyramids. Use eigenvalue decomposition to find the principal axes of inertia. Center and align the mesh, saving the translational and rotational offsets for subsequent geom-related computations.</li> </ol>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere","title":"MeshSphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Repeated subdivisions of a unit icosahedron (\"icosphere\").</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.subdivision","title":"subdivision  <code>instance-attribute</code>","text":"Python<pre><code>subdivision: int\n</code></pre> <p>integer in [0-4]: The number of subdivisions to apply to icosahedron faces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere","title":"MeshHemisphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Quad-projected hemisphere.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer in [0-10]: Equator discretization of one hemisphere quadrant.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone","title":"MeshCone","text":"<p>               Bases: <code>Mesh</code></p> <p>Cone mesh from top and bottom polygons.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.nvert","title":"nvert  <code>instance-attribute</code>","text":"Python<pre><code>nvert: int\n</code></pre> <p>integer &gt;= 3: The number of vertices in the polygon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in [0, 1]: The radius of the top face.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere","title":"MeshSupersphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Supersphere (superellipsoid) shape.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Longitude and latitude discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.e","title":"e  <code>instance-attribute</code>","text":"Python<pre><code>e: float\n</code></pre> <p>real &gt;= 0: The 'east-west' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.n","title":"n  <code>instance-attribute</code>","text":"Python<pre><code>n: float\n</code></pre> <p>real &gt;= 0: The 'north-south' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus","title":"MeshTorus","text":"<p>               Bases: <code>Mesh</code></p> <p>Supertorus (generalized torus) shape.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Discretization of both circumferences.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in (0, 1]: Minor radius of the torus.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.s","title":"s  <code>instance-attribute</code>","text":"Python<pre><code>s: float\n</code></pre> <p>real &gt; 0: The 'squareness' of minor sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.t","title":"t  <code>instance-attribute</code>","text":"Python<pre><code>t: float\n</code></pre> <p>real &gt; 0: The 'squareness' of major sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge","title":"MeshWedge","text":"<p>               Bases: <code>Mesh</code></p> <p>Slice of a unit spherical shell.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.res_phi","title":"res_phi  <code>instance-attribute</code>","text":"Python<pre><code>res_phi: int\n</code></pre> <p>integer &gt;= 0: Vertical resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.res_theta","title":"res_theta  <code>instance-attribute</code>","text":"Python<pre><code>res_theta: int\n</code></pre> <p>integer &gt;= 0: Horizontal resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.fov_phi","title":"fov_phi  <code>instance-attribute</code>","text":"Python<pre><code>fov_phi: float\n</code></pre> <p>real in (0, 180]: Horizontal field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.fov_theta","title":"fov_theta  <code>instance-attribute</code>","text":"Python<pre><code>fov_theta: float\n</code></pre> <p>real in (0, 90): Vertical field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.gamma","title":"gamma  <code>instance-attribute</code>","text":"Python<pre><code>gamma: float\n</code></pre> <p>real in [0, 1]: Foveal deformation of the discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate","title":"MeshPlate","text":"<p>               Bases: <code>Mesh</code></p> <p>Rectangular plate mesh.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.res_x","title":"res_x  <code>instance-attribute</code>","text":"Python<pre><code>res_x: int\n</code></pre> <p>integer &gt; 0: Horizontal resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.res_y","title":"res_y  <code>instance-attribute</code>","text":"Python<pre><code>res_y: int\n</code></pre> <p>integer &gt; 0: Vertical resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: MeshName | None = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 = array((1, 1, 1))\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Inertia = CONVEX\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: bool = False\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: int = -1\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: tuple[tuple[float, float], ...] | None = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: tuple[tuple[float, float, float], ...] | None = None\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Pos = Pos(pos=array((1, 1, 1)))\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Quat = Quat()\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/","title":"model","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model","title":"model","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: ModelName | None = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: str | None = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/","title":"texture","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture","title":"texture","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: TextureName | None = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: TextureType = CUBE\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: ColorSpace = AUTO\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Path | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: tuple[int, int] = (1, 1)\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: GridLayoutStr = '............'\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {<code>'.'</code>, <code>'R'</code>, <code>'L'</code>, <code>'U'</code>, <code>'D'</code>, <code>'F'</code>, <code>'B'</code>}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The <code>'.'</code> character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn","title":"TextureBuiltIn","text":"<p>               Bases: <code>Texture</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.builtin","title":"builtin  <code>instance-attribute</code>","text":"Python<pre><code>builtin: TextureBuiltInType\n</code></pre> <p>This and the remaining attributes control the generation of procedural textures. If the value of this attribute is different from \"none\", the texture is treated as procedural and any file names are ignored. The keywords have the following meaning: * gradient     * Generates a color gradient from rgb1 to rgb2. The interpolation in color space is done through a sigmoid function. For cube and skybox textures the gradient is along the +Y axis, i.e., from top to bottom for skybox rendering. * checker     * Generates a 2-by-2 checker pattern with alternating colors given by rgb1 and rgb2. This is suitable for rendering ground planes and also for marking objects with rotational symmetries. Note that 2d textures can be scaled so as to repeat the pattern as many times as necessary. For cube and skybox textures, the checker pattern is painted on each side of the cube. * flat     * Fills the entire texture with rgb1, except for the bottom face of cube and skybox textures which is filled with rgb2.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.rgb1","title":"rgb1  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgb1: Vec3 = array((0.8, 0.8, 0.8))\n</code></pre> <p>The first color used for procedural texture generation. This color is also used to fill missing sides of cube and skybox textures loaded from files. The components of this and all other RGB(A) vectors should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.rgb2","title":"rgb2  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgb2: Vec3 = array((0.5, 0.5, 0.5))\n</code></pre> <p>The second color used for procedural texture generation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.mark","title":"mark  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mark: Mark = NONE\n</code></pre> <p>Procedural textures can be marked with the markrgb color, on top of the colors determined by the builtin type. \"edge\" means that the edges of all texture images are marked. \"cross\" means that a cross is marked in the middle of each image. \"random\" means that randomly chosen pixels are marked. All markings are one-pixel wide, thus the markings appear larger and more diffuse on smaller textures.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.markrgb","title":"markrgb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>markrgb: Vec3 = array((0, 0, 0))\n</code></pre> <p>The color used for procedural texture markings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.random","title":"random  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>random: float = 0.01\n</code></pre> <p>When the mark attribute is set to \"random\", this attribute determines the probability of turning on each pixel. Note that larger textures have more pixels, and the probability here is applied independently to each pixel - thus the texture size and probability need to be adjusted jointly. Together with a gradient skybox texture, this can create the appearance of a night sky with stars. The random number generator is initialized with a fixed seed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>width: int = 0\n</code></pre> <p>The width of a procedural texture, i.e., the number of columns in the image. Larger values usually result in higher quality images, although in some cases (e.g. checker patterns) small values are sufficient. For textures loaded from files, this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.height","title":"height  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>height: int = 0\n</code></pre> <p>The height of the procedural texture, i.e., the number of rows in the image. For cube and skybox textures, this attribute is ignored and the height is set to 6 times the width. For textures loaded from files, this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.hflip","title":"hflip  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>hflip: bool = False\n</code></pre> <p>If true, images loaded from file are flipped in the horizontal direction. Does not affect procedural textures.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.vflip","title":"vflip  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vflip: bool = False\n</code></pre> <p>If true, images loaded from file are flipped in the vertical direction. Does not affect procedural textures.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.nchannel","title":"nchannel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nchannel: int = 3\n</code></pre> <p>The number of channels in the texture image file. This allows loading 4-channel textures (RGBA) or single-channel textures (e.g., for Physics-Based Rendering properties such as roughness or metallic).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: TextureName | None = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: TextureType = CUBE\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: ColorSpace = AUTO\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Path | None = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: tuple[int, int] = (1, 1)\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: GridLayoutStr = '............'\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {<code>'.'</code>, <code>'R'</code>, <code>'L'</code>, <code>'U'</code>, <code>'D'</code>, <code>'F'</code>, <code>'B'</code>}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The <code>'.'</code> character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Path | None = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureBuiltIn.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/","title":"material_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr","title":"material_attr","text":"<p>Defines child attributes of the Material class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: LayerRole\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/","title":"layer","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer","title":"layer","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: LayerRole\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/","title":"body_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr","title":"body_attr","text":"<p>Defines child attributes of the Body class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach","title":"Attach","text":"<p>               Bases: <code>XMLModel</code></p> <p>The attach element is used to insert a sub-tree of bodies from another model into this model's kinematic tree. Unlike include, which is implemented in the parser and is equivalent to copying and pasting XML from one file into another, attach is implemented in the model compiler. In order to use this element, the sub-model must first be defined as an asset. When creating an attachment, the top body of the attached subtree is specified, and all referencing elements outside the kinematic tree (e.g., sensors and actuators), are also copied into the top-level model. Additionally, any elements referenced from within the attached subtree (e.g. defaults and assets) will be copied in to the top-level model. attach is a Meta elements, so upon saving all attachments will appear in the saved XML file. Note that this element is a subset of the functionality of the procedural attachment functionality. As such, it shares the same limitations as described there. In addition, when the attach element is used, it is not possible to attach an entire model (i.e. including all elements, referenced or not).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach.model","title":"model  <code>instance-attribute</code>","text":"Python<pre><code>model: ModelName\n</code></pre> <p>The sub-model from which to attach a subtree.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach.body","title":"body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>body: BodyName | None = None\n</code></pre> <p>Name of the body in the sub-model to attach here. The body and its subtree will be attached. If this attribute is not specified, the contents of the world body will be attached in a new frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach.prefix","title":"prefix  <code>instance-attribute</code>","text":"Python<pre><code>prefix: str\n</code></pre> <p>Prefix to prepend to names of elements in the sub-model. This attribute is required to prevent name collisions with the parent or when attaching the same sub-tree multiple times.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Attach.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera","title":"Camera","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a camera, which moves with the body where it is defined. To create a fixed camera, define it in the world body. The cameras created here are in addition to the default free camera which is always defined and is adjusted via the visual element. Internally MuJoCo uses a flexible camera model, where the viewpoint and projection surface are adjusted independently so as to obtain oblique projections needed for virtual environments. This functionality however is not accessible through MJCF. Instead, the cameras created with this element (as well as the free camera) have a viewpoint that is always centered in front of the projection surface. The viewpoint coincides with the center of the camera frame. The camera is looking along the -Z axis of its frame. The +X axis points to the right, and the +Y axis points up. Thus the frame position and orientation are the key adjustments that need to be made here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: CameraName | None = None\n</code></pre> <p>Name of the camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This attribute specifies how the camera position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the camera sees).</p> <ul> <li><code>fixed</code> means that the position and orientation specified below are fixed relative to the body where the camera is defined.</li> <li><code>track</code> means that the camera position is at a constant offset from the body in world coordinates, while the camera orientation is constant in world coordinates. These constants are determined by applying forward kinematics in qpos0 and treating the camera as fixed. Tracking can be used for example to position a camera above a body, point it down so it sees the body, and have it always remain above the body no matter how the body translates and rotates.</li> <li><code>trackcom</code> is similar to \"track\" but the constant spatial offset is defined relative to the center of mass of the kinematic subtree starting at the body in which the camera is defined. This can be used to keep an entire mechanism in view. Note that the subtree center of mass for the world body is the center of mass of the entire model. So if a camera is defined in the world body in mode \"trackcom\", it will track the entire model.</li> <li><code>targetbody</code> means that the camera position is fixed in the body frame, while the camera orientation is adjusted so that it always points towards the targeted body (which is specified with the target attribute below). This can be used for example to model an eye that fixates a moving object; the object will be the target, and the camera/eye will be defined in the body corresponding to the head.</li> <li><code>targetbodycom</code> is the same as \"targetbody\" but the camera is oriented towards the center of mass of the subtree starting at the target body.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>When the camera mode is \"targetbody\" or \"targetbodycom\", this attribute becomes required. It specifies which body should be targeted by the camera. In all other modes this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.orthographic","title":"orthographic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orthographic: bool = False\n</code></pre> <p>Whether the camera uses a perspective projection (the default) or an orthographic projection. Setting this attribute changes the semantic of the fovy attribute, see below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.fovy","title":"fovy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fovy: float = 45\n</code></pre> <p>Vertical field-of-view of the camera. If the camera uses a perspective projection, the field-of-view is expressed in degrees, regardless of the global compiler/angle setting. If the camera uses an orthographic projection, the field-of-view is expressed in units of length; note that in this case the default of 45 is too large for most scenes and should likely be reduced. In either case, the horizontal field of view is computed automatically given the window size and the vertical field of view.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>resolution: tuple[int, int] = (1, 1)\n</code></pre> <p>Resolution of the camera in pixels [width height]. Note that these values are not used for rendering since those dimensions are determined by the size of the rendering context. This attribute serves as a convenient location to save the required resolution when creating a context.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.focal","title":"focal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focal: Vec2 = array((0, 0))\n</code></pre> <p>Focal length of the camera in length units. It is mutually exclusive with fovy. See Cameras for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.focalpixel","title":"focalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focalpixel: tuple[int, int] = (1, 1)\n</code></pre> <p>Focal length of the camera in pixel units. If both focal and focalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.principal","title":"principal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principal: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in length units. It is mutually exclusive with fovy.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.principalpixel","title":"principalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principalpixel: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in pixel units. If both principal and principalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.sensorsize","title":"sensorsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensorsize: Vec2 = array((0, 0))\n</code></pre> <p>Size of the camera sensor in length units. It is mutually exclusive with fovy. If specified, resolution and focal are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.ipd","title":"ipd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ipd: float = 0.068\n</code></pre> <p>Inter-pupilary distance. This attribute only has an effect during stereoscopic rendering. It specifies the distance between the left and right viewpoints. Each viewpoint is shifted by +/- half of the distance specified here, along the X axis of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the camera frame. See Frame orientations. Note that specifically for cameras, the xyaxes attribute is semantically convenient as the X and Y axes correspond to the directions \"right\" and \"up\" in pixel space, respectively.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Camera.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite","title":"Composite","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>prefix: str | None = None\n</code></pre> <p>All automatically generated model elements have names indicating the element type and index. For example, the body at coordinates (2, 0) in a 2D grid is named \"B2_0\" by default. If prefix=\"C\" is specified, the same body is named \"CB2_0\". The prefix is needed when multiple composite objects are used in the same model, to avoid name conflicts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: CompositeType = CABLE\n</code></pre> <p>This attribute determines the type of composite object. The only supported type is cable.</p> <p>The <code>cable</code> type creates a 1D chain of bodies connected with ball joints, each having a geom with user-defined type (cylinder, capsule or box). The geometry can either be defined with an array of 3D vertex coordinates vertex or with prescribed functions with the option curve. Currently, only linear and trigonometric functions are supported. For example, an helix can be obtained with curve=\"cos(s) sin(s) s\". The size is set with the option size, resulting in f(s)={size[1]\u22c5cos(2\u03c0\u22c5size[2]), size[1]\u22c5sin(2\u03c0\u22c5size[2]),  size[0]\u22c5s}.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.count","title":"count  <code>instance-attribute</code>","text":"Python<pre><code>count: Tuple[int] | Tuple[int, int] | Tuple[int, int, int]\n</code></pre> <p>The element count in each dimension of the grid. This can have 1, 2 or 3 numbers, specifying the element count along the X, Y and Z axis of the parent body frame within. Any missing numbers default to 1. If any of these numbers is 1, all subsequent numbers must also be 1, so that the leading dimensions of the grid are used. This means for example that a 1D grid will always extend along the X axis. To achieve a different orientation, rotate the frame of the parent body. Note that some types imply a grid of certain dimensionality, so the requirements for this attribute depend on the specified type.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>offset: Vec3 = array((0, 0, 0))\n</code></pre> <p>It specifies a 3D offset from the center of the parent body to the center of the first body of the cable. The offset is expressed in the local coordinate frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Quat = Quat(quat=array((1, 0, 0, 0)))\n</code></pre> <p>It specifies a quaternion that rotates the first body frame. The quaternion is expressed in the parent body frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: VecN | None = None\n</code></pre> <p>Vertex 3D positions in global coordinates.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.initial","title":"initial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>initial: CompositeInitial = NONE\n</code></pre> <p>Behavior of the first point. Free: free joint. Ball: ball joint. None: no dof.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.curve","title":"curve  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>curve: tuple[str, str, str] | None = None\n</code></pre> <p>Functions specifying the vertex positions. Available functions are s, cos(s), and sin(s), where s is the arc length parameter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: tuple[int, int, int] | None = None\n</code></pre> <p>Scaling of the curve functions. size[0] is the scaling of s, size[1] is the radius of cos(s) and sin(s), and size[2] is the speed of the argument (i.e. cos(2pisize[2]*s)).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[CompositeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.geom","title":"geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geom: CompositeGeom | None = None\n</code></pre> <p>Geometry assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.site","title":"site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>site: CompositeSite | None = None\n</code></pre> <p>Site assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.skin","title":"skin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>skin: Skin | None = None\n</code></pre> <p>Skin assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Composite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint","title":"CompositeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>Depending on the composite type, some joints are created automatically (e.g. the universal joints in rope) while other joints are optional (e.g. the stretch and twist joints in rope). This sub-element is used to specify which optional joints should be created, as well as to adjust the attributes of both automatic and optional joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.kind","title":"kind  <code>instance-attribute</code>","text":"Python<pre><code>kind: CompositeJointKind\n</code></pre> <p>The joint kind here is orthogonal to the joint type in the rest of MJCF. The joint kind refers to the function of the joint within the mechanism comprising the composite body, while the joint type (hinge or slide) is implied by the joint kind and composite body type.</p> <p>The main kind corresponds to the main joints forming each composite type. These joints are automatically included in the model even if the joint sub-element is missing. The main joints are 3D sliders for particle and grid; 1D sliders for box, cylinder and rope; universal joints for cloth, rope and loop. Even though the main joints are included automatically, this sub-element is still useful for adjusting their attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.solreffix","title":"solreffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffix: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.solimpfix","title":"solimpfix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfix: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Joint stiffness. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.</p> <p>Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite","title":"CompositeSite","text":"<p>               Bases: <code>SiteBase</code></p> <p>This sub-element adjusts the attributes of the sites in the composite object. Otherwise it is the same as geom above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>Sizes of the geometric shape representing the site. What shape it is I do not know.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.CompositeSite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin","title":"Skin","text":"<p>               Bases: <code>XMLModel</code></p> <p>If this element is included, the model compiler will generate a skinned mesh asset and attach it to the element bodies of the composite object. Skin can be attached to 2D grid, cloth, box, cylinder and ellipsoid. For other composite types it has no effect. Note that the skin created here is equivalent to a skin specified directly in the XML, as opposed to a skin loaded from file. So if the model is saved as XML, it will contain a large section describing the automatically-generated skin.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: bool = False\n</code></pre> <p>If this is true, explicit texture coordinates will be generated, mapping the skin to the unit square in texture space. This is needed when the material specifies a texture. If texcoord is false and the skin has texture, the texture will appear fixed to the world instead of the skin. The reason for having this attribute in the first place is because skins with texture coordinates upload these coordinates to the GPU even if no texture is applied later. So this attribute should be set to false in cases where no texture will be applied via the material attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.inflate","title":"inflate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inflate: float = 0\n</code></pre> <p>The default value of 0 means that the automatically-generated skin passes through the centers of the body elements comprising the composite object. Positive values offset each skin vertex by the specified amount, in the direction normal to the (non-inflated) skin at that vertex. This has two uses. First, in 2D objects, a small positive inflate factor is needed to avoid aliasing artifacts. Second, collisions are done with geoms that create some thickness, even for 2D objects. Inflating the skin with a value equal to the geom size will render the skin as a \"mattress\" that better represents the actual collision geometry. The value of this attribute is copied into the corresponding attribute of the skin asset being created.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.subgrid","title":"subgrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>subgrid: int = 0\n</code></pre> <p>This is only applicable to cloth and 2D grid types, and has no effect for any other composite type. The default value of 0 means that the skin has as many vertices as the number of element bodies. A positive value causes subdivision, with the specified number of (additional) grid lines. In this case the model compiler generates a denser skin using bi-cubic interpolation. This increases the quality of the rendering (especially in the absence of textures) but also slows down the renderer, so use it with caution. Values above 3 are unlikely to be needed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Skin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp","title":"FlexComp","text":"<p>               Bases: <code>XMLModel</code></p> <p>Similar to composite, this element (new in MuJoCo 3.0) is not a model element, but rather a macro which expands into multiple model elements representing a deformable entity. In particular this macro creates one flex element, a number of bodies that are children of the body in which the flexcomp is defined, and optionally one flex equality which constrains all flex edges to their initial length. A number of attributes are specified here and then passed through to the automatically-constructed flex. The primary role of flexcomp is to automate the creation of a (possibly large) collection of moving bodies with corresponding joints, and connect them with stretchable flex elements. See flex and deformable objects documentation for specifics on how flexes work. Here we only describe the automated construction process.</p> <p>An important distinction between flex and flexcomp is that the flex references bodies and specifies vertex coordinates in the frames of those bodies, while the flexcomp defines points. Each flexcomp point corresponds to one body and one vertex in the underlying flex. If the flexcomp point is pinned, the corresponding flex body is the parent body of the flexcomp, while the corresponding flex vertex coordinates equal the flexcomp point coordinates. If the flexcomp point is not pinned, a new child body is created at the coordinates of the flexcomp point (within the flexcomp parent body), and then the coordinates of the flex vertex within that new body are (0,0,0). The mechanism for pinning flexcomp points is explained below.</p> <p>Composite objects (available prior to MuJoCo 3.0) needed bodies with geoms for collisions, and sites for connecting tendons which generated shape-preserving forces. In contrast, flexes generate their own collisions and shape-preserving forces (as well as rendering), thus the bodies created here are much simpler: no geoms, sites or tendons are needed. Most of the bodies created here have 3 orthogonal slider joints, corresponding to freely moving point masses. In some cases we generate radial slider joints, allowing only expansion and contraction. Since no geoms are generated, the bodies need to have explicit inertial parameters.</p> <p>Below is a simple example of a flexcomp, modeling a (somewhat flexible) double pendulum with one end pinned to the world:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;flexcomp name=\"FL\" type=\"grid\" dim=\"1\" count=\"3 1 1\" mass=\"3\" spacing=\"0.2 0.2 0.2\"&gt;\n            &lt;pin id=\"0\"/&gt;\n        &lt;/flexcomp&gt;\n    &lt;/worldbody&gt;\n&lt;/mujoco&gt;\n</code></pre> <p>This flexcomp has 3 points, however the first point is pinned to the world (i.e. the parent of the flexcomp) and so only two bodies are automatically created, namely FL_1 and FL_2. Here is what this flexcomp generates after loading and saving the XML:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"FL_1\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n        &lt;body name=\"FL_2\" pos=\"0.2 0 0\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n    &lt;deformable&gt;\n        &lt;flex name=\"FL\" dim=\"1\" body=\"world FL_1 FL_2\" vertex=\"-0.2 0 0 0 0 0 0 0 0\" element=\"0 1 1 2\"/&gt;\n    &lt;/deformable&gt;\n    &lt;equality&gt;\n        &lt;flex flex=\"FL\"/&gt;\n    &lt;/equality&gt;\n&lt;/mujoco&gt;\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>The name of the flex element being generated automatically. This name is used as a prefix for all bodies that are automatically generated here, and is also referenced by the corresponding flex equality constraint (if applicable).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dim: int | None = None\n</code></pre> <p>Dimensionality of the flex object. This value must be 1, 2 or 3. The flex elements are capsules in 1D, triangles with radius in 2D, and tetrahedra with radius in 3D. Certain flexcomp types imply a dimensionality, in which case the value specified here is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.dof","title":"dof  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dof: FlexCompDOF | None = None\n</code></pre> <p>The parametrization of the flex's degrees of freedom (dofs). See the video on the right illustrating the different parametrizations with deformable spheres. The three models in the video are respectively sphere_full, sphere_radial and sphere_trilinear.</p> <ul> <li><code>full</code>: Three translational dofs per vertex. This is the most expressive but also the most expensive option.</li> <li><code>radial</code>: A single radial translational dof per vertex. Note that unlike in the \"full\" case, the radial parametrization requires a free joint at the flex's parent in order for free body motion to be possible. This type of parametrization is appropriate for shapes that are relatively spherical.</li> <li><code>trilinear</code>: Three translational dofs at each corner of the bounding box of the flex, for a total of 24 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using trilinear interpolation over the bounding box.</li> </ul> <p>Trilinear and quadratic flexes are much faster than the previous two options, and are the preferred choice if the expected deformations can be captured by the reduced parametriation. For example, see the video on the right comparing full and trilinear flexes for modeling deformable gripper pads.</p> <p>Note that the choice of dof parametrization affects the deformation modes of the flex but has no effect on the accuracy of the collision geometry, which always takes into account the high-resolution mesh of the flex.</p> <ul> <li><code>quadratic</code>: Three translational dofs per corner, edge, face, and volume of the bounding box of the flex, for a total of 81 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using quadratic interpolation over the bounding box. While this option requires more degrees of freedom than trilinear flexes, it enables curved deformation modes, while the only modes achievable for trilinear flexes are strech/compression and shear.</li> </ul> <p>Note that a higher interpolation order generally requires a smaller time step for stability, although usually not as large as with the \"full\" option and a fine mesh.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: FlexCompType | None = None\n</code></pre> <p>This attribute determines the type of flexcomp object. The remaining attributes and sub-elements are then interpreted according to the type. Default settings are also adjusted depending on the type. Different types correspond to different methods for specifying the flexcomp points and the stretchable elements that connect them. They fall in three categories: direct specification entered in the XML, direct specification loaded from file, and automated generation from higher-level specification.</p> <p><code>grid</code> generates a rectangular grid of points in 1D, 2D or 3D as specified by dim. The number of points in each dimension is determined by count while the grid spacing in each dimension is determined by spacing. Make sure the spacing is sufficiently large relative to radius to avoid permanent contacts. In 2D and 3D the grid is automatically triangulated, and corresponding flex elements are created (triangles or tetrahedra). In 1D the elements are capsules connecting consecutive pairs of points.</p> <p><code>box</code> generates a 3D box object, however flex bodies are only generated on the outer shell. Each flex body has a radial slider joint allowing it to move in and out from the center of the box. The parent body would normally be a floating body. The box surface is triangulated, and each flex element is a tetrahedron connecting the center of the box with one triangle face. count and spacing determine the count and spacing of the flex bodies, similar to the grid type in 3D. Note that the resulting flex has the same topology as the box generated by composite.</p> <p><code>cylinder</code> is the same as box, except the points are projected on the surface of a cylinder.</p> <p><code>ellipsoid</code> is the same as box, except the points are projected on the surface of an ellipsoid.</p> <p><code>disc</code> is the same as box, except the points are projected on the surface of a disc. It is only compatible with dim=2.</p> <p><code>circle</code> is the same as grid, except the points are sampled along a circle so that the first and last points are the same. The radius of the circle is computed such that each segment has the requested spacing. It is only compatible with dim=1.</p> <p><code>mesh</code> loads the flexcomp points and elements (i.e. triangles) from a mesh file, in the same file formats as mesh assets, excluding the legacy .msh format. A mesh asset is not actually added to the model. Instead the vertex and face data from the mesh file are used to populate the point and element data of the flexcomp. dim is automatically set to 2. Recall that a mesh asset in MuJoCo can be used as a rigid geom attached to a single body. In contrast, the flex generated here corresponds to a soft mesh with the same initial shape, where each vertex is a separate moving body (unless pinned).</p> <p><code>gmsh</code> is similar to mesh, but it loads a GMSH file in format 4.1 and format 2.2 (ascii or binary). The file extension can be anything; the parser recognizes the format by examining the file header. This is a very rich file format, allowing all kinds of elements with different dimensionality and topology. MuJoCo only supports GMSH element types 1, 2, 4 which happen to correspond to our 1D, 2D and 3D flexes and assumes that the nodes are specified in a single block. Only the Nodes and Elements sections of the GMHS file are processed, and used to populate the point and element data of the flexcomp. The parser will generate an error if the GMSH file contains meshes that are not supported by MuJoCo. dim is automatically set to the dimensionality specified in the GMSH file. Presently this is the only mechanism to load a large tetrahedral mesh in MuJoCo and generate a corresponding soft entity. If such a mesh is available in a different file format, use the freely available GMSH software to convert it to GMSH in one of the supported versions.</p> <p><code>direct</code> allows the user to specify the point and element data of the flexcomp directly in the XML. Note that flexcomp will still generate moving bodies automatically, as well as automate other settings; so it still provides convenience compared to specifing the corresponding flex directly.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>count: tuple[int, int, int] | None = None\n</code></pre> <p>The number of automatically generated points in each dimension. This and the next attribute only apply to types grid, box, cylinder, ellipsoid.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.spacing","title":"spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spacing: Vec3 | None = None\n</code></pre> <p>The spacing between the automatically generated points in each dimension. The spacing should be sufficiently large compared to the radius, to avoid permanent contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.point","title":"point  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>point: VecN | None = None\n</code></pre> <p>The 3D coordinates of the points. This attribute is only used with type direct. All other flexcomp types generate their own points. The points are used to construct bodies and vertices as explained earlier.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.element","title":"element  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>element: tuple[int, ...] | None = None\n</code></pre> <p>The zero-based point ids forming each flex elements. This attribute is only used with type direct. All other flexcomp types generate their own elements. This data is passed through to the automatically-generated flex.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: VecN | None = None\n</code></pre> <p>Texture coordinates of each point, passed through to the automatically-generated flex. Note that flexcomp does not generate texture coordinates automatically, except for 2D grids, box, cylinder and ellipsoid. For all other types, the user can specify explicit texture coordinates here, even if the points themselves were generated automatically. This requires understanding of the layout of the automatically-generated points and how they correspond to the texture referenced by the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>The mass of each automatically-generated body equals this value divided by the number of points. Note that pinning some points does not affect the mass of the other bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.inertiabox","title":"inertiabox  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiabox: float | None = None\n</code></pre> <p>Even though the automatically-generated bodies have the physics of point masses, with slider joints, MuJoCo still requires each body to have rotational inertia. The inertias generated here are diagonal, and are computed such that the corresponding equivalent-inertia boxes have sides equal to this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The name of the file from which a surface (triangular) or volumetric (tetrahedral) mesh is loaded. For surface meshes, the file extension is used to determine the file format. Supported formats are GMSH and the formats specified in mesh assets, excluding the legacy .msh format. Volumetric meshes are supported only in GMSH format. See here for more information on GMSH files.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.rigid","title":"rigid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rigid: bool | None = None\n</code></pre> <p>If this is true, all points correspond to vertices within the parent body, and no new bodies are created. This is equivalent to pinning all points. Note that if all points are indeed pinned, the model compiler will detect that the flex is rigid (which behaves is a non-convex mesh in collision detection).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3 | None = None\n</code></pre> <p>This 3D vector translates all points relative to the frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>If using a quaternion, rotation of all points around the pos vector specified above. Together these two vectors define a pose transformation, used to position and orient the points as needed.</p> <p>Other orientations are options in place of quat.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 | None = None\n</code></pre> <p>Scaling of all point coordinates, for types that specify coordinates explicitly. Scaling is applied after the pose transformation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.radius","title":"radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>radius: float | None = None\n</code></pre> <p>Radius of all flex elements. It can be zero in 3D, but must be positive in 1D and 2D. The radius affects both collision detection and rendering. In 1D and 2D it is needed to make the elements volumetric.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the flex. Note that textures specified in the material will be applied only if the flex has explicit texture coordinates.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 | None = None\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int | None = None\n</code></pre> <p>Integer group to which the flex belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of flexes.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.flatskin","title":"flatskin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flatskin: bool | None = None\n</code></pre> <p>This attribute determines whether 2D and 3D flexes that are rendered in flexskin mode will use smooth or flat shading. The default smooth shading is suitable in most cases, however if the object is intended to have visible sharp edges (such as a cube) then flat shading is more natural.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.origin","title":"origin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>origin: Vec3 | None = None\n</code></pre> <p>The origin of the flexcomp. Used for generating a volumetric mesh from an OBJ surface mesh. Each surface triangle is connected to the origin to create a tetrahedron, so the resulting volumetric mesh is guaranteed to be well-formed only for convex shapes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FlexComp.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Align = AUTO\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox","title":"GeomBox","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a box geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule","title":"GeomCapsule","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a capsule geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder","title":"GeomCylinder","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a cylinder geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid","title":"GeomEllipsoid","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a ellipsoid geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField","title":"GeomHField","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a height field geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[HFIELD] = HFIELD\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>hfield</code> type defines a height field geom. The geom must reference the desired height field asset with the hfield attribute below. The position and orientation of the geom set the position and orientation of the height field. The size of the geom is ignored, and the size parameters of the height field asset are used instead. See the description of the hfield element. Similar to planes, height field geoms can only be attached to the world body or to static children of the world.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.hfield","title":"hfield  <code>instance-attribute</code>","text":"Python<pre><code>hfield: HFieldName\n</code></pre> <p>This attribute must be specified if and only if the geom type is \"hfield\". It references the height field asset to be instantiated at the position and orientation of the geom frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomHField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh","title":"GeomMesh","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a mesh geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[MESH] = MESH\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>mesh</code> type defines a mesh. The geom must reference the desired mesh asset with the mesh attribute. Note that mesh assets can also be referenced from other geom types, causing primitive shapes to be fitted; see below. The size is determined by the mesh asset and the geom size parameters are ignored. Unlike all other geoms, the position and orientation of mesh geoms after compilation do not equal the settings of the corresponding attributes here. Instead they are offset by the translation and rotation that were needed to center and align the mesh asset in its own coordinate frame. Recall the discussion of centering and alignment in the mesh element.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.mesh","title":"mesh  <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomMesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane","title":"GeomPlane","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a plane geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[PLANE] = PLANE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>plane</code> type defines a plane which is infinite for collision detection purposes. It can only be attached to the world body or static children of the world. The plane passes through a point specified via the pos attribute. It is normal to the Z axis of the geom's local frame. The +Z direction corresponds to empty space. Thus the position and orientation defaults of (0,0,0) and (1,0,0,0) would create a ground plane at Z=0 elevation, with +Z being the vertical direction in the world (which is MuJoCo's convention). Since the plane is infinite, it could have been defined using any other point in the plane. The specified position however has additional meaning with regard to rendering. If either of the first two size parameters are positive, the plane is rendered as a rectangle of finite size (in the positive dimensions). This rectangle is centered at the specified position. Three size parameters are required. The first two specify the half- size of the rectangle along the X and Y axes. The third size parameter is unusual: it specifies the spacing between the grid subdivisions of the plane for rendering purposes. The subdivisions are revealed in wireframe rendering mode, but in general they should not be used to paint a grid over the ground plane (textures should be used for that purpose). Instead their role is to improve lighting and shadows, similar to the subdivisions used to render boxes. When planes are viewed from the back, the are automatically made semi-transparent. Planes and the +Z faces of boxes are the only surfaces that can show reflections, if the material applied to the geom has positive reflection. To render an infinite plane, set the first two size parameters to zero.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; spacing between square grid lines for rendering. If either the X or Y half-size is 0, the plane is rendered as infinite in the dimension(s) with 0 size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomPlane.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF","title":"GeomSDF","text":"<p>               Bases: <code>GeomBase</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SDF] = SDF\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>sdf</code> type defines a signed distance field (SDF, also referred to as signed distance function). In order to visualize the SDF, a custom mesh must be specified using the mesh/plugin attribute. See the model/plugin/sdf/ directory for example models with SDF geometries. For more details regarding SDF plugins, see the Extensions chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSDF.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere","title":"GeomSphere","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a sphere geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.GeomSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Vec3 | None = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Vec6 | None = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = HINGE\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = array((0, 0, 1))\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Vec2 = array((0, 0))\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = 0\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = array((0, 0))\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = AUTO\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Vec2 = array((0, 0))\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: ActuatorFrcLimited = AUTO\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: bool = False\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: float = 0\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: float = 0\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = 0\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = 0\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = 0\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light","title":"Light","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a light, which moves with the body where it is defined. To create a fixed light, define it in the world body. The lights created here are in addition to the headlight which is always defined and is configured via the visual element. Lights shine along the direction specified by the dir attribute. They do not have a full spatial frame with three orthogonal axes.</p> <p>By default, MuJoCo uses the standard OpenGL (fixed functional) Phong lighting model for its rendering, with augmented with shadow mapping. (See the OpenGL documentation for more information, including details about various attributes.)</p> <p>MJCF also supports alternative lighting models (e.g. physically-based rendering) by providing additional attributes. Attributes may be applied or ignored depending on the lighting model being used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: LightName | None = None\n</code></pre> <p>Name of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This is identical to the mode attribute of camera. It specifies the how the light position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the light illuminates).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>This is identical to the target attribute of camera above. It specifies which body should be targeted in \"targetbody\" and \"targetbodycom\" modes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: LightType = SPOT\n</code></pre> <p>Determines the type of light. Note that some light types may not be supported by some renderers (e.g. only spot and directional lights are supported by the default native renderer).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.directional","title":"directional  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>directional: bool = False\n</code></pre> <p>This is a deprecated legacy attribute. Please use light type instead. If set to \"true\", and no type is specified, this will change the light type to be directional.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.castshadow","title":"castshadow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>castshadow: bool = True\n</code></pre> <p>If this attribute is \"true\" the light will cast shadows. More precisely, the geoms illuminated by the light will cast shadows, however this is a property of lights rather than geoms. Since each shadow-casting light causes one extra rendering pass through all geoms, this attribute should be used with caution. Higher quality of the shadows is achieved by increasing the value of the shadowsize attribute of quality, as well as positioning spotlights closer to the surface on which shadows appear, and limiting the volume in which shadows are cast. For spotlights this volume is a cone, whose angle is the cutoff attribute below multiplied by the shadowscale attribute of map. For directional lights this volume is a box, whose half-sizes in the directions orthogonal to the light are the model extent multiplied by the shadowclip attribute of map. The model extent is computed by the compiler but can also be overridden by specifying the extent attribute of statistic. Internally the shadow-mapping mechanism renders the scene from the light viewpoint (as if it were a camera) into a depth texture, and then renders again from the camera viewpoint, using the depth texture to create shadows. The internal rendering pass uses the same near and far clipping planes as regular rendering, i.e., these clipping planes bound the cone or box shadow volume in the light direction. As a result, some shadows (especially those very close to the light) may be clipped.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.active","title":"active  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>active: bool = True\n</code></pre> <p>The light is active if this attribute is \"true\". This can be used at runtime to turn lights on and off.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the light. This attribute only affects the rendering for spotlights, but it should also be defined for directional lights because we render the cameras as decorative elements.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dir: Vec3 = array((0, 0, -1))\n</code></pre> <p>Direction of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.diffuse","title":"diffuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diffuse: Vec3 = array((0.7, 0.7, 0.7))\n</code></pre> <p>The color of the light. For the Phong (default) lighting model, this defines the diffuse color of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>The texture to use for image-based lighting. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.intensity","title":"intensity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>intensity: float = 0\n</code></pre> <p>The intensity of the light source, measured in candela, used for physically-based lighting models. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.ambient","title":"ambient  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ambient: Vec3 = array((0, 0, 0))\n</code></pre> <p>The ambient color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Vec3 = array((0.3, 0.3, 0.3))\n</code></pre> <p>The specular color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: float = 10\n</code></pre> <p>The effective range of the light. Objects further than this distance from the light position will not be illuminated by this light. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.bulbradius","title":"bulbradius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bulbradius: float = 0.02\n</code></pre> <p>The radius of the light source which can affect shadow softness depending on the renderer. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.attenuation","title":"attenuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attenuation: Vec3 = array((1, 0, 0))\n</code></pre> <p>These are the constant, linear and quadratic attenuation coefficients for Phong lighting. The default corresponds to no attenuation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.cutoff","title":"cutoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cutoff: float = 45\n</code></pre> <p>Cutoff angle for spotlights, always in degrees regardless of the global angle setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.exponent","title":"exponent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>exponent: float = 10\n</code></pre> <p>Exponent for spotlights. This setting controls the softness of the spotlight cutoff.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Light.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox","title":"SiteBox","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a box site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule","title":"SiteCapsule","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a capsule site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder","title":"SiteCylinder","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a cylinder site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid","title":"SiteEllipsoid","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a ellipsoid site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere","title":"SiteSphere","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a sphere site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.SiteSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/","title":"attach","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach","title":"attach","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach","title":"Attach","text":"<p>               Bases: <code>XMLModel</code></p> <p>The attach element is used to insert a sub-tree of bodies from another model into this model's kinematic tree. Unlike include, which is implemented in the parser and is equivalent to copying and pasting XML from one file into another, attach is implemented in the model compiler. In order to use this element, the sub-model must first be defined as an asset. When creating an attachment, the top body of the attached subtree is specified, and all referencing elements outside the kinematic tree (e.g., sensors and actuators), are also copied into the top-level model. Additionally, any elements referenced from within the attached subtree (e.g. defaults and assets) will be copied in to the top-level model. attach is a Meta elements, so upon saving all attachments will appear in the saved XML file. Note that this element is a subset of the functionality of the procedural attachment functionality. As such, it shares the same limitations as described there. In addition, when the attach element is used, it is not possible to attach an entire model (i.e. including all elements, referenced or not).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach.model","title":"model  <code>instance-attribute</code>","text":"Python<pre><code>model: ModelName\n</code></pre> <p>The sub-model from which to attach a subtree.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach.body","title":"body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>body: BodyName | None = None\n</code></pre> <p>Name of the body in the sub-model to attach here. The body and its subtree will be attached. If this attribute is not specified, the contents of the world body will be attached in a new frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach.prefix","title":"prefix  <code>instance-attribute</code>","text":"Python<pre><code>prefix: str\n</code></pre> <p>Prefix to prepend to names of elements in the sub-model. This attribute is required to prevent name collisions with the parent or when attaching the same sub-tree multiple times.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/#mujoco_mojo.mjcf.mujoco_attr.body_attr.attach.Attach.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/","title":"camera","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera","title":"camera","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera","title":"Camera","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a camera, which moves with the body where it is defined. To create a fixed camera, define it in the world body. The cameras created here are in addition to the default free camera which is always defined and is adjusted via the visual element. Internally MuJoCo uses a flexible camera model, where the viewpoint and projection surface are adjusted independently so as to obtain oblique projections needed for virtual environments. This functionality however is not accessible through MJCF. Instead, the cameras created with this element (as well as the free camera) have a viewpoint that is always centered in front of the projection surface. The viewpoint coincides with the center of the camera frame. The camera is looking along the -Z axis of its frame. The +X axis points to the right, and the +Y axis points up. Thus the frame position and orientation are the key adjustments that need to be made here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: CameraName | None = None\n</code></pre> <p>Name of the camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This attribute specifies how the camera position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the camera sees).</p> <ul> <li><code>fixed</code> means that the position and orientation specified below are fixed relative to the body where the camera is defined.</li> <li><code>track</code> means that the camera position is at a constant offset from the body in world coordinates, while the camera orientation is constant in world coordinates. These constants are determined by applying forward kinematics in qpos0 and treating the camera as fixed. Tracking can be used for example to position a camera above a body, point it down so it sees the body, and have it always remain above the body no matter how the body translates and rotates.</li> <li><code>trackcom</code> is similar to \"track\" but the constant spatial offset is defined relative to the center of mass of the kinematic subtree starting at the body in which the camera is defined. This can be used to keep an entire mechanism in view. Note that the subtree center of mass for the world body is the center of mass of the entire model. So if a camera is defined in the world body in mode \"trackcom\", it will track the entire model.</li> <li><code>targetbody</code> means that the camera position is fixed in the body frame, while the camera orientation is adjusted so that it always points towards the targeted body (which is specified with the target attribute below). This can be used for example to model an eye that fixates a moving object; the object will be the target, and the camera/eye will be defined in the body corresponding to the head.</li> <li><code>targetbodycom</code> is the same as \"targetbody\" but the camera is oriented towards the center of mass of the subtree starting at the target body.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>When the camera mode is \"targetbody\" or \"targetbodycom\", this attribute becomes required. It specifies which body should be targeted by the camera. In all other modes this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.orthographic","title":"orthographic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orthographic: bool = False\n</code></pre> <p>Whether the camera uses a perspective projection (the default) or an orthographic projection. Setting this attribute changes the semantic of the fovy attribute, see below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.fovy","title":"fovy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fovy: float = 45\n</code></pre> <p>Vertical field-of-view of the camera. If the camera uses a perspective projection, the field-of-view is expressed in degrees, regardless of the global compiler/angle setting. If the camera uses an orthographic projection, the field-of-view is expressed in units of length; note that in this case the default of 45 is too large for most scenes and should likely be reduced. In either case, the horizontal field of view is computed automatically given the window size and the vertical field of view.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>resolution: tuple[int, int] = (1, 1)\n</code></pre> <p>Resolution of the camera in pixels [width height]. Note that these values are not used for rendering since those dimensions are determined by the size of the rendering context. This attribute serves as a convenient location to save the required resolution when creating a context.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.focal","title":"focal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focal: Vec2 = array((0, 0))\n</code></pre> <p>Focal length of the camera in length units. It is mutually exclusive with fovy. See Cameras for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.focalpixel","title":"focalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>focalpixel: tuple[int, int] = (1, 1)\n</code></pre> <p>Focal length of the camera in pixel units. If both focal and focalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.principal","title":"principal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principal: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in length units. It is mutually exclusive with fovy.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.principalpixel","title":"principalpixel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>principalpixel: Vec2 = array((0, 0))\n</code></pre> <p>Offset of the principal point of the camera with respect to the camera center in pixel units. If both principal and principalpixel are specified, the former is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.sensorsize","title":"sensorsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensorsize: Vec2 = array((0, 0))\n</code></pre> <p>Size of the camera sensor in length units. It is mutually exclusive with fovy. If specified, resolution and focal are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.ipd","title":"ipd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ipd: float = 0.068\n</code></pre> <p>Inter-pupilary distance. This attribute only has an effect during stereoscopic rendering. It specifies the distance between the left and right viewpoints. Each viewpoint is shifted by +/- half of the distance specified here, along the X axis of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the camera frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the camera frame. See Frame orientations. Note that specifically for cameras, the xyaxes attribute is semantically convenient as the X and Y axes correspond to the directions \"right\" and \"up\" in pixel space, respectively.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/#mujoco_mojo.mjcf.mujoco_attr.body_attr.camera.Camera.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/","title":"composite","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite","title":"composite","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite","title":"Composite","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>prefix: str | None = None\n</code></pre> <p>All automatically generated model elements have names indicating the element type and index. For example, the body at coordinates (2, 0) in a 2D grid is named \"B2_0\" by default. If prefix=\"C\" is specified, the same body is named \"CB2_0\". The prefix is needed when multiple composite objects are used in the same model, to avoid name conflicts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: CompositeType = CABLE\n</code></pre> <p>This attribute determines the type of composite object. The only supported type is cable.</p> <p>The <code>cable</code> type creates a 1D chain of bodies connected with ball joints, each having a geom with user-defined type (cylinder, capsule or box). The geometry can either be defined with an array of 3D vertex coordinates vertex or with prescribed functions with the option curve. Currently, only linear and trigonometric functions are supported. For example, an helix can be obtained with curve=\"cos(s) sin(s) s\". The size is set with the option size, resulting in f(s)={size[1]\u22c5cos(2\u03c0\u22c5size[2]), size[1]\u22c5sin(2\u03c0\u22c5size[2]),  size[0]\u22c5s}.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.count","title":"count  <code>instance-attribute</code>","text":"Python<pre><code>count: Tuple[int] | Tuple[int, int] | Tuple[int, int, int]\n</code></pre> <p>The element count in each dimension of the grid. This can have 1, 2 or 3 numbers, specifying the element count along the X, Y and Z axis of the parent body frame within. Any missing numbers default to 1. If any of these numbers is 1, all subsequent numbers must also be 1, so that the leading dimensions of the grid are used. This means for example that a 1D grid will always extend along the X axis. To achieve a different orientation, rotate the frame of the parent body. Note that some types imply a grid of certain dimensionality, so the requirements for this attribute depend on the specified type.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>offset: Vec3 = array((0, 0, 0))\n</code></pre> <p>It specifies a 3D offset from the center of the parent body to the center of the first body of the cable. The offset is expressed in the local coordinate frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Quat = Quat(quat=array((1, 0, 0, 0)))\n</code></pre> <p>It specifies a quaternion that rotates the first body frame. The quaternion is expressed in the parent body frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: VecN | None = None\n</code></pre> <p>Vertex 3D positions in global coordinates.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.initial","title":"initial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>initial: CompositeInitial = NONE\n</code></pre> <p>Behavior of the first point. Free: free joint. Ball: ball joint. None: no dof.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.curve","title":"curve  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>curve: tuple[str, str, str] | None = None\n</code></pre> <p>Functions specifying the vertex positions. Available functions are s, cos(s), and sin(s), where s is the arc length parameter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: tuple[int, int, int] | None = None\n</code></pre> <p>Scaling of the curve functions. size[0] is the scaling of s, size[1] is the radius of cos(s) and sin(s), and size[2] is the speed of the argument (i.e. cos(2pisize[2]*s)).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.joints","title":"joints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>joints: Sequence[CompositeJoint] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Joints assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.geom","title":"geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>geom: CompositeGeom | None = None\n</code></pre> <p>Geometry assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.site","title":"site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>site: CompositeSite | None = None\n</code></pre> <p>Site assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.skin","title":"skin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>skin: Skin | None = None\n</code></pre> <p>Skin assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugins: Sequence[Plugin] = Field(\n    default_factory=list, exclude_if=is_empty_list\n)\n</code></pre> <p>Plugins assigned to composite.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite.Composite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/","title":"flexcomp","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp","title":"flexcomp","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp","title":"FlexComp","text":"<p>               Bases: <code>XMLModel</code></p> <p>Similar to composite, this element (new in MuJoCo 3.0) is not a model element, but rather a macro which expands into multiple model elements representing a deformable entity. In particular this macro creates one flex element, a number of bodies that are children of the body in which the flexcomp is defined, and optionally one flex equality which constrains all flex edges to their initial length. A number of attributes are specified here and then passed through to the automatically-constructed flex. The primary role of flexcomp is to automate the creation of a (possibly large) collection of moving bodies with corresponding joints, and connect them with stretchable flex elements. See flex and deformable objects documentation for specifics on how flexes work. Here we only describe the automated construction process.</p> <p>An important distinction between flex and flexcomp is that the flex references bodies and specifies vertex coordinates in the frames of those bodies, while the flexcomp defines points. Each flexcomp point corresponds to one body and one vertex in the underlying flex. If the flexcomp point is pinned, the corresponding flex body is the parent body of the flexcomp, while the corresponding flex vertex coordinates equal the flexcomp point coordinates. If the flexcomp point is not pinned, a new child body is created at the coordinates of the flexcomp point (within the flexcomp parent body), and then the coordinates of the flex vertex within that new body are (0,0,0). The mechanism for pinning flexcomp points is explained below.</p> <p>Composite objects (available prior to MuJoCo 3.0) needed bodies with geoms for collisions, and sites for connecting tendons which generated shape-preserving forces. In contrast, flexes generate their own collisions and shape-preserving forces (as well as rendering), thus the bodies created here are much simpler: no geoms, sites or tendons are needed. Most of the bodies created here have 3 orthogonal slider joints, corresponding to freely moving point masses. In some cases we generate radial slider joints, allowing only expansion and contraction. Since no geoms are generated, the bodies need to have explicit inertial parameters.</p> <p>Below is a simple example of a flexcomp, modeling a (somewhat flexible) double pendulum with one end pinned to the world:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;flexcomp name=\"FL\" type=\"grid\" dim=\"1\" count=\"3 1 1\" mass=\"3\" spacing=\"0.2 0.2 0.2\"&gt;\n            &lt;pin id=\"0\"/&gt;\n        &lt;/flexcomp&gt;\n    &lt;/worldbody&gt;\n&lt;/mujoco&gt;\n</code></pre> <p>This flexcomp has 3 points, however the first point is pinned to the world (i.e. the parent of the flexcomp) and so only two bodies are automatically created, namely FL_1 and FL_2. Here is what this flexcomp generates after loading and saving the XML:</p> XML<pre><code>&lt;mujoco&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"FL_1\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n        &lt;body name=\"FL_2\" pos=\"0.2 0 0\"&gt;\n            &lt;inertial pos=\"0 0 0\" mass=\"1\" diaginertia=\"1.66667e-05 1.66667e-05 1.66667e-05\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"1 0 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 1 0\" type=\"slide\"/&gt;\n            &lt;joint pos=\"0 0 0\" axis=\"0 0 1\" type=\"slide\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n    &lt;deformable&gt;\n        &lt;flex name=\"FL\" dim=\"1\" body=\"world FL_1 FL_2\" vertex=\"-0.2 0 0 0 0 0 0 0 0\" element=\"0 1 1 2\"/&gt;\n    &lt;/deformable&gt;\n    &lt;equality&gt;\n        &lt;flex flex=\"FL\"/&gt;\n    &lt;/equality&gt;\n&lt;/mujoco&gt;\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>The name of the flex element being generated automatically. This name is used as a prefix for all bodies that are automatically generated here, and is also referenced by the corresponding flex equality constraint (if applicable).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dim: int | None = None\n</code></pre> <p>Dimensionality of the flex object. This value must be 1, 2 or 3. The flex elements are capsules in 1D, triangles with radius in 2D, and tetrahedra with radius in 3D. Certain flexcomp types imply a dimensionality, in which case the value specified here is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.dof","title":"dof  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dof: FlexCompDOF | None = None\n</code></pre> <p>The parametrization of the flex's degrees of freedom (dofs). See the video on the right illustrating the different parametrizations with deformable spheres. The three models in the video are respectively sphere_full, sphere_radial and sphere_trilinear.</p> <ul> <li><code>full</code>: Three translational dofs per vertex. This is the most expressive but also the most expensive option.</li> <li><code>radial</code>: A single radial translational dof per vertex. Note that unlike in the \"full\" case, the radial parametrization requires a free joint at the flex's parent in order for free body motion to be possible. This type of parametrization is appropriate for shapes that are relatively spherical.</li> <li><code>trilinear</code>: Three translational dofs at each corner of the bounding box of the flex, for a total of 24 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using trilinear interpolation over the bounding box.</li> </ul> <p>Trilinear and quadratic flexes are much faster than the previous two options, and are the preferred choice if the expected deformations can be captured by the reduced parametriation. For example, see the video on the right comparing full and trilinear flexes for modeling deformable gripper pads.</p> <p>Note that the choice of dof parametrization affects the deformation modes of the flex but has no effect on the accuracy of the collision geometry, which always takes into account the high-resolution mesh of the flex.</p> <ul> <li><code>quadratic</code>: Three translational dofs per corner, edge, face, and volume of the bounding box of the flex, for a total of 81 dofs for the entire flex, independent of the number of vertices. The positions of the vertices are updated using quadratic interpolation over the bounding box. While this option requires more degrees of freedom than trilinear flexes, it enables curved deformation modes, while the only modes achievable for trilinear flexes are strech/compression and shear.</li> </ul> <p>Note that a higher interpolation order generally requires a smaller time step for stability, although usually not as large as with the \"full\" option and a fine mesh.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: FlexCompType | None = None\n</code></pre> <p>This attribute determines the type of flexcomp object. The remaining attributes and sub-elements are then interpreted according to the type. Default settings are also adjusted depending on the type. Different types correspond to different methods for specifying the flexcomp points and the stretchable elements that connect them. They fall in three categories: direct specification entered in the XML, direct specification loaded from file, and automated generation from higher-level specification.</p> <p><code>grid</code> generates a rectangular grid of points in 1D, 2D or 3D as specified by dim. The number of points in each dimension is determined by count while the grid spacing in each dimension is determined by spacing. Make sure the spacing is sufficiently large relative to radius to avoid permanent contacts. In 2D and 3D the grid is automatically triangulated, and corresponding flex elements are created (triangles or tetrahedra). In 1D the elements are capsules connecting consecutive pairs of points.</p> <p><code>box</code> generates a 3D box object, however flex bodies are only generated on the outer shell. Each flex body has a radial slider joint allowing it to move in and out from the center of the box. The parent body would normally be a floating body. The box surface is triangulated, and each flex element is a tetrahedron connecting the center of the box with one triangle face. count and spacing determine the count and spacing of the flex bodies, similar to the grid type in 3D. Note that the resulting flex has the same topology as the box generated by composite.</p> <p><code>cylinder</code> is the same as box, except the points are projected on the surface of a cylinder.</p> <p><code>ellipsoid</code> is the same as box, except the points are projected on the surface of an ellipsoid.</p> <p><code>disc</code> is the same as box, except the points are projected on the surface of a disc. It is only compatible with dim=2.</p> <p><code>circle</code> is the same as grid, except the points are sampled along a circle so that the first and last points are the same. The radius of the circle is computed such that each segment has the requested spacing. It is only compatible with dim=1.</p> <p><code>mesh</code> loads the flexcomp points and elements (i.e. triangles) from a mesh file, in the same file formats as mesh assets, excluding the legacy .msh format. A mesh asset is not actually added to the model. Instead the vertex and face data from the mesh file are used to populate the point and element data of the flexcomp. dim is automatically set to 2. Recall that a mesh asset in MuJoCo can be used as a rigid geom attached to a single body. In contrast, the flex generated here corresponds to a soft mesh with the same initial shape, where each vertex is a separate moving body (unless pinned).</p> <p><code>gmsh</code> is similar to mesh, but it loads a GMSH file in format 4.1 and format 2.2 (ascii or binary). The file extension can be anything; the parser recognizes the format by examining the file header. This is a very rich file format, allowing all kinds of elements with different dimensionality and topology. MuJoCo only supports GMSH element types 1, 2, 4 which happen to correspond to our 1D, 2D and 3D flexes and assumes that the nodes are specified in a single block. Only the Nodes and Elements sections of the GMHS file are processed, and used to populate the point and element data of the flexcomp. The parser will generate an error if the GMSH file contains meshes that are not supported by MuJoCo. dim is automatically set to the dimensionality specified in the GMSH file. Presently this is the only mechanism to load a large tetrahedral mesh in MuJoCo and generate a corresponding soft entity. If such a mesh is available in a different file format, use the freely available GMSH software to convert it to GMSH in one of the supported versions.</p> <p><code>direct</code> allows the user to specify the point and element data of the flexcomp directly in the XML. Note that flexcomp will still generate moving bodies automatically, as well as automate other settings; so it still provides convenience compared to specifing the corresponding flex directly.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>count: tuple[int, int, int] | None = None\n</code></pre> <p>The number of automatically generated points in each dimension. This and the next attribute only apply to types grid, box, cylinder, ellipsoid.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.spacing","title":"spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spacing: Vec3 | None = None\n</code></pre> <p>The spacing between the automatically generated points in each dimension. The spacing should be sufficiently large compared to the radius, to avoid permanent contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.point","title":"point  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>point: VecN | None = None\n</code></pre> <p>The 3D coordinates of the points. This attribute is only used with type direct. All other flexcomp types generate their own points. The points are used to construct bodies and vertices as explained earlier.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.element","title":"element  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>element: tuple[int, ...] | None = None\n</code></pre> <p>The zero-based point ids forming each flex elements. This attribute is only used with type direct. All other flexcomp types generate their own elements. This data is passed through to the automatically-generated flex.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: VecN | None = None\n</code></pre> <p>Texture coordinates of each point, passed through to the automatically-generated flex. Note that flexcomp does not generate texture coordinates automatically, except for 2D grids, box, cylinder and ellipsoid. For all other types, the user can specify explicit texture coordinates here, even if the points themselves were generated automatically. This requires understanding of the layout of the automatically-generated points and how they correspond to the texture referenced by the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>The mass of each automatically-generated body equals this value divided by the number of points. Note that pinning some points does not affect the mass of the other bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.inertiabox","title":"inertiabox  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiabox: float | None = None\n</code></pre> <p>Even though the automatically-generated bodies have the physics of point masses, with slider joints, MuJoCo still requires each body to have rotational inertia. The inertias generated here are diagonal, and are computed such that the corresponding equivalent-inertia boxes have sides equal to this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Path | None = None\n</code></pre> <p>The name of the file from which a surface (triangular) or volumetric (tetrahedral) mesh is loaded. For surface meshes, the file extension is used to determine the file format. Supported formats are GMSH and the formats specified in mesh assets, excluding the legacy .msh format. Volumetric meshes are supported only in GMSH format. See here for more information on GMSH files.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.rigid","title":"rigid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rigid: bool | None = None\n</code></pre> <p>If this is true, all points correspond to vertices within the parent body, and no new bodies are created. This is equivalent to pinning all points. Note that if all points are indeed pinned, the model compiler will detect that the flex is rigid (which behaves is a non-convex mesh in collision detection).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3 | None = None\n</code></pre> <p>This 3D vector translates all points relative to the frame of the parent body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>If using a quaternion, rotation of all points around the pos vector specified above. Together these two vectors define a pose transformation, used to position and orient the points as needed.</p> <p>Other orientations are options in place of quat.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Vec3 | None = None\n</code></pre> <p>Scaling of all point coordinates, for types that specify coordinates explicitly. Scaling is applied after the pose transformation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.radius","title":"radius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>radius: float | None = None\n</code></pre> <p>Radius of all flex elements. It can be zero in 3D, but must be positive in 1D and 2D. The radius affects both collision detection and rendering. In 1D and 2D it is needed to make the elements volumetric.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the flex. Note that textures specified in the material will be applied only if the flex has explicit texture coordinates.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 | None = None\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int | None = None\n</code></pre> <p>Integer group to which the flex belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of flexes.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.flatskin","title":"flatskin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>flatskin: bool | None = None\n</code></pre> <p>This attribute determines whether 2D and 3D flexes that are rendered in flexskin mode will use smooth or flat shading. The default smooth shading is suitable in most cases, however if the object is intended to have visible sharp edges (such as a cube) then flat shading is more natural.</p> <p>Directly passed through to the automatically-generated flex object and have the same meaning.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.origin","title":"origin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>origin: Vec3 | None = None\n</code></pre> <p>The origin of the flexcomp. Used for generating a volumetric mesh from an OBJ surface mesh. Each surface triangle is connected to the origin to create a tetrahedron, so the resulting volumetric mesh is guaranteed to be well-formed only for convex shapes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp.FlexComp.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/frame/","title":"frame","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/frame/#mujoco_mojo.mjcf.mujoco_attr.body_attr.frame","title":"frame","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/","title":"free_joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint","title":"free_joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Align = AUTO\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/","title":"geom","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom","title":"geom","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase","title":"GeomBase","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a geom, and attaches it rigidly to the body within which the geom is defined. Multiple geoms can be attached to the same body. At runtime they determine the appearance and collision properties of the body. At compile time they can also determine the inertial properties of the body, depending on the presence of the inertial element and the setting of the inertiafromgeom attribute of compiler. This is done by summing the masses and inertias of all geoms attached to the body with geom group in the range specified by the inertiagrouprange attribute of compiler. The geom masses and inertias are computed using the geom shape, a specified density or a geom mass which implies a density, and the assumption of uniform density.</p> <p>Geoms are not strictly required for physics simulation. One can create and simulate a model that only has bodies and joints. Such a model can even be visualized, using equivalent inertia boxes to represent bodies. Only contact forces would be missing from such a simulation. We do not recommend using such models, but knowing that this is possible helps clarify the role of bodies and geoms in MuJoCo.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBase.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane","title":"GeomPlane","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a plane geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[PLANE] = PLANE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>plane</code> type defines a plane which is infinite for collision detection purposes. It can only be attached to the world body or static children of the world. The plane passes through a point specified via the pos attribute. It is normal to the Z axis of the geom's local frame. The +Z direction corresponds to empty space. Thus the position and orientation defaults of (0,0,0) and (1,0,0,0) would create a ground plane at Z=0 elevation, with +Z being the vertical direction in the world (which is MuJoCo's convention). Since the plane is infinite, it could have been defined using any other point in the plane. The specified position however has additional meaning with regard to rendering. If either of the first two size parameters are positive, the plane is rendered as a rectangle of finite size (in the positive dimensions). This rectangle is centered at the specified position. Three size parameters are required. The first two specify the half- size of the rectangle along the X and Y axes. The third size parameter is unusual: it specifies the spacing between the grid subdivisions of the plane for rendering purposes. The subdivisions are revealed in wireframe rendering mode, but in general they should not be used to paint a grid over the ground plane (textures should be used for that purpose). Instead their role is to improve lighting and shadows, similar to the subdivisions used to render boxes. When planes are viewed from the back, the are automatically made semi-transparent. Planes and the +Z faces of boxes are the only surfaces that can show reflections, if the material applied to the geom has positive reflection. To render an infinite plane, set the first two size parameters to zero.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; spacing between square grid lines for rendering. If either the X or Y half-size is 0, the plane is rendered as infinite in the dimension(s) with 0 size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomPlane.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField","title":"GeomHField","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a height field geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[HFIELD] = HFIELD\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>hfield</code> type defines a height field geom. The geom must reference the desired height field asset with the hfield attribute below. The position and orientation of the geom set the position and orientation of the height field. The size of the geom is ignored, and the size parameters of the height field asset are used instead. See the description of the hfield element. Similar to planes, height field geoms can only be attached to the world body or to static children of the world.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.hfield","title":"hfield  <code>instance-attribute</code>","text":"Python<pre><code>hfield: HFieldName\n</code></pre> <p>This attribute must be specified if and only if the geom type is \"hfield\". It references the height field asset to be instantiated at the position and orientation of the geom frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomHField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere","title":"GeomSphere","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a sphere geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule","title":"GeomCapsule","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a capsule geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid","title":"GeomEllipsoid","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a ellipsoid geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder","title":"GeomCylinder","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a cylinder geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox","title":"GeomBox","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a box geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh","title":"GeomMesh","text":"<p>               Bases: <code>GeomBase</code></p> <p>This element creates a mesh geometry.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[MESH] = MESH\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>mesh</code> type defines a mesh. The geom must reference the desired mesh asset with the mesh attribute. Note that mesh assets can also be referenced from other geom types, causing primitive shapes to be fitted; see below. The size is determined by the mesh asset and the geom size parameters are ignored. Unlike all other geoms, the position and orientation of mesh geoms after compilation do not equal the settings of the corresponding attributes here. Instead they are offset by the translation and rotation that were needed to center and align the mesh asset in its own coordinate frame. Recall the discussion of centering and alignment in the mesh element.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.mesh","title":"mesh  <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomMesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF","title":"GeomSDF","text":"<p>               Bases: <code>GeomBase</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SDF] = SDF\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>sdf</code> type defines a signed distance field (SDF, also referred to as signed distance function). In order to visualize the SDF, a custom mesh must be specified using the mesh/plugin attribute. See the model/plugin/sdf/ directory for example models with SDF geometries. For more details regarding SDF plugins, see the Extensions chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.geom.GeomSDF.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/","title":"inertial","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial","title":"inertial","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation | None = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Vec3 | None = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Vec6 | None = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/","title":"joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint","title":"joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: JointName | None = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = HINGE\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = array((0, 0, 1))\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Vec2 = array((0, 0))\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = 0\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = array((0, 0))\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = AUTO\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Vec2 = array((0, 0))\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: ActuatorFrcLimited = AUTO\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.</p> <p>This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: bool = False\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: float = 0\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: float = 0\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = 0\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = 0\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = 0\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/","title":"light","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light","title":"light","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light","title":"Light","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a light, which moves with the body where it is defined. To create a fixed light, define it in the world body. The lights created here are in addition to the headlight which is always defined and is configured via the visual element. Lights shine along the direction specified by the dir attribute. They do not have a full spatial frame with three orthogonal axes.</p> <p>By default, MuJoCo uses the standard OpenGL (fixed functional) Phong lighting model for its rendering, with augmented with shadow mapping. (See the OpenGL documentation for more information, including details about various attributes.)</p> <p>MJCF also supports alternative lighting models (e.g. physically-based rendering) by providing additional attributes. Attributes may be applied or ignored depending on the lighting model being used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: LightName | None = None\n</code></pre> <p>Name of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: TrackingMode = FIXED\n</code></pre> <p>This is identical to the mode attribute of camera. It specifies the how the light position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the light illuminates).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>target: BodyName | None = None\n</code></pre> <p>This is identical to the target attribute of camera above. It specifies which body should be targeted in \"targetbody\" and \"targetbodycom\" modes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: LightType = SPOT\n</code></pre> <p>Determines the type of light. Note that some light types may not be supported by some renderers (e.g. only spot and directional lights are supported by the default native renderer).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.directional","title":"directional  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>directional: bool = False\n</code></pre> <p>This is a deprecated legacy attribute. Please use light type instead. If set to \"true\", and no type is specified, this will change the light type to be directional.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.castshadow","title":"castshadow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>castshadow: bool = True\n</code></pre> <p>If this attribute is \"true\" the light will cast shadows. More precisely, the geoms illuminated by the light will cast shadows, however this is a property of lights rather than geoms. Since each shadow-casting light causes one extra rendering pass through all geoms, this attribute should be used with caution. Higher quality of the shadows is achieved by increasing the value of the shadowsize attribute of quality, as well as positioning spotlights closer to the surface on which shadows appear, and limiting the volume in which shadows are cast. For spotlights this volume is a cone, whose angle is the cutoff attribute below multiplied by the shadowscale attribute of map. For directional lights this volume is a box, whose half-sizes in the directions orthogonal to the light are the model extent multiplied by the shadowclip attribute of map. The model extent is computed by the compiler but can also be overridden by specifying the extent attribute of statistic. Internally the shadow-mapping mechanism renders the scene from the light viewpoint (as if it were a camera) into a depth texture, and then renders again from the camera viewpoint, using the depth texture to create shadows. The internal rendering pass uses the same near and far clipping planes as regular rendering, i.e., these clipping planes bound the cone or box shadow volume in the light direction. As a result, some shadows (especially those very close to the light) may be clipped.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.active","title":"active  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>active: bool = True\n</code></pre> <p>The light is active if this attribute is \"true\". This can be used at runtime to turn lights on and off.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the light. This attribute only affects the rendering for spotlights, but it should also be defined for directional lights because we render the cameras as decorative elements.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.dir","title":"dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>dir: Vec3 = array((0, 0, -1))\n</code></pre> <p>Direction of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.diffuse","title":"diffuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diffuse: Vec3 = array((0.7, 0.7, 0.7))\n</code></pre> <p>The color of the light. For the Phong (default) lighting model, this defines the diffuse color of the light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: TextureName | None = None\n</code></pre> <p>The texture to use for image-based lighting. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.intensity","title":"intensity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>intensity: float = 0\n</code></pre> <p>The intensity of the light source, measured in candela, used for physically-based lighting models. This is unused by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.ambient","title":"ambient  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ambient: Vec3 = array((0, 0, 0))\n</code></pre> <p>The ambient color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Vec3 = array((0.3, 0.3, 0.3))\n</code></pre> <p>The specular color of the light, used by the default Phong lighting model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: float = 10\n</code></pre> <p>The effective range of the light. Objects further than this distance from the light position will not be illuminated by this light. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.bulbradius","title":"bulbradius  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>bulbradius: float = 0.02\n</code></pre> <p>The radius of the light source which can affect shadow softness depending on the renderer. This only applies to spotlights.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.attenuation","title":"attenuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>attenuation: Vec3 = array((1, 0, 0))\n</code></pre> <p>These are the constant, linear and quadratic attenuation coefficients for Phong lighting. The default corresponds to no attenuation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.cutoff","title":"cutoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cutoff: float = 45\n</code></pre> <p>Cutoff angle for spotlights, always in degrees regardless of the global angle setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.exponent","title":"exponent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>exponent: float = 10\n</code></pre> <p>Exponent for spotlights. This setting controls the softness of the spotlight cutoff.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/#mujoco_mojo.mjcf.mujoco_attr.body_attr.light.Light.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/plugin/","title":"plugin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.plugin","title":"plugin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/","title":"site","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site","title":"site","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase","title":"SiteBase","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a site, which is a simplified and restricted kind of geom. A small subset of the geom attributes are available here; see the geom element for their detailed documentation. Semantically sites represent locations of interest relative to the body frames. Sites do not participate in collisions and computation of body masses and inertias. The geometric shapes that can be used to render sites are limited to a subset of the available geom types. However sites can be used in some places where geoms are not allowed: mounting sensors, specifying via-points of spatial tendons, constructing slider-crank transmissions for actuators.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBase.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere","title":"SiteSphere","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a sphere site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule","title":"SiteCapsule","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a capsule site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid","title":"SiteEllipsoid","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a ellipsoid site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder","title":"SiteCylinder","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a cylinder site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox","title":"SiteBox","text":"<p>               Bases: <code>SiteBase</code></p> <p>This element creates a box site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, cylinder, ellipsoid and box sites. It provides an alternative specification of the site length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the site connects these two points, with the +Z axis of the site's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.site.SiteBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/","title":"composite_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr","title":"composite_attr","text":"<p>Defines child attributes of the Composite class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint","title":"CompositeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>Depending on the composite type, some joints are created automatically (e.g. the universal joints in rope) while other joints are optional (e.g. the stretch and twist joints in rope). This sub-element is used to specify which optional joints should be created, as well as to adjust the attributes of both automatic and optional joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.kind","title":"kind  <code>instance-attribute</code>","text":"Python<pre><code>kind: CompositeJointKind\n</code></pre> <p>The joint kind here is orthogonal to the joint type in the rest of MJCF. The joint kind refers to the function of the joint within the mechanism comprising the composite body, while the joint type (hinge or slide) is implied by the joint kind and composite body type.</p> <p>The main kind corresponds to the main joints forming each composite type. These joints are automatically included in the model even if the joint sub-element is missing. The main joints are 3D sliders for particle and grid; 1D sliders for box, cylinder and rope; universal joints for cloth, rope and loop. Even though the main joints are included automatically, this sub-element is still useful for adjusting their attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.solreffix","title":"solreffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffix: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.solimpfix","title":"solimpfix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfix: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Joint stiffness. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.</p> <p>Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite","title":"CompositeSite","text":"<p>               Bases: <code>SiteBase</code></p> <p>This sub-element adjusts the attributes of the sites in the composite object. Otherwise it is the same as geom above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>Sizes of the geometric shape representing the site. What shape it is I do not know.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.CompositeSite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin","title":"Skin","text":"<p>               Bases: <code>XMLModel</code></p> <p>If this element is included, the model compiler will generate a skinned mesh asset and attach it to the element bodies of the composite object. Skin can be attached to 2D grid, cloth, box, cylinder and ellipsoid. For other composite types it has no effect. Note that the skin created here is equivalent to a skin specified directly in the XML, as opposed to a skin loaded from file. So if the model is saved as XML, it will contain a large section describing the automatically-generated skin.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: bool = False\n</code></pre> <p>If this is true, explicit texture coordinates will be generated, mapping the skin to the unit square in texture space. This is needed when the material specifies a texture. If texcoord is false and the skin has texture, the texture will appear fixed to the world instead of the skin. The reason for having this attribute in the first place is because skins with texture coordinates upload these coordinates to the GPU even if no texture is applied later. So this attribute should be set to false in cases where no texture will be applied via the material attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.inflate","title":"inflate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inflate: float = 0\n</code></pre> <p>The default value of 0 means that the automatically-generated skin passes through the centers of the body elements comprising the composite object. Positive values offset each skin vertex by the specified amount, in the direction normal to the (non-inflated) skin at that vertex. This has two uses. First, in 2D objects, a small positive inflate factor is needed to avoid aliasing artifacts. Second, collisions are done with geoms that create some thickness, even for 2D objects. Inflating the skin with a value equal to the geom size will render the skin as a \"mattress\" that better represents the actual collision geometry. The value of this attribute is copied into the corresponding attribute of the skin asset being created.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.subgrid","title":"subgrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>subgrid: int = 0\n</code></pre> <p>This is only applicable to cloth and 2D grid types, and has no effect for any other composite type. The default value of 0 means that the skin has as many vertices as the number of element bodies. A positive value causes subdivision, with the specified number of (additional) grid lines. In this case the model compiler generates a denser skin using bi-cubic interpolation. This increases the quality of the rendering (especially in the absence of textures) but also slows down the renderer, so use it with caution. Values above 3 are unlikely to be needed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.Skin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/","title":"geom","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom","title":"geom","text":"<p>Defines the geometric types for composites.</p> <p>Note</p> <p>I was pretty lazy when I did this, I just decided to have these type inherit from their respective Geom class. That is not a super clean way to do it because it means that these objects may have attributes that MuJoCo will just ignore. The XML attributes defined here are restricted to the subset that only the composite geometries have.</p> <p>Sorry...</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane","title":"CompositePlane","text":"<p>               Bases: <code>GeomPlane</code></p> <p>Same as GeomPlane with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[PLANE] = PLANE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>plane</code> type defines a plane which is infinite for collision detection purposes. It can only be attached to the world body or static children of the world. The plane passes through a point specified via the pos attribute. It is normal to the Z axis of the geom's local frame. The +Z direction corresponds to empty space. Thus the position and orientation defaults of (0,0,0) and (1,0,0,0) would create a ground plane at Z=0 elevation, with +Z being the vertical direction in the world (which is MuJoCo's convention). Since the plane is infinite, it could have been defined using any other point in the plane. The specified position however has additional meaning with regard to rendering. If either of the first two size parameters are positive, the plane is rendered as a rectangle of finite size (in the positive dimensions). This rectangle is centered at the specified position. Three size parameters are required. The first two specify the half- size of the rectangle along the X and Y axes. The third size parameter is unusual: it specifies the spacing between the grid subdivisions of the plane for rendering purposes. The subdivisions are revealed in wireframe rendering mode, but in general they should not be used to paint a grid over the ground plane (textures should be used for that purpose). Instead their role is to improve lighting and shadows, similar to the subdivisions used to render boxes. When planes are viewed from the back, the are automatically made semi-transparent. Planes and the +Z faces of boxes are the only surfaces that can show reflections, if the material applied to the geom has positive reflection. To render an infinite plane, set the first two size parameters to zero.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; spacing between square grid lines for rendering. If either the X or Y half-size is 0, the plane is rendered as infinite in the dimension(s) with 0 size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositePlane.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField","title":"CompositeHField","text":"<p>               Bases: <code>GeomHField</code></p> <p>Same as GeomHField with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[HFIELD] = HFIELD\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>hfield</code> type defines a height field geom. The geom must reference the desired height field asset with the hfield attribute below. The position and orientation of the geom set the position and orientation of the height field. The size of the geom is ignored, and the size parameters of the height field asset are used instead. See the description of the hfield element. Similar to planes, height field geoms can only be attached to the world body or to static children of the world.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.hfield","title":"hfield  <code>instance-attribute</code>","text":"Python<pre><code>hfield: HFieldName\n</code></pre> <p>This attribute must be specified if and only if the geom type is \"hfield\". It references the height field asset to be instantiated at the position and orientation of the geom frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeHField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere","title":"CompositeSphere","text":"<p>               Bases: <code>GeomSphere</code></p> <p>Same as GeomSphere with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SPHERE] = SPHERE\n</code></pre> <p>Type of geometric shape. The keywords have the following meaning:</p> <p>The <code>sphere</code> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair- wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via quality. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: float | None = None\n</code></pre> <p>Radius of the sphere.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule","title":"CompositeCapsule","text":"<p>               Bases: <code>GeomCapsule</code></p> <p>Same as GeomCapsule with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CAPSULE] = CAPSULE\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>capsule</code> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the fromto attribute below. In that case only one size parameter is required, namely the radius of the capsule.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCapsule.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid","title":"CompositeEllipsoid","text":"<p>               Bases: <code>GeomEllipsoid</code></p> <p>Same as GeomEllipsoid with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[ELLIPSOID] = ELLIPSOID\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>ellipsoid</code> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X radius; Y radius; Z radius.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeEllipsoid.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder","title":"CompositeCylinder","text":"<p>               Bases: <code>GeomCylinder</code></p> <p>Same as GeomCylinder with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[CYLINDER] = CYLINDER\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>cylinder</code> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the fromto attribute below.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec2 | float | None = None\n</code></pre> <p>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeCylinder.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox","title":"CompositeBox","text":"<p>               Bases: <code>GeomBox</code></p> <p>Same as GeomBox with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[BOX] = BOX\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>box</code> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions can generate up to 8 contact points.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>X half-size; Y half-size; Z half-size.</p> <p>Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the type attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.mesh","title":"mesh  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName | None = None\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeBox.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh","title":"CompositeMesh","text":"<p>               Bases: <code>GeomMesh</code></p> <p>Same as GeomMesh with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[MESH] = MESH\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>mesh</code> type defines a mesh. The geom must reference the desired mesh asset with the mesh attribute. Note that mesh assets can also be referenced from other geom types, causing primitive shapes to be fitted; see below. The size is determined by the mesh asset and the geom size parameters are ignored. Unlike all other geoms, the position and orientation of mesh geoms after compilation do not equal the settings of the corresponding attributes here. Instead they are offset by the translation and rotation that were needed to center and align the mesh asset in its own coordinate frame. Recall the discussion of centering and alignment in the mesh element.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.mesh","title":"mesh  <code>instance-attribute</code>","text":"Python<pre><code>mesh: MeshName\n</code></pre> <p>If the geom type is \"mesh\", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of \"sphere\", \"capsule\", \"cylinder\", \"ellipsoid\", \"box\". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute fitaabb of compiler. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the fitscale attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeMesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF","title":"CompositeSDF","text":"<p>               Bases: <code>GeomSDF</code></p> <p>Same as GeomSDF with different attributes.</p> <p>This sub-element adjusts the attributes of the geoms in the composite object. The default attributes are the same as in the rest of MJCF (except that user-defined defaults have no effect here). Note that the geom sub-element can appears only once, unlike joint and tendon sub-elements which can appear multiple times. This is because different kinds of joints and tendons have different sets of attributes, while all geoms in the composite object are identical.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: GeomName | None = None\n</code></pre> <p>Name of the geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.contype","title":"contype  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contype: int = 1\n</code></pre> <p>This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See Collision detection in the Computation chapter. Two geoms can collide if the contype of one geom is compatible with the conaffinity of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.conaffinity","title":"conaffinity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>conaffinity: int = 1\n</code></pre> <p>Bitmask for contact filtering; see contype above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.condim","title":"condim  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>condim: Literal[1, 3, 4, 6] = 3\n</code></pre> <p>The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the condim values of the two participating geoms. See Contact in the Computation chapter. The allowed values and their meaning are:</p> condim Description 1 Frictionless contact. 3 Regular frictional contact, opposing slip in the tangent plane. 4 Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration). 6 Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>priority: int = 0\n</code></pre> <p>The geom priority determines how the properties of two colliding geoms are combined to form the properties of the contact. This interacts with the solmix attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.friction","title":"friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>friction: Vec3 = array((1, 0.005, 0.0001))\n</code></pre> <p>Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are combined depending on the solmix and priority attributes, as explained in Contact parameters. See the general Contact section for descriptions of the semantics of this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.mass","title":"mass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mass: float | None = None\n</code></pre> <p>If this attribute is specified, the density attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inertia are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not saved in mjModel.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: float = 1000\n</code></pre> <p>Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the mass attribute above is unspecified. If shellinertia is \"false\" (the default), density has semantics of mass/volume; if \"true\", it has semantics of mass/area.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.shellinertia","title":"shellinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shellinertia: bool = False\n</code></pre> <p>If true, the geom's inertia is computed assuming that all the mass is concentrated on the surface. In this case density is interpreted as surface rather than volumetric density. This attribute only applies to primitive geoms and is ignored for meshes. Surface inertia for meshes can be specified by setting the asset/mesh/inertia attribute to \"shell\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.solmix","title":"solmix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solmix: float = 1\n</code></pre> <p>This attribute specifies the weight used for averaging of contact parameters, and interacts with the priority attribute. See Contact parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.solref","title":"solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solref: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.solimp","title":"solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimp: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>Constraint solver parameters for contact simulation. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = 0\n</code></pre> <p>Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in Solver parameters. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.gap","title":"gap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gap: float = 0\n</code></pre> <p>This attribute is used to enable the generation of inactive contacts, i.e., contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.fromto","title":"fromto  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fromto: Vec6 | None = None\n</code></pre> <p>This attribute can only be used with capsule, box, cylinder and ellipsoid geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The elongated part of the geom connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point, while in the perpendicular direction, the geom sizes are both equal to the first value of the size attribute. The frame orientation is obtained with the same procedure as the zaxis attribute described in Frame orientations. The frame position is in the middle between the end points. If this attribute is specified, the remaining position and orientation-related attributes are ignored. The image on the right demonstrates use of fromto with the four supported geoms, using identical Z values. The model is here. Note that the fromto semantics of capsule are unique: the two end points specify the segment around which the radius defines the capsule surface.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the geom, specified in the frame of the body where the geom is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the geom frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.fitscale","title":"fitscale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitscale: float = 1\n</code></pre> <p>This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.fluidshape","title":"fluidshape  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidshape: FluidShape = NONE\n</code></pre> <p>\"ellipsoid\" activates the geom-level fluid interaction model based on an ellipsoidal approximation of the geom shape. When active, the model based on body inertia sizes is disabled for the body in which the geom is defined. See section on ellipsoid-based fluid interaction model for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.fluidcoef","title":"fluidcoef  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fluidcoef: Vec5 = array((0.5, 0.25, 1.5, 1.0, 1.0))\n</code></pre> <p>Dimensionless coefficients of fluid interaction model, as follows. See section on ellipsoid-based fluid interaction model for details.</p> Index Description Symbol Default 0 Blunt drag coefficient CD,blunt 0.5 1 Slender drag coefficient CD,slender 0.25 2 Angular drag coefficient CD,angular 1.5 3 Kutta lift coefficient CK 1.0 4 Magnus lift coefficient CM 1.0"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Plugin | None = None\n</code></pre> <p>Associate this geom with an engine plugin. Either plugin or instance are required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Literal[SDF] = SDF\n</code></pre> <p>Type of geometric shape.</p> <p>The <code>sdf</code> type defines a signed distance field (SDF, also referred to as signed distance function). In order to visualize the SDF, a custom mesh must be specified using the mesh/plugin attribute. See the model/plugin/sdf/ directory for example models with SDF geometries. For more details regarding SDF plugins, see the Extensions chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/geom/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.geom.CompositeSDF.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/","title":"joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint","title":"joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint","title":"CompositeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>Depending on the composite type, some joints are created automatically (e.g. the universal joints in rope) while other joints are optional (e.g. the stretch and twist joints in rope). This sub-element is used to specify which optional joints should be created, as well as to adjust the attributes of both automatic and optional joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.kind","title":"kind  <code>instance-attribute</code>","text":"Python<pre><code>kind: CompositeJointKind\n</code></pre> <p>The joint kind here is orthogonal to the joint type in the rest of MJCF. The joint kind refers to the function of the joint within the mechanism comprising the composite body, while the joint type (hinge or slide) is implied by the joint kind and composite body type.</p> <p>The main kind corresponds to the main joints forming each composite type. These joints are automatically included in the model even if the joint sub-element is missing. The main joints are 3D sliders for particle and grid; 1D sliders for box, cylinder and rope; universal joints for cloth, rope and loop. Even though the main joints are included automatically, this sub-element is still useful for adjusting their attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.solreffix","title":"solreffix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffix: Vec2 = SOLREF_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.solimpfix","title":"solimpfix  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfix: Vec5 = SOLIMP_DEFAULT\n</code></pre> <p>These are the solref and solimp attributes used to equality-constrain the joint. Whether or not a given joint is quality-constrained depends on the joint kind and composite object type as explained above. For joints that are not equality-constrained, this attribute has no effect. The defaults are adjusted depending on the composite type. Otherwise these attributes obey the same rules as all other solref and solimp attributes in MJCF. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Vec3 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Joint stiffness. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Limited = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.</p> <p>Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: float = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Vec2 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Vec5 = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: JointType = Field(\n    default_factory=lambda: deepcopy(default)\n)\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.joint.CompositeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/","title":"site","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site","title":"site","text":"<p>Defines the site type for composites.</p> <p>Note</p> <p>I was pretty lazy when I did this, I just decided to have this type inherit from the SiteBase class. That is not a super clean way to do it because it means this object may have attributes that MuJoCo will just ignore. The XML attributes defined here are restricted to the subset that only the composite site has.</p> <p>Sorry...</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite","title":"CompositeSite","text":"<p>               Bases: <code>SiteBase</code></p> <p>This sub-element adjusts the attributes of the sites in the composite object. Otherwise it is the same as geom above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>size: Vec3 | None = None\n</code></pre> <p>Sizes of the geometric shape representing the site. What shape it is I do not know.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: SiteName | None = None\n</code></pre> <p>Name of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: str | None = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>Material used to specify the visual properties of the site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Pos = Pos(pos=array((0, 0, 0)))\n</code></pre> <p>Position of the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>orientation: Orientation = Quat()\n</code></pre> <p>Orientation of the site frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: VecN | None = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/site/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.site.CompositeSite.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/","title":"skin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin","title":"skin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin","title":"Skin","text":"<p>               Bases: <code>XMLModel</code></p> <p>If this element is included, the model compiler will generate a skinned mesh asset and attach it to the element bodies of the composite object. Skin can be attached to 2D grid, cloth, box, cylinder and ellipsoid. For other composite types it has no effect. Note that the skin created here is equivalent to a skin specified directly in the XML, as opposed to a skin loaded from file. So if the model is saved as XML, it will contain a large section describing the automatically-generated skin.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: bool = False\n</code></pre> <p>If this is true, explicit texture coordinates will be generated, mapping the skin to the unit square in texture space. This is needed when the material specifies a texture. If texcoord is false and the skin has texture, the texture will appear fixed to the world instead of the skin. The reason for having this attribute in the first place is because skins with texture coordinates upload these coordinates to the GPU even if no texture is applied later. So this attribute should be set to false in cases where no texture will be applied via the material attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: MaterialName | None = None\n</code></pre> <p>If specified, this attribute applies a material to the geom. Otherwise, if unspecified and the type of the geom is a mesh the compiler will apply the mesh asset material if present.</p> <p>The material determines the visual properties of the geom. The only exception is color: if the rgba attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Vec4 = array((0.5, 0.5, 0.5, 1))\n</code></pre> <p>Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: int = 0\n</code></pre> <p>This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see inertiagrouprange attribute of compiler. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. By default, groups 0, 1 and 2 are visible, while all other groups are invisible. The group attribute can also be used as a tag for custom computations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.inflate","title":"inflate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inflate: float = 0\n</code></pre> <p>The default value of 0 means that the automatically-generated skin passes through the centers of the body elements comprising the composite object. Positive values offset each skin vertex by the specified amount, in the direction normal to the (non-inflated) skin at that vertex. This has two uses. First, in 2D objects, a small positive inflate factor is needed to avoid aliasing artifacts. Second, collisions are done with geoms that create some thickness, even for 2D objects. Inflating the skin with a value equal to the geom size will render the skin as a \"mattress\" that better represents the actual collision geometry. The value of this attribute is copied into the corresponding attribute of the skin asset being created.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.subgrid","title":"subgrid  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>subgrid: int = 0\n</code></pre> <p>This is only applicable to cloth and 2D grid types, and has no effect for any other composite type. The default value of 0 means that the skin has as many vertices as the number of element bodies. A positive value causes subdivision, with the specified number of (additional) grid lines. In this case the model compiler generates a denser skin using bi-cubic interpolation. This increases the quality of the rendering (especially in the absence of textures) but also slows down the renderer, so use it with caution. Values above 3 are unlikely to be needed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite_attr/skin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.composite_attr.skin.Skin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/","title":"flexcomp_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp_attr","title":"flexcomp_attr","text":"<p>Defines child attributes of the FlexComp class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/contact/","title":"contact","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/contact/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp_attr.contact","title":"contact","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/edge/","title":"edge","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/edge/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp_attr.edge","title":"edge","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/elasticity/","title":"elasticity","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/elasticity/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp_attr.elasticity","title":"elasticity","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/pin/","title":"pin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp_attr/pin/#mujoco_mojo.mjcf.mujoco_attr.body_attr.flexcomp_attr.pin","title":"pin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/","title":"compiler_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr","title":"compiler_attr","text":"<p>Defines child attributes of the Compiler class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: LengthRangeMode = MUSCLE\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: bool = True\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: bool = False\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: float = 20\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: float = 0\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: float = 1\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: float = 0.01\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: float = 10\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: float = 2\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: float = 0.05\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/","title":"lengthrange","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange","title":"lengthrange","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: LengthRangeMode = MUSCLE\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: bool = True\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: bool = False\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: float = 20\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: float = 0\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: float = 1\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: float = 0.01\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: float = 10\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: float = 2\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: float = 0.05\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/","title":"option_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr","title":"option_attr","text":"<p>Defines child attributes of the Option class.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: EnableDisable = ENABLE\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: EnableDisable = ENABLE\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: EnableDisable = ENABLE\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: EnableDisable = ENABLE\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: EnableDisable = ENABLE\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: EnableDisable = ENABLE\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: EnableDisable = ENABLE\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: EnableDisable = DISABLE\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: EnableDisable = DISABLE\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: EnableDisable = DISABLE\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p> <p>flag value at initialization time</p> <p>Unlike any other flag, the sleep flag has an effect during mjData initialization (mj_makeData or mj_resetData). First, it must be set at initialization time in order for the sleep-init policy to take effect. Second, it must be set in order for static quantities to be computed. See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/","title":"flag","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag","title":"flag","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: EnableDisable = ENABLE\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: EnableDisable = ENABLE\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: EnableDisable = ENABLE\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: EnableDisable = ENABLE\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: EnableDisable = ENABLE\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: EnableDisable = ENABLE\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: EnableDisable = ENABLE\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: EnableDisable = ENABLE\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: EnableDisable = ENABLE\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: EnableDisable = ENABLE\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: EnableDisable = DISABLE\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: EnableDisable = DISABLE\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: EnableDisable = DISABLE\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: EnableDisable = DISABLE\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p> <p>flag value at initialization time</p> <p>Unlike any other flag, the sleep flag has an effect during mjData initialization (mj_makeData or mj_resetData). First, it must be set at initialization time in order for the sleep-init policy to take effect. Second, it must be set in order for static quantities to be computed. See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"}]}