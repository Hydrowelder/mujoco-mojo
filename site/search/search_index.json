{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#mujoco-mojo","title":"MuJoCo Mojo","text":"<p>Pythonic MJCF generation and validation toolkit built on Pydantic v2.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed MJCF models</li> <li>Compile-time XML validation</li> <li>NumPy vector support</li> <li>Automatic XML serialization</li> <li>MuJoCo compatible schema</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"Python<pre><code>from mujoco_mojo import Material\n\nmat = Material(name=\"steel\")\nprint(mat.to_xml())\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mujoco_mojo<ul> <li>base</li> <li>mjcf<ul> <li>mujoco</li> <li>mujoco_attr<ul> <li>asset</li> <li>asset_attr<ul> <li>hfield</li> <li>material</li> <li>material_attr<ul> <li>layer</li> </ul> </li> <li>mesh</li> <li>mesh_attr<ul> <li>plugin</li> </ul> </li> <li>model</li> <li>texture</li> </ul> </li> <li>body</li> <li>body_attr<ul> <li>attach</li> <li>camera</li> <li>composite</li> <li>flexcomp</li> <li>frame</li> <li>free_joint</li> <li>geom</li> <li>inertial</li> <li>joint</li> <li>light</li> <li>plugin</li> <li>site</li> </ul> </li> <li>compiler</li> <li>compiler_attr<ul> <li>lengthrange</li> </ul> </li> <li>option</li> <li>option_attr<ul> <li>flag</li> </ul> </li> <li>size</li> <li>statistic</li> </ul> </li> </ul> </li> <li>types</li> <li>utils</li> <li>writer</li> </ul> </li> </ul>"},{"location":"reference/mujoco_mojo/","title":"mujoco_mojo","text":""},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body","title":"Body","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class Body(XMLModel):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"body\"\n\n    attributes = _body_attr\n    children = _body_children\n    __exclusive_groups__ = (frame_orientations,)\n\n    name: Optional[str] = None\n    \"\"\"Name of the body.\"\"\"\n    childclass: Optional[str] = None\n    \"\"\"If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.\"\"\"\n    mocap: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.\"\"\"\n    pos: Optional[Vec3] = None\n    \"The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).\"\n    quat: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    axisangle: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec6] = None\n    \"\"\"See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    gravcomp: Optional[float] = None\n    \"\"\"Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.\"\"\"\n    sleep: Optional[Sleep] = None\n    \"\"\"Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:\n\n    * A tree which is affected by actuators is not allowed to sleep (overridable).\n    * Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).\n    * Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).\n    * flexes are not allowed to sleep (not overridable).\n    * All other trees are allowed to sleep (overridable).\n\n    The policies never and allowed constitute user overrides of the automatic compiler policy.\n\n    The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.\n\n    See implementation notes for more details.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters. Has length of `nbody_user`\"\"\"\n\n    inertial: Optional[float] = None  # TODO\n    joints: List[float] = Field(default_factory=list)  # TODO\n    freejoints: Optional[List[float]] = Field(default_factory=list)  # TODO\n    geoms: List[Geom] = Field(default_factory=list)\n    sites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    cameras: Optional[List[float]] = Field(default_factory=list)  # TODO\n    lights: Optional[List[float]] = Field(default_factory=list)  # TODO\n    composites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    flexcomps: Optional[List[float]] = Field(default_factory=list)  # TODO\n    plugins: Optional[List[float]] = Field(default_factory=list)  # TODO\n    attaches: Optional[List[float]] = Field(default_factory=list)  # TODO\n    frames: Optional[List[float]] = Field(default_factory=list)  # TODO\n\n    bodies: List[Body] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Body.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler","title":"Compiler","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler.py</code> Python<pre><code>class Compiler(XMLModel):\n    \"\"\"This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.\"\"\"\n\n    tag = \"compiler\"\n\n    attributes = (\n        \"autolimits\",\n        \"boundmass\",\n        \"boundinertia\",\n        \"settotalmass\",\n        \"balanceinertia\",\n        \"strippath\",\n        \"coordinate\",\n        \"angle\",\n        \"fitaabb\",\n        \"eulerseq\",\n        \"meshdir\",\n        \"texturedir\",\n        \"discardvisual\",\n        \"usethread\",\n        \"fusestatic\",\n        \"inertiafromgeom\",\n        \"inertiagrouprange\",\n        \"saveinertial\",\n        \"assetdir\",\n        \"alignfree\",\n    )\n    children = (\"lengthrange\",)\n\n    autolimits: Optional[bool] = None\n    \"\"\"This attribute affects the behavior of attributes such as \"limited\" (on &lt;body-joint&gt; or &lt;tendon&gt;), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on &lt;actuator&gt;). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.\"\"\"\n    boundmass: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.\"\"\"\n    boundinertia: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.\"\"\"\n    settotalmass: Optional[float] = None\n    \"\"\"If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.\"\"\"\n    balanceinertia: Optional[bool] = None\n    \"\"\"A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.\"\"\"\n    strippath: Optional[bool] = None\n    \"\"\"When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.\"\"\"\n    coordinate: Optional[Coordinate] = None\n    \"\"\"In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.\"\"\"\n    angle: Optional[Angle] = None\n    \"\"\"This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.\"\"\"\n    fitaabb: Optional[bool] = None\n    \"\"\"The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).\"\"\"\n    eulerseq: Optional[str] = None\n    \"\"\"This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.\"\"\"\n    meshdir: Optional[str] = None\n    \"\"\"This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.\"\"\"\n    texturedir: Optional[str] = None\n    \"\"\"This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.\"\"\"\n    assetdir: Optional[str] = None\n    \"\"\"This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.\"\"\"\n    discardvisual: Optional[bool] = None\n    \"\"\"This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.\n\n    * All materials are discarded.\n    * All textures are discarded.\n    * All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.\n    * All meshes which are not referenced by any geom (in particular those discarded above) are discarded.\n\n    The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.\n    \"\"\"\n    usethread: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.\"\"\"\n    fusestatic: Optional[bool] = None\n    \"\"\"This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless\n\n    * They are referenced by another element in the model.\n    * They contain a site which is referenced by a force or torque sensor.\n\n    This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.\"\"\"\n    inertiafromgeom: Optional[InertiaFromGeom] = None\n    \"\"\"This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.\"\"\"\n    alignfree: Optional[bool] = None\n    \"\"\"This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.\"\"\"\n    inertiagrouprange: Optional[InertiaGroupRange] = None\n    \"\"\"This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.\"\"\"\n    saveinertial: Optional[bool] = None\n    \"\"\"If set to \"true\", the compiler will save explicit inertial clauses for all bodies.\"\"\"\n\n    lengthrange: Optional[LengthRange] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.alignfree","title":"alignfree  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>alignfree: Optional[bool] = None\n</code></pre> <p>This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>angle: Optional[Angle] = None\n</code></pre> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.assetdir","title":"assetdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>assetdir: Optional[str] = None\n</code></pre> <p>This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.autolimits","title":"autolimits  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autolimits: Optional[bool] = None\n</code></pre> <p>This attribute affects the behavior of attributes such as \"limited\" (on  or ), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on ). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.balanceinertia","title":"balanceinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>balanceinertia: Optional[bool] = None\n</code></pre> <p>A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.boundinertia","title":"boundinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundinertia: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.boundmass","title":"boundmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundmass: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.coordinate","title":"coordinate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>coordinate: Optional[Coordinate] = None\n</code></pre> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.discardvisual","title":"discardvisual  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>discardvisual: Optional[bool] = None\n</code></pre> <p>This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.</p> <ul> <li>All materials are discarded.</li> <li>All textures are discarded.</li> <li>All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.</li> <li>All meshes which are not referenced by any geom (in particular those discarded above) are discarded.</li> </ul> <p>The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.eulerseq","title":"eulerseq  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerseq: Optional[str] = None\n</code></pre> <p>This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.fitaabb","title":"fitaabb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitaabb: Optional[bool] = None\n</code></pre> <p>The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.fusestatic","title":"fusestatic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fusestatic: Optional[bool] = None\n</code></pre> <p>This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless</p> <ul> <li>They are referenced by another element in the model.</li> <li>They contain a site which is referenced by a force or torque sensor.</li> </ul> <p>This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.inertiafromgeom","title":"inertiafromgeom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiafromgeom: Optional[InertiaFromGeom] = None\n</code></pre> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.inertiagrouprange","title":"inertiagrouprange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiagrouprange: Optional[InertiaGroupRange] = None\n</code></pre> <p>This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.meshdir","title":"meshdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meshdir: Optional[str] = None\n</code></pre> <p>This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.saveinertial","title":"saveinertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>saveinertial: Optional[bool] = None\n</code></pre> <p>If set to \"true\", the compiler will save explicit inertial clauses for all bodies.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.settotalmass","title":"settotalmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>settotalmass: Optional[float] = None\n</code></pre> <p>If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.strippath","title":"strippath  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>strippath: Optional[bool] = None\n</code></pre> <p>When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.texturedir","title":"texturedir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texturedir: Optional[str] = None\n</code></pre> <p>This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.usethread","title":"usethread  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>usethread: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Compiler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option_attr\\flag.py</code> Python<pre><code>class Flag(XMLModel):\n    \"\"\"This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.\"\"\"\n\n    tag = \"flag\"\n\n    attributes = (\n        \"constraint\",\n        \"equality\",\n        \"frictionloss\",\n        \"limit\",\n        \"contact\",\n        \"spring\",\n        \"damping\",\n        \"gravity\",\n        \"clampctrl\",\n        \"warmstart\",\n        \"filterparent\",\n        \"actuation\",\n        \"refsafe\",\n        \"sensor\",\n        \"midphase\",\n        \"eulerdamp\",\n        \"autoreset\",\n        \"nativeccd\",\n        \"island\",\n        \"override\",\n        \"energy\",\n        \"fwdinv\",\n        \"invdiscrete\",\n        \"multiccd\",\n        \"sleep\",\n    )\n\n    constraint: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.\"\"\"\n    equality: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to equality constraints.\"\"\"\n    frictionloss: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to friction loss constraints.\"\"\"\n    limit: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to joint and tendon limit constraints.\"\"\"\n    contact: Optional[EnableDisable] = None\n    \"\"\"This flag disables collision detection and all standard computations related to contact constraints.\"\"\"\n    spring: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    damping: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    gravity: Optional[EnableDisable] = None\n    \"\"\"This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.\"\"\"\n    clampctrl: Optional[EnableDisable] = None\n    \"\"\"This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.\"\"\"\n    warmstart: Optional[EnableDisable] = None\n    \"\"\"This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.\"\"\"\n    filterparent: Optional[EnableDisable] = None\n    \"\"\"This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.\"\"\"\n    actuation: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.\"\"\"\n    refsafe: Optional[EnableDisable] = None\n    \"\"\"This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.\"\"\"\n    sensor: Optional[EnableDisable] = None\n    \"\"\"This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.\"\"\"\n    midphase: Optional[EnableDisable] = None\n    \"\"\"This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.\"\"\"\n    nativeccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.\"\"\"\n    island: Optional[EnableDisable] = None\n    \"\"\"This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.\"\"\"\n    eulerdamp: Optional[EnableDisable] = None\n    \"\"\"This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.\"\"\"\n    autoreset: Optional[EnableDisable] = None\n    \"\"\"This flag disables the automatic resetting of the simulation state when numerical issues are detected.\"\"\"\n    override: Optional[EnableDisable] = None\n    \"\"\"This flag enables the Contact override mechanism.\"\"\"\n    energy: Optional[EnableDisable] = None\n    \"\"\"This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.\n\n    The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.\"\"\"\n    fwdinv: Optional[EnableDisable] = None\n    \"\"\"This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.\"\"\"\n    invdiscrete: Optional[EnableDisable] = None\n    \"\"\"This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.\"\"\"\n    multiccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.\"\"\"\n    sleep: Optional[EnableDisable] = None\n    \"\"\"This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[EnableDisable] = None\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\free_joint.py</code> Python<pre><code>class FreeJoint(XMLModel):\n    \"\"\"This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for\n\n    ``` xml\n    &lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n    ```\n\n    While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.\"\"\"\n\n    tag = \"joint\"\n    type: ClassVar[JointType] = JointType.FREE\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    align: Optional[Align] = None\n    \"\"\"When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.\n\n    Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.\n\n    Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Optional[Align] = None\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\hfield.py</code> Python<pre><code>class HField(XMLModel):\n    \"\"\"This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:\n\n    1. The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.\n\n    2. The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4*(2+nrow*ncol) bytes:\n        ```\n        (int32)   nrow\n        (int32)   ncol\n        (float32) data[nrow*ncol]\n        ```\n    3. The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.\n\n    Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.\n\n    The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.\n\n    For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.\n    \"\"\"\n\n    tag = \"hfield\"\n\n    attributes = (\n        \"name\",\n        \"content_type\",\n        \"file\",\n        \"nrow\",\n        \"ncol\",\n        \"elevation\",\n        \"size\",\n    )\n\n    name: Optional[str] = None\n    \"\"\"Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.\"\"\"\n    nrow: Optional[int] = None\n    \"\"\"This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.\"\"\"\n    ncol: Optional[int] = None\n    \"\"\"This attribute specifies the number of columns in the elevation data matrix.\"\"\"\n    elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None  # type: ignore\n    \"\"\"This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.\"\"\"\n    size: Vec4\n    \"\"\"The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.\"\"\"\n\n    @model_validator(mode=\"before\")\n    def coerce_elevation(self) -&gt; HField:\n        elev = self.elevation\n        nrow = self.nrow\n        ncol = self.ncol\n\n        if elev is None:\n            return self\n\n        elev = np.asarray(elev, dtype=np.float64)\n\n        if nrow is not None and ncol is not None:\n            expected_len = nrow * ncol\n            if elev.size != expected_len:\n                raise ValueError(\n                    f\"Elevation length {elev.size} does not match nrow*ncol={expected_len}\"\n                )\n\n        # Normalize\n        min_val = elev.min()\n        max_val = elev.max()\n        if max_val &gt; min_val:\n            elev = (elev - min_val) / (max_val - min_val)\n\n        self.elevation = elev\n        return self\n\n    @field_validator(\"nrow\", \"ncol\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v is not None and v &lt; 0:\n            raise ValueError(\"nrow and ncol must be non-negative\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: Optional[int] = None\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: Optional[int] = None\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\inertial.py</code> Python<pre><code>class Inertial(XMLModel):\n    \"\"\"This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.\"\"\"\n\n    tag = \"inertial\"\n\n    attributes = (\n        \"pos\",\n        \"quat\",\n        \"mass\",\n        \"diaginertia\",\n        \"axisangle\",\n        \"xyaxes\",\n        \"zaxis\",\n        \"euler\",\n        \"fullinertia\",\n    )\n    __exclusive_groups__ = (frame_orientations, (\"diaginertia\", \"fullinertia\"))\n\n    pos: Vec3\n    \"\"\"Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.\"\"\"\n    quat: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    axisangle: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    mass: float\n    \"\"\"Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.\"\"\"\n    diaginertia: Optional[Vec3] = None\n    \"\"\"Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.\"\"\"\n    fullinertia: Optional[Vec6] = None\n    \"\"\"Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.\"\"\"\n\n    @property\n    def using_diag(self) -&gt; bool:\n        if self.diaginertia is not None and self.fullinertia is None:\n            return True\n        if self.diaginertia is None and self.fullinertia is not None:\n            return False\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Neither diaginertia nor fullinertia were specified.\")\n        raise ValueError(\"Both diaginertia and fullinertia were specified (invalid).\")\n\n    @property\n    def inertia_matrix(self) -&gt; np.ndarray:\n        if self.using_diag:\n            d = self.diaginertia\n            assert d is not None\n            return np.diag(np.asarray(d))\n\n        f = np.asarray(self.fullinertia)\n        assert f is not None\n\n        return np.array(\n            [\n                [f[0], f[3], f[4]],\n                [f[3], f[1], f[5]],\n                [f[4], f[5], f[2]],\n            ],\n            dtype=np.float64,\n        )\n\n    @property\n    def i_xx(self) -&gt; float:\n        return float(self.inertia_matrix[0, 0])\n\n    @property\n    def i_yy(self) -&gt; float:\n        return float(self.inertia_matrix[1, 1])\n\n    @property\n    def i_zz(self) -&gt; float:\n        return float(self.inertia_matrix[2, 2])\n\n    @property\n    def i_xy(self) -&gt; float:\n        return float(self.inertia_matrix[0, 1])\n\n    @property\n    def i_xz(self) -&gt; float:\n        return float(self.inertia_matrix[0, 2])\n\n    @property\n    def i_yz(self) -&gt; float:\n        return float(self.inertia_matrix[1, 2])\n\n    @property\n    def i_yx(self) -&gt; float:\n        return self.i_xy\n\n    @property\n    def i_zx(self) -&gt; float:\n        return self.i_xz\n\n    @property\n    def i_zy(self) -&gt; float:\n        return self.i_yz\n\n    @field_validator(\"mass\")\n    @classmethod\n    def validate_mass(cls, v: float) -&gt; float:\n        if not np.isfinite(v):\n            raise ValueError(\"mass must be finite\")\n        if v &lt; 0:\n            raise ValueError(\"mass must be non-negative\")\n        return v\n\n    @field_validator(\"diaginertia\")\n    @classmethod\n    def validate_diaginertia(cls, v: Vec3 | None) -&gt; Vec3 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (3,):\n            raise ValueError(\"diaginertia must be length 3\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"diaginertia must be finite\")\n\n        if np.any(arr &lt;= 0):\n            raise ValueError(\"diaginertia values must be positive\")\n\n        return arr\n\n    @field_validator(\"fullinertia\")\n    @classmethod\n    def validate_fullinertia(cls, v: Vec6 | None) -&gt; Vec6 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (6,):\n            raise ValueError(\"fullinertia must have length 6\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"fullinertia must be finite\")\n\n        return arr\n\n    @model_validator(mode=\"after\")\n    def validate_inertia_physics(self) -&gt; Inertial:\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Either diaginertia or fullinertia must be specified\")\n\n        if self.diaginertia is not None and self.fullinertia is not None:\n            raise ValueError(\"Only one of diaginertia or fullinertia may be specified\")\n\n        M = self.inertia_matrix\n\n        # Symmetry sanity check (numerical)\n        if not np.allclose(M, M.T, atol=1e-12):\n            raise ValueError(\"Inertia matrix is not symmetric\")\n\n        # Eigenvalue check (MuJoCo uses this too)\n        eigvals = np.linalg.eigvalsh(M)\n\n        if np.any(eigvals &lt;= 0):\n            raise ValueError(\n                f\"Inertia matrix must be positive definite. Eigenvalues: {eigvals}\"\n            )\n\n        return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Optional[Vec3] = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Optional[Vec6] = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\joint.py</code> Python<pre><code>class Joint(XMLModel):\n    \"\"\"This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.\"\"\"\n\n    tag = \"joint\"\n\n    attributes = ()\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    type: Optional[JointType] = None\n    \"\"\"Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.\n\n    The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.\n\n    The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.\n\n    The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    pos: Optional[Vec3] = None\n    \"\"\"Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.\"\"\"\n    axis: Optional[Vec3] = None\n    \"\"\"This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.\"\"\"\n    springdamper: Optional[Vec2] = None\n    \"\"\"When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.\"\"\"\n    solreflimit: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solimplimit: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solreffriction: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    solimpfriction: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    stiffness: Optional[float] = None\n    \"\"\"Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.\"\"\"\n    range: Optional[Vec2] = None\n    \"\"\"The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.\n    Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.\"\"\"\n    limited: Optional[Limited] = None\n    \"\"\"This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.\"\"\"\n    actuatorfrcrange: Optional[Vec2] = None\n    \"\"\"Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    The compiler expects the first value to be smaller than the second value.\n    Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".\"\"\"\n    actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n    \"\"\"This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.\"\"\"\n    actuatorgravcomp: Optional[bool] = None\n    \"\"\"If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.\"\"\"\n    margin: Optional[float] = None\n    \"\"\"The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.\"\"\"\n    ref: Optional[float] = None\n    \"\"\"The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.\"\"\"\n    springref: Optional[float] = None\n    \"\"\"The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.\"\"\"\n    armature: Optional[float] = None\n    \"\"\"Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.\n\n    Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.\"\"\"\n    damping: Optional[float] = None\n    \"\"\"Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.\"\"\"\n    frictionloss: Optional[float] = None\n    \"\"\"Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Optional[Vec2] = None\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: Optional[bool] = None\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: Optional[float] = None\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[float] = None\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[float] = None\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Optional[Limited] = None\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: Optional[float] = None\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Optional[Vec2] = None\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: Optional[float] = None\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Optional[Vec2] = None\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: Optional[float] = None\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: Optional[float] = None\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[JointType] = None\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material_attr\\layer.py</code> Python<pre><code>class Layer(XMLModel):\n    \"\"\"If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.\"\"\"\n\n    tag = \"layer\"\n\n    attributes = (\n        \"texture\",\n        \"role\",\n    )\n\n    texture: str\n    \"\"\"Name of the texture, like the texture attribute.\"\"\"\n    role: str\n    \"\"\"Role of the texture. The valid values, expected number of channels, and the role semantics are:\n\n    | value     | channels | description                                                  |\n    |:----------|:---------|:-------------------------------------------------------------|\n    | rgb       | 3        | base color / albedo [red, green, blue]                       |\n    | normal    | 3        | bump map (surface normals)                                   |\n    | occlusion | 1        | ambient occlusion                                            |\n    | roughness | 1        | roughness                                                    |\n    | metallic  | 1        | metallicity                                                  |\n    | opacity   | 1        | opacity (alpha channel)                                      |\n    | emissive  | 4        | RGB light emmision intensity, exposure weight in 4th channel |\n    | orm       | 3        | packed 3 channel [occlusion, roughness, metallic]            |\n    | rgba      | 4        | packed 4 channel [red, green, blue, alpha]                   |\n    \"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: str\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: str\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler_attr\\lengthrange.py</code> Python<pre><code>class LengthRange(XMLModel):\n    \"\"\"This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".\"\"\"\n\n    attributes = (\n        \"mode\",\n        \"useexisting\",\n        \"uselimit\",\n        \"accel\",\n        \"maxforce\",\n        \"timeconst\",\n        \"timestep\",\n        \"inttotal\",\n        \"interval\",\n        \"tolrange\",\n    )\n\n    mode: Optional[Mode] = None\n    \"\"\"Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.\"\"\"\n    useexisting: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.\"\"\"\n    uselimit: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.\"\"\"\n    accel: Optional[float] = None\n    \"\"\"This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.\"\"\"\n    maxforce: Optional[float] = None\n    \"\"\"The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.\"\"\"\n    timeconst: Optional[float] = None\n    \"\"\"The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.\"\"\"\n    timestep: Optional[float] = None\n    \"\"\"The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.\"\"\"\n    inttotal: Optional[float] = None\n    \"\"\"The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.\"\"\"\n    interval: Optional[float] = None\n    \"\"\"The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.\"\"\"\n    tolrange: Optional[float] = None\n    \"\"\"This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: Optional[float] = None\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: Optional[float] = None\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: Optional[float] = None\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: Optional[float] = None\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: Optional[Mode] = None\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: Optional[float] = None\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: Optional[float] = None\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material.py</code> Python<pre><code>class Material(XMLModel):\n    \"\"\"This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.\"\"\"\n\n    tag = \"material\"\n\n    attributes = (\n        \"name\",\n        \"class_\",\n        \"texture\",\n        \"texrepeat\",\n        \"texuniform\",\n        \"emission\",\n        \"specular\",\n        \"shininess\",\n        \"reflectance\",\n        \"metallic\",\n        \"roughness\",\n        \"rgba\",\n    )\n\n    children = (\"layers\",)\n\n    name: str\n    \"\"\"Name of the material, used for referencing.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    texture: Optional[str] = None\n    \"\"\"If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.\"\"\"\n    texrepeat: Optional[Vec2] = None\n    \"\"\"This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.\"\"\"\n    texuniform: Optional[bool] = None\n    \"\"\"For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.\"\"\"\n    emission: Optional[float] = None\n    \"\"\"Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.\"\"\"\n    specular: Optional[float] = None\n    \"\"\"Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].\"\"\"\n    shininess: Optional[float] = None\n    \"\"\"Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.\"\"\"\n    reflectance: Optional[float] = None\n    \"\"\"This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.\"\"\"\n    metallic: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.\"\"\"\n    roughness: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.\"\"\"\n    rgba: Optional[Vec4] = None\n    \"\"\"Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.\"\"\"\n\n    layers: List[Layer] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: Optional[float] = None\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: Optional[float] = None\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Optional[Vec4] = None\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: Optional[float] = None\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Optional[float] = None\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Optional[Vec2] = None\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: Optional[str] = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: Optional[bool] = None\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class Mesh(XMLModel):\n    \"\"\"This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.\"\"\"\n\n    tag = \"mesh\"\n\n    attributes = _mesh_attr\n\n    name: Optional[str] = None\n    \"\"\"Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes (only scale in this case).\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.\"\"\"\n    scale: Optional[Vec3] = None\n    \"\"\"This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.\"\"\"\n    inertia: Optional[Inertia] = None\n    \"\"\"This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.\n\n    * convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.\n    * exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.\n    * legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.\n    * shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.\n    \"\"\"\n    smoothnormal: Optional[bool] = None\n    \"\"\"Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.\"\"\"\n    maxhullvert: Optional[int] = None\n    \"\"\"Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.\"\"\"\n    vertex: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.\"\"\"\n    normal: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.\"\"\"\n    texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n    \"\"\"Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.\"\"\"\n    face: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.\"\"\"\n    refpos: Optional[Vec3] = None\n    \"\"\"Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.\"\"\"\n    refquat: Optional[Vec4] = None\n    \"\"\"Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.\"\"\"\n    material: Optional[str] = None\n    \"\"\"Fallback material for mesh geoms that do not specify their own material.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone","title":"MeshCone","text":"<p>               Bases: <code>Mesh</code></p> <p>Cone mesh from top and bottom polygons.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshCone(Mesh):\n    \"\"\"\n    Cone mesh from top and bottom polygons.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"cone\"\n\n    attributes = _mesh_attr + (\"builtin\", \"nvert\", \"radius\")\n\n    nvert: int\n    \"\"\"integer &gt;= 3: The number of vertices in the polygon.\"\"\"\n    radius: float\n    \"\"\"real in [0, 1]: The radius of the top face.\"\"\"\n\n    @field_validator(\"nvert\")\n    @classmethod\n    def validate_nvert(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"nvert must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"radius must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.nvert","title":"nvert  <code>instance-attribute</code>","text":"Python<pre><code>nvert: int\n</code></pre> <p>integer &gt;= 3: The number of vertices in the polygon.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in [0, 1]: The radius of the top face.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshCone.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere","title":"MeshHemisphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Quad-projected hemisphere.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshHemisphere(Mesh):\n    \"\"\"\n    Quad-projected hemisphere.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"hemisphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\")\n\n    resolution: int\n    \"\"\"integer in [0-10]: Equator discretization of one hemisphere quadrant.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 10:\n            raise ValueError(\"resolution must be in [0, 10]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer in [0-10]: Equator discretization of one hemisphere quadrant.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshHemisphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate","title":"MeshPlate","text":"<p>               Bases: <code>Mesh</code></p> <p>Rectangular plate mesh.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshPlate(Mesh):\n    \"\"\"\n    Rectangular plate mesh.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"plate\"\n\n    attributes = _mesh_attr + (\"builtin\", \"res_x\", \"res_y\")\n\n    res_x: int\n    \"\"\"integer &gt; 0: Horizontal resolution of the plate.\"\"\"\n    res_y: int\n    \"\"\"integer &gt; 0: Vertical resolution of the plate.\"\"\"\n\n    @field_validator(\"res_x\", \"res_y\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.res_x","title":"res_x  <code>instance-attribute</code>","text":"Python<pre><code>res_x: int\n</code></pre> <p>integer &gt; 0: Horizontal resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.res_y","title":"res_y  <code>instance-attribute</code>","text":"Python<pre><code>res_y: int\n</code></pre> <p>integer &gt; 0: Vertical resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshPlate.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere","title":"MeshSphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Repeated subdivisions of a unit icosahedron (\"icosphere\").</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSphere(Mesh):\n    \"\"\"\n    Repeated subdivisions of a unit icosahedron (\"icosphere\").\n    \"\"\"\n\n    builtin: ClassVar[str] = \"sphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"subdivision\")\n\n    subdivision: int\n    \"\"\"integer in [0-4]: The number of subdivisions to apply to icosahedron faces.\"\"\"\n\n    @field_validator(\"subdivision\")\n    @classmethod\n    def validate_subdivision(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 4:\n            raise ValueError(\"subdivision must be in [0, 4]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.subdivision","title":"subdivision  <code>instance-attribute</code>","text":"Python<pre><code>subdivision: int\n</code></pre> <p>integer in [0-4]: The number of subdivisions to apply to icosahedron faces.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere","title":"MeshSupersphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Supersphere (superellipsoid) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSupersphere(Mesh):\n    \"\"\"\n    Supersphere (superellipsoid) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"supersphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"e\", \"n\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Longitude and latitude discretization.\"\"\"\n    e: float\n    \"\"\"real &gt;= 0: The 'east-west' exponent.\"\"\"\n    n: float\n    \"\"\"real &gt;= 0: The 'north-south' exponent.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"e\", \"n\")\n    @classmethod\n    def validate_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.e","title":"e  <code>instance-attribute</code>","text":"Python<pre><code>e: float\n</code></pre> <p>real &gt;= 0: The 'east-west' exponent.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.n","title":"n  <code>instance-attribute</code>","text":"Python<pre><code>n: float\n</code></pre> <p>real &gt;= 0: The 'north-south' exponent.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Longitude and latitude discretization.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshSupersphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus","title":"MeshTorus","text":"<p>               Bases: <code>Mesh</code></p> <p>Supertorus (generalized torus) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshTorus(Mesh):\n    \"\"\"\n    Supertorus (generalized torus) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"torus\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"radius\", \"s\", \"t\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Discretization of both circumferences.\"\"\"\n    radius: float\n    \"\"\"real in (0, 1]: Minor radius of the torus.\"\"\"\n    s: float\n    \"\"\"real &gt; 0: The 'squareness' of minor sections.\"\"\"\n    t: float\n    \"\"\"real &gt; 0: The 'squareness' of major sections.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 1:\n            raise ValueError(\"radius must be in (0, 1]\")\n        return v\n\n    @field_validator(\"s\", \"t\")\n    @classmethod\n    def validate_positive(cls, v: float) -&gt; float:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in (0, 1]: Minor radius of the torus.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Discretization of both circumferences.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.s","title":"s  <code>instance-attribute</code>","text":"Python<pre><code>s: float\n</code></pre> <p>real &gt; 0: The 'squareness' of minor sections.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.t","title":"t  <code>instance-attribute</code>","text":"Python<pre><code>t: float\n</code></pre> <p>real &gt; 0: The 'squareness' of major sections.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshTorus.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge","title":"MeshWedge","text":"<p>               Bases: <code>Mesh</code></p> <p>Slice of a unit spherical shell.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshWedge(Mesh):\n    \"\"\"\n    Slice of a unit spherical shell.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"wedge\"\n\n    attributes = _mesh_attr + (\n        \"builtin\",\n        \"res_phi\",\n        \"res_theta\",\n        \"fov_phi\",\n        \"fov_theta\",\n        \"gamma\",\n    )\n\n    res_phi: int\n    \"\"\"integer &gt;= 0: Vertical resolution of the slice.\"\"\"\n    res_theta: int\n    \"\"\"integer &gt;= 0: Horizontal resolution of the slice.\"\"\"\n    fov_phi: float\n    \"\"\"real in (0, 180]: Horizontal field of view (degrees).\"\"\"\n    fov_theta: float\n    \"\"\"real in (0, 90): Vertical field of view (degrees).\"\"\"\n    gamma: float\n    \"\"\"real in [0, 1]: Foveal deformation of the discretization.\"\"\"\n\n    @field_validator(\"res_phi\", \"res_theta\")\n    @classmethod\n    def validate_non_negative(cls, v: int) -&gt; int:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n\n    @field_validator(\"fov_phi\")\n    @classmethod\n    def validate_fov_phi(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 180:\n            raise ValueError(\"fov_phi must be in (0, 180]\")\n        return v\n\n    @field_validator(\"fov_theta\")\n    @classmethod\n    def validate_fov_theta(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt; 90:\n            raise ValueError(\"fov_theta must be in (0, 90)\")\n        return v\n\n    @field_validator(\"gamma\")\n    @classmethod\n    def validate_gamma(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"gamma must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.fov_phi","title":"fov_phi  <code>instance-attribute</code>","text":"Python<pre><code>fov_phi: float\n</code></pre> <p>real in (0, 180]: Horizontal field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.fov_theta","title":"fov_theta  <code>instance-attribute</code>","text":"Python<pre><code>fov_theta: float\n</code></pre> <p>real in (0, 90): Vertical field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.gamma","title":"gamma  <code>instance-attribute</code>","text":"Python<pre><code>gamma: float\n</code></pre> <p>real in [0, 1]: Foveal deformation of the discretization.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.res_phi","title":"res_phi  <code>instance-attribute</code>","text":"Python<pre><code>res_phi: int\n</code></pre> <p>integer &gt;= 0: Vertical resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.res_theta","title":"res_theta  <code>instance-attribute</code>","text":"Python<pre><code>res_theta: int\n</code></pre> <p>integer &gt;= 0: Horizontal resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.MeshWedge.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\model.py</code> Python<pre><code>class Model(XMLModel):\n    \"\"\"This element specifies other MJCF models which may be used for attachment in the current model.\"\"\"\n\n    tag = \"model\"\n\n    attributes = (\"name\", \"file\", \"content_type\")\n\n    name: Optional[str] = None\n    \"\"\"Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.\"\"\"\n    file: Path\n    \"\"\"The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"The file type to be loaded into a model. Currently only text/xml is supported.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mujoco","title":"Mujoco","text":"<p>               Bases: <code>XMLModel</code></p> <p>The unique top-level element, identifying the XML file as an MJCF model file.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco.py</code> Python<pre><code>class Mujoco(XMLModel):\n    \"\"\"The unique top-level element, identifying the XML file as an MJCF model file.\"\"\"\n\n    tag = \"mujoco\"\n\n    attributes = (\"model\",)\n    children = (\n        \"options\",\n        \"compilers\",\n        \"sizes\",\n        \"statistics\",\n        \"assets\",\n        \"worldbody\",\n        \"deformables\",\n        \"contacts\",\n        \"equalities\",\n        \"tendons\",\n        \"actuators\",\n        \"sensors\",\n        \"keyframes\",\n        \"visuals\",\n        \"defaults\",\n        \"customs\",\n        \"extensions\",\n    )\n\n    model: str = \"MuJoCo Model\"\n    \"\"\"The name of the model. This name is shown in the title bar of simulate.cc.\"\"\"\n\n    options: List[Option] = Field(default_factory=list)\n    compilers: List[Compiler] = Field(default_factory=list)\n    sizes: List[Size] = Field(default_factory=list)\n    statistics: List = Field(default_factory=list)\n    assets: List = Field(default_factory=list)\n    worldbody: Optional[WorldBody] = None\n    deformables: List = Field(default_factory=list)\n    contacts: List = Field(default_factory=list)\n    equalities: List = Field(default_factory=list)\n    tendons: List = Field(default_factory=list)\n    actuators: List = Field(default_factory=list)\n    sensors: List = Field(default_factory=list)\n    keyframes: List = Field(default_factory=list)\n    visuals: List = Field(default_factory=list)\n    defaults: List = Field(default_factory=list)\n    customs: List = Field(default_factory=list)\n    extensions: List = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mujoco.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mujoco.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>model: str = 'MuJoCo Model'\n</code></pre> <p>The name of the model. This name is shown in the title bar of simulate.cc.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mujoco.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Mujoco.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option","title":"Option","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option.py</code> Python<pre><code>class Option(XMLModel):\n    \"\"\"This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.\"\"\"\n\n    tag = \"option\"\n\n    attributes = (\n        \"timestep\",\n        \"impratio\",\n        \"tolerance\",\n        \"ls_tolerance\",\n        \"noslip_tolerance\",\n        \"ccd_tolerance\",\n        \"sleep_tolerance\",\n        \"gravity\",\n        \"wind\",\n        \"magnetic\",\n        \"density\",\n        \"viscosity\",\n        \"o_margin\",\n        \"o_solref\",\n        \"o_solimp\",\n        \"o_friction\",\n        \"integrator\",\n        \"cone\",\n        \"jacobian\",\n        \"solver\",\n        \"iterations\",\n        \"ls_iterations\",\n        \"noslip_iterations\",\n        \"ccd_iterations\",\n        \"sdf_iterations\",\n        \"sdf_initpoints\",\n        \"actuatorgroupdisable\",\n    )\n    children = (\"flag\",)\n\n    timestep: Optional[float] = None\n    \"\"\"Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.\"\"\"\n    impratio: Optional[float] = None\n    \"\"\"This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.\"\"\"\n    gravity: Optional[Vec3] = None\n    \"\"\"Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.\"\"\"\n    wind: Optional[Vec3] = None\n    \"\"\"Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.\"\"\"\n    magnetic: Optional[Vec3] = None\n    \"\"\"Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.\"\"\"\n    density: Optional[float] = None\n    \"\"\"Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.\"\"\"\n    viscosity: Optional[float] = None\n    \"\"\"Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.\"\"\"\n    o_margin: Optional[float] = None\n    \"\"\"This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.\"\"\"\n    o_solref: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_solimp: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_friction: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    integrator: Optional[Integrator] = None\n    \"\"\"This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.\"\"\"\n    cone: Optional[Cone] = None\n    \"\"\"The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.\"\"\"\n    jacobian: Optional[Jacobian] = None\n    \"\"\"The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.\"\"\"\n    solver: Optional[Solver] = None\n    \"\"\"This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.\"\"\"\n    iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.\"\"\"\n    tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.\"\"\"\n    ls_iterations: Optional[int] = None\n    \"\"\"Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.\"\"\"\n    ls_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the linesearch algorithm.\"\"\"\n    noslip_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.\"\"\"\n    noslip_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the Noslip solver.\"\"\"\n    ccd_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.\"\"\"\n    ccd_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the convex collision algorithm.\"\"\"\n    sleep_tolerance: Optional[float] = None\n    \"\"\"Velocity tolerance below which sleeping is allowed.\"\"\"\n    sdf_iterations: Optional[int] = None\n    \"\"\"Number of iterations used for Signed Distance Field collisions (per initial point).\"\"\"\n    sdf_initpoints: Optional[int] = None\n    \"\"\"Number of starting points used for finding contacts with Signed Distance Field collisions.\"\"\"\n    actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n    \"\"\"List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.\"\"\"\n\n    flag: Optional[Flag] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.actuatorgroupdisable","title":"actuatorgroupdisable  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n</code></pre> <p>List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.ccd_iterations","title":"ccd_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.ccd_tolerance","title":"ccd_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the convex collision algorithm.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.cone","title":"cone  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cone: Optional[Cone] = None\n</code></pre> <p>The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: Optional[float] = None\n</code></pre> <p>Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[Vec3] = None\n</code></pre> <p>Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.impratio","title":"impratio  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>impratio: Optional[float] = None\n</code></pre> <p>This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.integrator","title":"integrator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>integrator: Optional[Integrator] = None\n</code></pre> <p>This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.iterations","title":"iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.jacobian","title":"jacobian  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>jacobian: Optional[Jacobian] = None\n</code></pre> <p>The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.ls_iterations","title":"ls_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.ls_tolerance","title":"ls_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the linesearch algorithm.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.magnetic","title":"magnetic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>magnetic: Optional[Vec3] = None\n</code></pre> <p>Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.noslip_iterations","title":"noslip_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.noslip_tolerance","title":"noslip_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the Noslip solver.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.o_friction","title":"o_friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_friction: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.o_margin","title":"o_margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_margin: Optional[float] = None\n</code></pre> <p>This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.o_solimp","title":"o_solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solimp: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.o_solref","title":"o_solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solref: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.sdf_initpoints","title":"sdf_initpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_initpoints: Optional[int] = None\n</code></pre> <p>Number of starting points used for finding contacts with Signed Distance Field collisions.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.sdf_iterations","title":"sdf_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_iterations: Optional[int] = None\n</code></pre> <p>Number of iterations used for Signed Distance Field collisions (per initial point).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.sleep_tolerance","title":"sleep_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep_tolerance: Optional[float] = None\n</code></pre> <p>Velocity tolerance below which sleeping is allowed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.solver","title":"solver  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solver: Optional[Solver] = None\n</code></pre> <p>This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.viscosity","title":"viscosity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>viscosity: Optional[float] = None\n</code></pre> <p>Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>wind: Optional[Vec3] = None\n</code></pre> <p>Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Option.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh_attr\\plugin.py</code> Python<pre><code>class Plugin(XMLModel):\n    \"\"\"Associate this mesh with an engine plugin. Either plugin or instance are required.\"\"\"\n\n    tag = \"plugin\"\n\n    attributes = (\"plugin\", \"instance\")\n\n    plugin: Optional[str] = None\n    \"\"\"Plugin identifier, used for implicit plugin instantiation.\"\"\"\n    instance: Optional[str] = None  # TODO I think this was implemented poorly\n    \"\"\"Instance name, used for explicit plugin instantiation.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: Optional[str] = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Optional[str] = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size","title":"Size","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\size.py</code> Python<pre><code>class Size(XMLModel):\n    \"\"\"This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.\"\"\"\n\n    tag = \"size\"\n\n    attributes = (\n        \"memory\",\n        \"njmax\",\n        \"nconmax\",\n        \"nstack\",\n        \"nuserdata\",\n        \"nkey\",\n        \"nuser_body\",\n        \"nuser_jnt\",\n        \"nuser_geom\",\n        \"nuser_site\",\n        \"nuser_cam\",\n        \"nuser_tendon\",\n        \"nuser_actuator\",\n        \"nuser_sensor\",\n    )\n\n    memory: Optional[str] = None\n    \"\"\"This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.\"\"\"\n    njmax: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.\"\"\"\n    nconmax: Optional[int] = None\n    \"\"\"This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.\"\"\"\n    nstack: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.\"\"\"\n    nuserdata: Optional[int] = None\n    \"\"\"The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.\"\"\"\n    nkey: Optional[int] = None\n    \"\"\"The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.\"\"\"\n    nuser_body: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.\"\"\"\n    nuser_jnt: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each joint.\"\"\"\n    nuser_geom: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each geom.\"\"\"\n    nuser_site: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each site.\"\"\"\n    nuser_cam: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each camera.\"\"\"\n    nuser_tendon: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each tendon.\"\"\"\n    nuser_actuator: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each actuator.\"\"\"\n    nuser_sensor: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each sensor.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>memory: Optional[str] = None\n</code></pre> <p>This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nconmax","title":"nconmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nconmax: Optional[int] = None\n</code></pre> <p>This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.njmax","title":"njmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>njmax: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nkey","title":"nkey  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nkey: Optional[int] = None\n</code></pre> <p>The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nstack","title":"nstack  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nstack: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_actuator","title":"nuser_actuator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_actuator: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each actuator.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_body","title":"nuser_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_body: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_cam","title":"nuser_cam  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_cam: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each camera.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_geom","title":"nuser_geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_geom: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each geom.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_jnt","title":"nuser_jnt  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_jnt: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each joint.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_sensor","title":"nuser_sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_sensor: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each sensor.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_site","title":"nuser_site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_site: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each site.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuser_tendon","title":"nuser_tendon  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_tendon: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each tendon.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.nuserdata","title":"nuserdata  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuserdata: Optional[int] = None\n</code></pre> <p>The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Size.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic","title":"Statistic","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\statistic.py</code> Python<pre><code>class Statistic(XMLModel):\n    \"\"\"This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.\"\"\"\n\n    tag = \"statistic\"\n\n    attributes = (\n        \"meaninertia\",\n        \"meanmass\",\n        \"meansize\",\n        \"extent\",\n        \"center\",\n    )\n\n    meanmass: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.\"\"\"\n    meaninertia: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.\"\"\"\n    meansize: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.\"\"\"\n    extent: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.\"\"\"\n    center: Optional[Vec3] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.center","title":"center  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>center: Optional[Vec3] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>extent: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.meaninertia","title":"meaninertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meaninertia: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.meanmass","title":"meanmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meanmass: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.meansize","title":"meansize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meansize: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Statistic.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\texture.py</code> Python<pre><code>class Texture(XMLModel):\n    \"\"\"This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.\n\n    The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.\n\n    Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.\n\n    The custom MuJoCo format is assumed to be a binary file containing the following data:\n    ```\n    (int32)   width\n    (int32)   height\n    (byte)    rgb_data[3*width*height]\n    ```\n    \"\"\"\n\n    tag = \"texture\"\n\n    attributes = _texture_attr\n\n    name: Optional[str] = None\n    \"\"\"As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.\"\"\"\n    type: Optional[Type] = None\n    \"\"\"This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:\n\n    The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:\n\n    1. Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.\n    2. Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.\n    3. Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.\n    4. Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.\n\n    The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.\n\n    The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.\"\"\"\n    colorspace: Optional[ColorSpace] = None\n    \"\"\"This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.\"\"\"\n    gridsize: Optional[Tuple[int, int]] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.\"\"\"\n    gridlayout: Optional[str] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.\"\"\"\n    fileright: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileleft: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileup: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filedown: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filefront: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileback: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: Optional[ColorSpace] = None\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: Optional[str] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: Optional[Tuple[int, int]] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[Type] = None\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody","title":"WorldBody","text":"<p>               Bases: <code>Body</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class WorldBody(Body):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"worldbody\"\n\n    attributes = ()\n    children = _world_body_children\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.WorldBody.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.XMLModel","title":"XMLModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for most MuJoCo Mojo MJCF objects.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>class XMLModel(BaseModel):\n    \"\"\"Base class for most MuJoCo Mojo MJCF objects.\"\"\"\n\n    tag: ClassVar[str]\n    \"\"\"Tag name of the XML tag.\"\"\"\n    attributes: ClassVar[tuple[str, ...]] = ()\n    \"\"\"Attributes of the XML tag.\"\"\"\n    children: ClassVar[tuple[str, ...]] = ()\n    \"\"\"Children of the XML tag.\"\"\"\n    __exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n    \"\"\"Attributes which if defined simultaneously will result in an error.\"\"\"\n\n    def to_xml(self) -&gt; Element:\n        el = Element(self.tag)\n\n        # attributes (deterministic)\n        for field in tuple(self.attributes):\n            value = getattr(self, field, None)\n            if value is not None:\n                # I use a trailing underscore to get around python's special names\n                # i.e., \"class\" is reserved for python so I use \"class_\" instead\n                field = field.rstrip(\"_\")\n                el.set(field, _format_value(value))\n\n        # children (deterministic)\n        for field in tuple(self.children):\n            value = getattr(self, field, None)\n\n            if value is None:\n                continue\n\n            if isinstance(value, list):\n                for item in value:\n                    el.append(item.to_xml())\n            else:\n                el.append(value.to_xml())\n\n        return el\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"\n        Validates that XML attribute and child names exist on the model.\n\n        This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n        \"\"\"\n        super().__pydantic_init_subclass__(**kwargs)\n\n        # Pydantic fields (includes inherited)\n        model_fields = set(cls.model_fields.keys())\n\n        # Class-level attributes (ClassVars, constants, etc)\n        class_vars = set(vars(cls).keys())\n\n        valid_names = model_fields | class_vars\n\n        # Validate attributes\n        for name in cls.attributes:\n            if name not in valid_names:\n                raise TypeError(\n                    f\"{cls.__name__}: attribute '{name}' is not defined \"\n                    f\"as a field or class variable\"\n                )\n\n        # Validate children\n        for name in cls.children:\n            if name not in valid_names:\n                raise TypeError(\n                    f\"{cls.__name__}: child '{name}' is not defined \"\n                    f\"as a field or class variable\"\n                )\n\n    @model_validator(mode=\"after\")\n    def enforce_exclusive_groups(self) -&gt; XMLModel:\n        \"\"\"\n        Ensures that only one attribute in each exclusive group is set.\n        \"\"\"\n        for group in self.__exclusive_groups__:\n            count = sum(getattr(self, field) is not None for field in group)\n            if count &gt; 1:\n                raise ValueError(\n                    f\"{type(self).__name__}: Only one of {group} may be specified\"\n                )\n        return self\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.XMLModel.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.XMLModel.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.XMLModel.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.XMLModel.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.XMLModel.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/#mujoco_mojo.XMLModel.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/base/","title":"base","text":""},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel","title":"XMLModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for most MuJoCo Mojo MJCF objects.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>class XMLModel(BaseModel):\n    \"\"\"Base class for most MuJoCo Mojo MJCF objects.\"\"\"\n\n    tag: ClassVar[str]\n    \"\"\"Tag name of the XML tag.\"\"\"\n    attributes: ClassVar[tuple[str, ...]] = ()\n    \"\"\"Attributes of the XML tag.\"\"\"\n    children: ClassVar[tuple[str, ...]] = ()\n    \"\"\"Children of the XML tag.\"\"\"\n    __exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n    \"\"\"Attributes which if defined simultaneously will result in an error.\"\"\"\n\n    def to_xml(self) -&gt; Element:\n        el = Element(self.tag)\n\n        # attributes (deterministic)\n        for field in tuple(self.attributes):\n            value = getattr(self, field, None)\n            if value is not None:\n                # I use a trailing underscore to get around python's special names\n                # i.e., \"class\" is reserved for python so I use \"class_\" instead\n                field = field.rstrip(\"_\")\n                el.set(field, _format_value(value))\n\n        # children (deterministic)\n        for field in tuple(self.children):\n            value = getattr(self, field, None)\n\n            if value is None:\n                continue\n\n            if isinstance(value, list):\n                for item in value:\n                    el.append(item.to_xml())\n            else:\n                el.append(value.to_xml())\n\n        return el\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):\n        \"\"\"\n        Validates that XML attribute and child names exist on the model.\n\n        This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n        \"\"\"\n        super().__pydantic_init_subclass__(**kwargs)\n\n        # Pydantic fields (includes inherited)\n        model_fields = set(cls.model_fields.keys())\n\n        # Class-level attributes (ClassVars, constants, etc)\n        class_vars = set(vars(cls).keys())\n\n        valid_names = model_fields | class_vars\n\n        # Validate attributes\n        for name in cls.attributes:\n            if name not in valid_names:\n                raise TypeError(\n                    f\"{cls.__name__}: attribute '{name}' is not defined \"\n                    f\"as a field or class variable\"\n                )\n\n        # Validate children\n        for name in cls.children:\n            if name not in valid_names:\n                raise TypeError(\n                    f\"{cls.__name__}: child '{name}' is not defined \"\n                    f\"as a field or class variable\"\n                )\n\n    @model_validator(mode=\"after\")\n    def enforce_exclusive_groups(self) -&gt; XMLModel:\n        \"\"\"\n        Ensures that only one attribute in each exclusive group is set.\n        \"\"\"\n        for group in self.__exclusive_groups__:\n            count = sum(getattr(self, field) is not None for field in group)\n            if count &gt; 1:\n                raise ValueError(\n                    f\"{type(self).__name__}: Only one of {group} may be specified\"\n                )\n        return self\n</code></pre>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/base/#mujoco_mojo.base.XMLModel.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/types/","title":"types","text":""},{"location":"reference/mujoco_mojo/utils/","title":"utils","text":""},{"location":"reference/mujoco_mojo/writer/","title":"writer","text":""},{"location":"reference/mujoco_mojo/mjcf/","title":"mjcf","text":""},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body","title":"Body","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class Body(XMLModel):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"body\"\n\n    attributes = _body_attr\n    children = _body_children\n    __exclusive_groups__ = (frame_orientations,)\n\n    name: Optional[str] = None\n    \"\"\"Name of the body.\"\"\"\n    childclass: Optional[str] = None\n    \"\"\"If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.\"\"\"\n    mocap: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.\"\"\"\n    pos: Optional[Vec3] = None\n    \"The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).\"\n    quat: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    axisangle: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec6] = None\n    \"\"\"See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    gravcomp: Optional[float] = None\n    \"\"\"Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.\"\"\"\n    sleep: Optional[Sleep] = None\n    \"\"\"Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:\n\n    * A tree which is affected by actuators is not allowed to sleep (overridable).\n    * Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).\n    * Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).\n    * flexes are not allowed to sleep (not overridable).\n    * All other trees are allowed to sleep (overridable).\n\n    The policies never and allowed constitute user overrides of the automatic compiler policy.\n\n    The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.\n\n    See implementation notes for more details.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters. Has length of `nbody_user`\"\"\"\n\n    inertial: Optional[float] = None  # TODO\n    joints: List[float] = Field(default_factory=list)  # TODO\n    freejoints: Optional[List[float]] = Field(default_factory=list)  # TODO\n    geoms: List[Geom] = Field(default_factory=list)\n    sites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    cameras: Optional[List[float]] = Field(default_factory=list)  # TODO\n    lights: Optional[List[float]] = Field(default_factory=list)  # TODO\n    composites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    flexcomps: Optional[List[float]] = Field(default_factory=list)  # TODO\n    plugins: Optional[List[float]] = Field(default_factory=list)  # TODO\n    attaches: Optional[List[float]] = Field(default_factory=list)  # TODO\n    frames: Optional[List[float]] = Field(default_factory=list)  # TODO\n\n    bodies: List[Body] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Body.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler","title":"Compiler","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler.py</code> Python<pre><code>class Compiler(XMLModel):\n    \"\"\"This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.\"\"\"\n\n    tag = \"compiler\"\n\n    attributes = (\n        \"autolimits\",\n        \"boundmass\",\n        \"boundinertia\",\n        \"settotalmass\",\n        \"balanceinertia\",\n        \"strippath\",\n        \"coordinate\",\n        \"angle\",\n        \"fitaabb\",\n        \"eulerseq\",\n        \"meshdir\",\n        \"texturedir\",\n        \"discardvisual\",\n        \"usethread\",\n        \"fusestatic\",\n        \"inertiafromgeom\",\n        \"inertiagrouprange\",\n        \"saveinertial\",\n        \"assetdir\",\n        \"alignfree\",\n    )\n    children = (\"lengthrange\",)\n\n    autolimits: Optional[bool] = None\n    \"\"\"This attribute affects the behavior of attributes such as \"limited\" (on &lt;body-joint&gt; or &lt;tendon&gt;), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on &lt;actuator&gt;). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.\"\"\"\n    boundmass: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.\"\"\"\n    boundinertia: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.\"\"\"\n    settotalmass: Optional[float] = None\n    \"\"\"If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.\"\"\"\n    balanceinertia: Optional[bool] = None\n    \"\"\"A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.\"\"\"\n    strippath: Optional[bool] = None\n    \"\"\"When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.\"\"\"\n    coordinate: Optional[Coordinate] = None\n    \"\"\"In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.\"\"\"\n    angle: Optional[Angle] = None\n    \"\"\"This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.\"\"\"\n    fitaabb: Optional[bool] = None\n    \"\"\"The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).\"\"\"\n    eulerseq: Optional[str] = None\n    \"\"\"This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.\"\"\"\n    meshdir: Optional[str] = None\n    \"\"\"This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.\"\"\"\n    texturedir: Optional[str] = None\n    \"\"\"This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.\"\"\"\n    assetdir: Optional[str] = None\n    \"\"\"This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.\"\"\"\n    discardvisual: Optional[bool] = None\n    \"\"\"This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.\n\n    * All materials are discarded.\n    * All textures are discarded.\n    * All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.\n    * All meshes which are not referenced by any geom (in particular those discarded above) are discarded.\n\n    The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.\n    \"\"\"\n    usethread: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.\"\"\"\n    fusestatic: Optional[bool] = None\n    \"\"\"This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless\n\n    * They are referenced by another element in the model.\n    * They contain a site which is referenced by a force or torque sensor.\n\n    This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.\"\"\"\n    inertiafromgeom: Optional[InertiaFromGeom] = None\n    \"\"\"This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.\"\"\"\n    alignfree: Optional[bool] = None\n    \"\"\"This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.\"\"\"\n    inertiagrouprange: Optional[InertiaGroupRange] = None\n    \"\"\"This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.\"\"\"\n    saveinertial: Optional[bool] = None\n    \"\"\"If set to \"true\", the compiler will save explicit inertial clauses for all bodies.\"\"\"\n\n    lengthrange: Optional[LengthRange] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.alignfree","title":"alignfree  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>alignfree: Optional[bool] = None\n</code></pre> <p>This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>angle: Optional[Angle] = None\n</code></pre> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.assetdir","title":"assetdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>assetdir: Optional[str] = None\n</code></pre> <p>This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.autolimits","title":"autolimits  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autolimits: Optional[bool] = None\n</code></pre> <p>This attribute affects the behavior of attributes such as \"limited\" (on  or ), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on ). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.balanceinertia","title":"balanceinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>balanceinertia: Optional[bool] = None\n</code></pre> <p>A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.boundinertia","title":"boundinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundinertia: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.boundmass","title":"boundmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundmass: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.coordinate","title":"coordinate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>coordinate: Optional[Coordinate] = None\n</code></pre> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.discardvisual","title":"discardvisual  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>discardvisual: Optional[bool] = None\n</code></pre> <p>This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.</p> <ul> <li>All materials are discarded.</li> <li>All textures are discarded.</li> <li>All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.</li> <li>All meshes which are not referenced by any geom (in particular those discarded above) are discarded.</li> </ul> <p>The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.eulerseq","title":"eulerseq  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerseq: Optional[str] = None\n</code></pre> <p>This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.fitaabb","title":"fitaabb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitaabb: Optional[bool] = None\n</code></pre> <p>The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.fusestatic","title":"fusestatic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fusestatic: Optional[bool] = None\n</code></pre> <p>This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless</p> <ul> <li>They are referenced by another element in the model.</li> <li>They contain a site which is referenced by a force or torque sensor.</li> </ul> <p>This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.inertiafromgeom","title":"inertiafromgeom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiafromgeom: Optional[InertiaFromGeom] = None\n</code></pre> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.inertiagrouprange","title":"inertiagrouprange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiagrouprange: Optional[InertiaGroupRange] = None\n</code></pre> <p>This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.meshdir","title":"meshdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meshdir: Optional[str] = None\n</code></pre> <p>This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.saveinertial","title":"saveinertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>saveinertial: Optional[bool] = None\n</code></pre> <p>If set to \"true\", the compiler will save explicit inertial clauses for all bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.settotalmass","title":"settotalmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>settotalmass: Optional[float] = None\n</code></pre> <p>If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.strippath","title":"strippath  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>strippath: Optional[bool] = None\n</code></pre> <p>When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.texturedir","title":"texturedir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texturedir: Optional[str] = None\n</code></pre> <p>This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.usethread","title":"usethread  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>usethread: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Compiler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option_attr\\flag.py</code> Python<pre><code>class Flag(XMLModel):\n    \"\"\"This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.\"\"\"\n\n    tag = \"flag\"\n\n    attributes = (\n        \"constraint\",\n        \"equality\",\n        \"frictionloss\",\n        \"limit\",\n        \"contact\",\n        \"spring\",\n        \"damping\",\n        \"gravity\",\n        \"clampctrl\",\n        \"warmstart\",\n        \"filterparent\",\n        \"actuation\",\n        \"refsafe\",\n        \"sensor\",\n        \"midphase\",\n        \"eulerdamp\",\n        \"autoreset\",\n        \"nativeccd\",\n        \"island\",\n        \"override\",\n        \"energy\",\n        \"fwdinv\",\n        \"invdiscrete\",\n        \"multiccd\",\n        \"sleep\",\n    )\n\n    constraint: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.\"\"\"\n    equality: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to equality constraints.\"\"\"\n    frictionloss: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to friction loss constraints.\"\"\"\n    limit: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to joint and tendon limit constraints.\"\"\"\n    contact: Optional[EnableDisable] = None\n    \"\"\"This flag disables collision detection and all standard computations related to contact constraints.\"\"\"\n    spring: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    damping: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    gravity: Optional[EnableDisable] = None\n    \"\"\"This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.\"\"\"\n    clampctrl: Optional[EnableDisable] = None\n    \"\"\"This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.\"\"\"\n    warmstart: Optional[EnableDisable] = None\n    \"\"\"This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.\"\"\"\n    filterparent: Optional[EnableDisable] = None\n    \"\"\"This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.\"\"\"\n    actuation: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.\"\"\"\n    refsafe: Optional[EnableDisable] = None\n    \"\"\"This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.\"\"\"\n    sensor: Optional[EnableDisable] = None\n    \"\"\"This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.\"\"\"\n    midphase: Optional[EnableDisable] = None\n    \"\"\"This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.\"\"\"\n    nativeccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.\"\"\"\n    island: Optional[EnableDisable] = None\n    \"\"\"This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.\"\"\"\n    eulerdamp: Optional[EnableDisable] = None\n    \"\"\"This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.\"\"\"\n    autoreset: Optional[EnableDisable] = None\n    \"\"\"This flag disables the automatic resetting of the simulation state when numerical issues are detected.\"\"\"\n    override: Optional[EnableDisable] = None\n    \"\"\"This flag enables the Contact override mechanism.\"\"\"\n    energy: Optional[EnableDisable] = None\n    \"\"\"This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.\n\n    The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.\"\"\"\n    fwdinv: Optional[EnableDisable] = None\n    \"\"\"This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.\"\"\"\n    invdiscrete: Optional[EnableDisable] = None\n    \"\"\"This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.\"\"\"\n    multiccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.\"\"\"\n    sleep: Optional[EnableDisable] = None\n    \"\"\"This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[EnableDisable] = None\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\free_joint.py</code> Python<pre><code>class FreeJoint(XMLModel):\n    \"\"\"This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for\n\n    ``` xml\n    &lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n    ```\n\n    While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.\"\"\"\n\n    tag = \"joint\"\n    type: ClassVar[JointType] = JointType.FREE\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    align: Optional[Align] = None\n    \"\"\"When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.\n\n    Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.\n\n    Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Optional[Align] = None\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\hfield.py</code> Python<pre><code>class HField(XMLModel):\n    \"\"\"This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:\n\n    1. The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.\n\n    2. The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4*(2+nrow*ncol) bytes:\n        ```\n        (int32)   nrow\n        (int32)   ncol\n        (float32) data[nrow*ncol]\n        ```\n    3. The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.\n\n    Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.\n\n    The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.\n\n    For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.\n    \"\"\"\n\n    tag = \"hfield\"\n\n    attributes = (\n        \"name\",\n        \"content_type\",\n        \"file\",\n        \"nrow\",\n        \"ncol\",\n        \"elevation\",\n        \"size\",\n    )\n\n    name: Optional[str] = None\n    \"\"\"Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.\"\"\"\n    nrow: Optional[int] = None\n    \"\"\"This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.\"\"\"\n    ncol: Optional[int] = None\n    \"\"\"This attribute specifies the number of columns in the elevation data matrix.\"\"\"\n    elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None  # type: ignore\n    \"\"\"This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.\"\"\"\n    size: Vec4\n    \"\"\"The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.\"\"\"\n\n    @model_validator(mode=\"before\")\n    def coerce_elevation(self) -&gt; HField:\n        elev = self.elevation\n        nrow = self.nrow\n        ncol = self.ncol\n\n        if elev is None:\n            return self\n\n        elev = np.asarray(elev, dtype=np.float64)\n\n        if nrow is not None and ncol is not None:\n            expected_len = nrow * ncol\n            if elev.size != expected_len:\n                raise ValueError(\n                    f\"Elevation length {elev.size} does not match nrow*ncol={expected_len}\"\n                )\n\n        # Normalize\n        min_val = elev.min()\n        max_val = elev.max()\n        if max_val &gt; min_val:\n            elev = (elev - min_val) / (max_val - min_val)\n\n        self.elevation = elev\n        return self\n\n    @field_validator(\"nrow\", \"ncol\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v is not None and v &lt; 0:\n            raise ValueError(\"nrow and ncol must be non-negative\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: Optional[int] = None\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: Optional[int] = None\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\inertial.py</code> Python<pre><code>class Inertial(XMLModel):\n    \"\"\"This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.\"\"\"\n\n    tag = \"inertial\"\n\n    attributes = (\n        \"pos\",\n        \"quat\",\n        \"mass\",\n        \"diaginertia\",\n        \"axisangle\",\n        \"xyaxes\",\n        \"zaxis\",\n        \"euler\",\n        \"fullinertia\",\n    )\n    __exclusive_groups__ = (frame_orientations, (\"diaginertia\", \"fullinertia\"))\n\n    pos: Vec3\n    \"\"\"Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.\"\"\"\n    quat: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    axisangle: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    mass: float\n    \"\"\"Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.\"\"\"\n    diaginertia: Optional[Vec3] = None\n    \"\"\"Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.\"\"\"\n    fullinertia: Optional[Vec6] = None\n    \"\"\"Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.\"\"\"\n\n    @property\n    def using_diag(self) -&gt; bool:\n        if self.diaginertia is not None and self.fullinertia is None:\n            return True\n        if self.diaginertia is None and self.fullinertia is not None:\n            return False\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Neither diaginertia nor fullinertia were specified.\")\n        raise ValueError(\"Both diaginertia and fullinertia were specified (invalid).\")\n\n    @property\n    def inertia_matrix(self) -&gt; np.ndarray:\n        if self.using_diag:\n            d = self.diaginertia\n            assert d is not None\n            return np.diag(np.asarray(d))\n\n        f = np.asarray(self.fullinertia)\n        assert f is not None\n\n        return np.array(\n            [\n                [f[0], f[3], f[4]],\n                [f[3], f[1], f[5]],\n                [f[4], f[5], f[2]],\n            ],\n            dtype=np.float64,\n        )\n\n    @property\n    def i_xx(self) -&gt; float:\n        return float(self.inertia_matrix[0, 0])\n\n    @property\n    def i_yy(self) -&gt; float:\n        return float(self.inertia_matrix[1, 1])\n\n    @property\n    def i_zz(self) -&gt; float:\n        return float(self.inertia_matrix[2, 2])\n\n    @property\n    def i_xy(self) -&gt; float:\n        return float(self.inertia_matrix[0, 1])\n\n    @property\n    def i_xz(self) -&gt; float:\n        return float(self.inertia_matrix[0, 2])\n\n    @property\n    def i_yz(self) -&gt; float:\n        return float(self.inertia_matrix[1, 2])\n\n    @property\n    def i_yx(self) -&gt; float:\n        return self.i_xy\n\n    @property\n    def i_zx(self) -&gt; float:\n        return self.i_xz\n\n    @property\n    def i_zy(self) -&gt; float:\n        return self.i_yz\n\n    @field_validator(\"mass\")\n    @classmethod\n    def validate_mass(cls, v: float) -&gt; float:\n        if not np.isfinite(v):\n            raise ValueError(\"mass must be finite\")\n        if v &lt; 0:\n            raise ValueError(\"mass must be non-negative\")\n        return v\n\n    @field_validator(\"diaginertia\")\n    @classmethod\n    def validate_diaginertia(cls, v: Vec3 | None) -&gt; Vec3 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (3,):\n            raise ValueError(\"diaginertia must be length 3\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"diaginertia must be finite\")\n\n        if np.any(arr &lt;= 0):\n            raise ValueError(\"diaginertia values must be positive\")\n\n        return arr\n\n    @field_validator(\"fullinertia\")\n    @classmethod\n    def validate_fullinertia(cls, v: Vec6 | None) -&gt; Vec6 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (6,):\n            raise ValueError(\"fullinertia must have length 6\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"fullinertia must be finite\")\n\n        return arr\n\n    @model_validator(mode=\"after\")\n    def validate_inertia_physics(self) -&gt; Inertial:\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Either diaginertia or fullinertia must be specified\")\n\n        if self.diaginertia is not None and self.fullinertia is not None:\n            raise ValueError(\"Only one of diaginertia or fullinertia may be specified\")\n\n        M = self.inertia_matrix\n\n        # Symmetry sanity check (numerical)\n        if not np.allclose(M, M.T, atol=1e-12):\n            raise ValueError(\"Inertia matrix is not symmetric\")\n\n        # Eigenvalue check (MuJoCo uses this too)\n        eigvals = np.linalg.eigvalsh(M)\n\n        if np.any(eigvals &lt;= 0):\n            raise ValueError(\n                f\"Inertia matrix must be positive definite. Eigenvalues: {eigvals}\"\n            )\n\n        return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Optional[Vec3] = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Optional[Vec6] = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\joint.py</code> Python<pre><code>class Joint(XMLModel):\n    \"\"\"This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.\"\"\"\n\n    tag = \"joint\"\n\n    attributes = ()\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    type: Optional[JointType] = None\n    \"\"\"Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.\n\n    The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.\n\n    The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.\n\n    The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    pos: Optional[Vec3] = None\n    \"\"\"Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.\"\"\"\n    axis: Optional[Vec3] = None\n    \"\"\"This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.\"\"\"\n    springdamper: Optional[Vec2] = None\n    \"\"\"When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.\"\"\"\n    solreflimit: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solimplimit: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solreffriction: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    solimpfriction: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    stiffness: Optional[float] = None\n    \"\"\"Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.\"\"\"\n    range: Optional[Vec2] = None\n    \"\"\"The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.\n    Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.\"\"\"\n    limited: Optional[Limited] = None\n    \"\"\"This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.\"\"\"\n    actuatorfrcrange: Optional[Vec2] = None\n    \"\"\"Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    The compiler expects the first value to be smaller than the second value.\n    Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".\"\"\"\n    actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n    \"\"\"This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.\"\"\"\n    actuatorgravcomp: Optional[bool] = None\n    \"\"\"If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.\"\"\"\n    margin: Optional[float] = None\n    \"\"\"The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.\"\"\"\n    ref: Optional[float] = None\n    \"\"\"The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.\"\"\"\n    springref: Optional[float] = None\n    \"\"\"The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.\"\"\"\n    armature: Optional[float] = None\n    \"\"\"Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.\n\n    Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.\"\"\"\n    damping: Optional[float] = None\n    \"\"\"Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.\"\"\"\n    frictionloss: Optional[float] = None\n    \"\"\"Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Optional[Vec2] = None\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: Optional[bool] = None\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: Optional[float] = None\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[float] = None\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[float] = None\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Optional[Limited] = None\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: Optional[float] = None\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Optional[Vec2] = None\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: Optional[float] = None\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Optional[Vec2] = None\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: Optional[float] = None\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: Optional[float] = None\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[JointType] = None\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material_attr\\layer.py</code> Python<pre><code>class Layer(XMLModel):\n    \"\"\"If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.\"\"\"\n\n    tag = \"layer\"\n\n    attributes = (\n        \"texture\",\n        \"role\",\n    )\n\n    texture: str\n    \"\"\"Name of the texture, like the texture attribute.\"\"\"\n    role: str\n    \"\"\"Role of the texture. The valid values, expected number of channels, and the role semantics are:\n\n    | value     | channels | description                                                  |\n    |:----------|:---------|:-------------------------------------------------------------|\n    | rgb       | 3        | base color / albedo [red, green, blue]                       |\n    | normal    | 3        | bump map (surface normals)                                   |\n    | occlusion | 1        | ambient occlusion                                            |\n    | roughness | 1        | roughness                                                    |\n    | metallic  | 1        | metallicity                                                  |\n    | opacity   | 1        | opacity (alpha channel)                                      |\n    | emissive  | 4        | RGB light emmision intensity, exposure weight in 4th channel |\n    | orm       | 3        | packed 3 channel [occlusion, roughness, metallic]            |\n    | rgba      | 4        | packed 4 channel [red, green, blue, alpha]                   |\n    \"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: str\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: str\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler_attr\\lengthrange.py</code> Python<pre><code>class LengthRange(XMLModel):\n    \"\"\"This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".\"\"\"\n\n    attributes = (\n        \"mode\",\n        \"useexisting\",\n        \"uselimit\",\n        \"accel\",\n        \"maxforce\",\n        \"timeconst\",\n        \"timestep\",\n        \"inttotal\",\n        \"interval\",\n        \"tolrange\",\n    )\n\n    mode: Optional[Mode] = None\n    \"\"\"Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.\"\"\"\n    useexisting: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.\"\"\"\n    uselimit: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.\"\"\"\n    accel: Optional[float] = None\n    \"\"\"This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.\"\"\"\n    maxforce: Optional[float] = None\n    \"\"\"The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.\"\"\"\n    timeconst: Optional[float] = None\n    \"\"\"The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.\"\"\"\n    timestep: Optional[float] = None\n    \"\"\"The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.\"\"\"\n    inttotal: Optional[float] = None\n    \"\"\"The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.\"\"\"\n    interval: Optional[float] = None\n    \"\"\"The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.\"\"\"\n    tolrange: Optional[float] = None\n    \"\"\"This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: Optional[float] = None\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: Optional[float] = None\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: Optional[float] = None\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: Optional[float] = None\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: Optional[Mode] = None\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: Optional[float] = None\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: Optional[float] = None\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material.py</code> Python<pre><code>class Material(XMLModel):\n    \"\"\"This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.\"\"\"\n\n    tag = \"material\"\n\n    attributes = (\n        \"name\",\n        \"class_\",\n        \"texture\",\n        \"texrepeat\",\n        \"texuniform\",\n        \"emission\",\n        \"specular\",\n        \"shininess\",\n        \"reflectance\",\n        \"metallic\",\n        \"roughness\",\n        \"rgba\",\n    )\n\n    children = (\"layers\",)\n\n    name: str\n    \"\"\"Name of the material, used for referencing.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    texture: Optional[str] = None\n    \"\"\"If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.\"\"\"\n    texrepeat: Optional[Vec2] = None\n    \"\"\"This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.\"\"\"\n    texuniform: Optional[bool] = None\n    \"\"\"For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.\"\"\"\n    emission: Optional[float] = None\n    \"\"\"Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.\"\"\"\n    specular: Optional[float] = None\n    \"\"\"Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].\"\"\"\n    shininess: Optional[float] = None\n    \"\"\"Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.\"\"\"\n    reflectance: Optional[float] = None\n    \"\"\"This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.\"\"\"\n    metallic: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.\"\"\"\n    roughness: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.\"\"\"\n    rgba: Optional[Vec4] = None\n    \"\"\"Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.\"\"\"\n\n    layers: List[Layer] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: Optional[float] = None\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: Optional[float] = None\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Optional[Vec4] = None\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: Optional[float] = None\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Optional[float] = None\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Optional[Vec2] = None\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: Optional[str] = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: Optional[bool] = None\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class Mesh(XMLModel):\n    \"\"\"This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.\"\"\"\n\n    tag = \"mesh\"\n\n    attributes = _mesh_attr\n\n    name: Optional[str] = None\n    \"\"\"Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes (only scale in this case).\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.\"\"\"\n    scale: Optional[Vec3] = None\n    \"\"\"This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.\"\"\"\n    inertia: Optional[Inertia] = None\n    \"\"\"This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.\n\n    * convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.\n    * exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.\n    * legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.\n    * shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.\n    \"\"\"\n    smoothnormal: Optional[bool] = None\n    \"\"\"Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.\"\"\"\n    maxhullvert: Optional[int] = None\n    \"\"\"Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.\"\"\"\n    vertex: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.\"\"\"\n    normal: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.\"\"\"\n    texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n    \"\"\"Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.\"\"\"\n    face: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.\"\"\"\n    refpos: Optional[Vec3] = None\n    \"\"\"Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.\"\"\"\n    refquat: Optional[Vec4] = None\n    \"\"\"Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.\"\"\"\n    material: Optional[str] = None\n    \"\"\"Fallback material for mesh geoms that do not specify their own material.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone","title":"MeshCone","text":"<p>               Bases: <code>Mesh</code></p> <p>Cone mesh from top and bottom polygons.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshCone(Mesh):\n    \"\"\"\n    Cone mesh from top and bottom polygons.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"cone\"\n\n    attributes = _mesh_attr + (\"builtin\", \"nvert\", \"radius\")\n\n    nvert: int\n    \"\"\"integer &gt;= 3: The number of vertices in the polygon.\"\"\"\n    radius: float\n    \"\"\"real in [0, 1]: The radius of the top face.\"\"\"\n\n    @field_validator(\"nvert\")\n    @classmethod\n    def validate_nvert(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"nvert must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"radius must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.nvert","title":"nvert  <code>instance-attribute</code>","text":"Python<pre><code>nvert: int\n</code></pre> <p>integer &gt;= 3: The number of vertices in the polygon.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in [0, 1]: The radius of the top face.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshCone.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere","title":"MeshHemisphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Quad-projected hemisphere.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshHemisphere(Mesh):\n    \"\"\"\n    Quad-projected hemisphere.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"hemisphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\")\n\n    resolution: int\n    \"\"\"integer in [0-10]: Equator discretization of one hemisphere quadrant.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 10:\n            raise ValueError(\"resolution must be in [0, 10]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer in [0-10]: Equator discretization of one hemisphere quadrant.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshHemisphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate","title":"MeshPlate","text":"<p>               Bases: <code>Mesh</code></p> <p>Rectangular plate mesh.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshPlate(Mesh):\n    \"\"\"\n    Rectangular plate mesh.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"plate\"\n\n    attributes = _mesh_attr + (\"builtin\", \"res_x\", \"res_y\")\n\n    res_x: int\n    \"\"\"integer &gt; 0: Horizontal resolution of the plate.\"\"\"\n    res_y: int\n    \"\"\"integer &gt; 0: Vertical resolution of the plate.\"\"\"\n\n    @field_validator(\"res_x\", \"res_y\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.res_x","title":"res_x  <code>instance-attribute</code>","text":"Python<pre><code>res_x: int\n</code></pre> <p>integer &gt; 0: Horizontal resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.res_y","title":"res_y  <code>instance-attribute</code>","text":"Python<pre><code>res_y: int\n</code></pre> <p>integer &gt; 0: Vertical resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshPlate.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere","title":"MeshSphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Repeated subdivisions of a unit icosahedron (\"icosphere\").</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSphere(Mesh):\n    \"\"\"\n    Repeated subdivisions of a unit icosahedron (\"icosphere\").\n    \"\"\"\n\n    builtin: ClassVar[str] = \"sphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"subdivision\")\n\n    subdivision: int\n    \"\"\"integer in [0-4]: The number of subdivisions to apply to icosahedron faces.\"\"\"\n\n    @field_validator(\"subdivision\")\n    @classmethod\n    def validate_subdivision(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 4:\n            raise ValueError(\"subdivision must be in [0, 4]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.subdivision","title":"subdivision  <code>instance-attribute</code>","text":"Python<pre><code>subdivision: int\n</code></pre> <p>integer in [0-4]: The number of subdivisions to apply to icosahedron faces.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere","title":"MeshSupersphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Supersphere (superellipsoid) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSupersphere(Mesh):\n    \"\"\"\n    Supersphere (superellipsoid) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"supersphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"e\", \"n\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Longitude and latitude discretization.\"\"\"\n    e: float\n    \"\"\"real &gt;= 0: The 'east-west' exponent.\"\"\"\n    n: float\n    \"\"\"real &gt;= 0: The 'north-south' exponent.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"e\", \"n\")\n    @classmethod\n    def validate_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.e","title":"e  <code>instance-attribute</code>","text":"Python<pre><code>e: float\n</code></pre> <p>real &gt;= 0: The 'east-west' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.n","title":"n  <code>instance-attribute</code>","text":"Python<pre><code>n: float\n</code></pre> <p>real &gt;= 0: The 'north-south' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Longitude and latitude discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshSupersphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus","title":"MeshTorus","text":"<p>               Bases: <code>Mesh</code></p> <p>Supertorus (generalized torus) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshTorus(Mesh):\n    \"\"\"\n    Supertorus (generalized torus) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"torus\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"radius\", \"s\", \"t\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Discretization of both circumferences.\"\"\"\n    radius: float\n    \"\"\"real in (0, 1]: Minor radius of the torus.\"\"\"\n    s: float\n    \"\"\"real &gt; 0: The 'squareness' of minor sections.\"\"\"\n    t: float\n    \"\"\"real &gt; 0: The 'squareness' of major sections.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 1:\n            raise ValueError(\"radius must be in (0, 1]\")\n        return v\n\n    @field_validator(\"s\", \"t\")\n    @classmethod\n    def validate_positive(cls, v: float) -&gt; float:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in (0, 1]: Minor radius of the torus.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Discretization of both circumferences.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.s","title":"s  <code>instance-attribute</code>","text":"Python<pre><code>s: float\n</code></pre> <p>real &gt; 0: The 'squareness' of minor sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.t","title":"t  <code>instance-attribute</code>","text":"Python<pre><code>t: float\n</code></pre> <p>real &gt; 0: The 'squareness' of major sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshTorus.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge","title":"MeshWedge","text":"<p>               Bases: <code>Mesh</code></p> <p>Slice of a unit spherical shell.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshWedge(Mesh):\n    \"\"\"\n    Slice of a unit spherical shell.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"wedge\"\n\n    attributes = _mesh_attr + (\n        \"builtin\",\n        \"res_phi\",\n        \"res_theta\",\n        \"fov_phi\",\n        \"fov_theta\",\n        \"gamma\",\n    )\n\n    res_phi: int\n    \"\"\"integer &gt;= 0: Vertical resolution of the slice.\"\"\"\n    res_theta: int\n    \"\"\"integer &gt;= 0: Horizontal resolution of the slice.\"\"\"\n    fov_phi: float\n    \"\"\"real in (0, 180]: Horizontal field of view (degrees).\"\"\"\n    fov_theta: float\n    \"\"\"real in (0, 90): Vertical field of view (degrees).\"\"\"\n    gamma: float\n    \"\"\"real in [0, 1]: Foveal deformation of the discretization.\"\"\"\n\n    @field_validator(\"res_phi\", \"res_theta\")\n    @classmethod\n    def validate_non_negative(cls, v: int) -&gt; int:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n\n    @field_validator(\"fov_phi\")\n    @classmethod\n    def validate_fov_phi(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 180:\n            raise ValueError(\"fov_phi must be in (0, 180]\")\n        return v\n\n    @field_validator(\"fov_theta\")\n    @classmethod\n    def validate_fov_theta(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt; 90:\n            raise ValueError(\"fov_theta must be in (0, 90)\")\n        return v\n\n    @field_validator(\"gamma\")\n    @classmethod\n    def validate_gamma(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"gamma must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.fov_phi","title":"fov_phi  <code>instance-attribute</code>","text":"Python<pre><code>fov_phi: float\n</code></pre> <p>real in (0, 180]: Horizontal field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.fov_theta","title":"fov_theta  <code>instance-attribute</code>","text":"Python<pre><code>fov_theta: float\n</code></pre> <p>real in (0, 90): Vertical field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.gamma","title":"gamma  <code>instance-attribute</code>","text":"Python<pre><code>gamma: float\n</code></pre> <p>real in [0, 1]: Foveal deformation of the discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.res_phi","title":"res_phi  <code>instance-attribute</code>","text":"Python<pre><code>res_phi: int\n</code></pre> <p>integer &gt;= 0: Vertical resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.res_theta","title":"res_theta  <code>instance-attribute</code>","text":"Python<pre><code>res_theta: int\n</code></pre> <p>integer &gt;= 0: Horizontal resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.MeshWedge.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\model.py</code> Python<pre><code>class Model(XMLModel):\n    \"\"\"This element specifies other MJCF models which may be used for attachment in the current model.\"\"\"\n\n    tag = \"model\"\n\n    attributes = (\"name\", \"file\", \"content_type\")\n\n    name: Optional[str] = None\n    \"\"\"Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.\"\"\"\n    file: Path\n    \"\"\"The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"The file type to be loaded into a model. Currently only text/xml is supported.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco","title":"Mujoco","text":"<p>               Bases: <code>XMLModel</code></p> <p>The unique top-level element, identifying the XML file as an MJCF model file.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco.py</code> Python<pre><code>class Mujoco(XMLModel):\n    \"\"\"The unique top-level element, identifying the XML file as an MJCF model file.\"\"\"\n\n    tag = \"mujoco\"\n\n    attributes = (\"model\",)\n    children = (\n        \"options\",\n        \"compilers\",\n        \"sizes\",\n        \"statistics\",\n        \"assets\",\n        \"worldbody\",\n        \"deformables\",\n        \"contacts\",\n        \"equalities\",\n        \"tendons\",\n        \"actuators\",\n        \"sensors\",\n        \"keyframes\",\n        \"visuals\",\n        \"defaults\",\n        \"customs\",\n        \"extensions\",\n    )\n\n    model: str = \"MuJoCo Model\"\n    \"\"\"The name of the model. This name is shown in the title bar of simulate.cc.\"\"\"\n\n    options: List[Option] = Field(default_factory=list)\n    compilers: List[Compiler] = Field(default_factory=list)\n    sizes: List[Size] = Field(default_factory=list)\n    statistics: List = Field(default_factory=list)\n    assets: List = Field(default_factory=list)\n    worldbody: Optional[WorldBody] = None\n    deformables: List = Field(default_factory=list)\n    contacts: List = Field(default_factory=list)\n    equalities: List = Field(default_factory=list)\n    tendons: List = Field(default_factory=list)\n    actuators: List = Field(default_factory=list)\n    sensors: List = Field(default_factory=list)\n    keyframes: List = Field(default_factory=list)\n    visuals: List = Field(default_factory=list)\n    defaults: List = Field(default_factory=list)\n    customs: List = Field(default_factory=list)\n    extensions: List = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>model: str = 'MuJoCo Model'\n</code></pre> <p>The name of the model. This name is shown in the title bar of simulate.cc.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Mujoco.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option","title":"Option","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option.py</code> Python<pre><code>class Option(XMLModel):\n    \"\"\"This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.\"\"\"\n\n    tag = \"option\"\n\n    attributes = (\n        \"timestep\",\n        \"impratio\",\n        \"tolerance\",\n        \"ls_tolerance\",\n        \"noslip_tolerance\",\n        \"ccd_tolerance\",\n        \"sleep_tolerance\",\n        \"gravity\",\n        \"wind\",\n        \"magnetic\",\n        \"density\",\n        \"viscosity\",\n        \"o_margin\",\n        \"o_solref\",\n        \"o_solimp\",\n        \"o_friction\",\n        \"integrator\",\n        \"cone\",\n        \"jacobian\",\n        \"solver\",\n        \"iterations\",\n        \"ls_iterations\",\n        \"noslip_iterations\",\n        \"ccd_iterations\",\n        \"sdf_iterations\",\n        \"sdf_initpoints\",\n        \"actuatorgroupdisable\",\n    )\n    children = (\"flag\",)\n\n    timestep: Optional[float] = None\n    \"\"\"Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.\"\"\"\n    impratio: Optional[float] = None\n    \"\"\"This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.\"\"\"\n    gravity: Optional[Vec3] = None\n    \"\"\"Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.\"\"\"\n    wind: Optional[Vec3] = None\n    \"\"\"Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.\"\"\"\n    magnetic: Optional[Vec3] = None\n    \"\"\"Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.\"\"\"\n    density: Optional[float] = None\n    \"\"\"Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.\"\"\"\n    viscosity: Optional[float] = None\n    \"\"\"Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.\"\"\"\n    o_margin: Optional[float] = None\n    \"\"\"This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.\"\"\"\n    o_solref: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_solimp: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_friction: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    integrator: Optional[Integrator] = None\n    \"\"\"This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.\"\"\"\n    cone: Optional[Cone] = None\n    \"\"\"The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.\"\"\"\n    jacobian: Optional[Jacobian] = None\n    \"\"\"The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.\"\"\"\n    solver: Optional[Solver] = None\n    \"\"\"This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.\"\"\"\n    iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.\"\"\"\n    tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.\"\"\"\n    ls_iterations: Optional[int] = None\n    \"\"\"Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.\"\"\"\n    ls_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the linesearch algorithm.\"\"\"\n    noslip_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.\"\"\"\n    noslip_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the Noslip solver.\"\"\"\n    ccd_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.\"\"\"\n    ccd_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the convex collision algorithm.\"\"\"\n    sleep_tolerance: Optional[float] = None\n    \"\"\"Velocity tolerance below which sleeping is allowed.\"\"\"\n    sdf_iterations: Optional[int] = None\n    \"\"\"Number of iterations used for Signed Distance Field collisions (per initial point).\"\"\"\n    sdf_initpoints: Optional[int] = None\n    \"\"\"Number of starting points used for finding contacts with Signed Distance Field collisions.\"\"\"\n    actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n    \"\"\"List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.\"\"\"\n\n    flag: Optional[Flag] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.actuatorgroupdisable","title":"actuatorgroupdisable  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n</code></pre> <p>List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ccd_iterations","title":"ccd_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ccd_tolerance","title":"ccd_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the convex collision algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.cone","title":"cone  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cone: Optional[Cone] = None\n</code></pre> <p>The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: Optional[float] = None\n</code></pre> <p>Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[Vec3] = None\n</code></pre> <p>Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.impratio","title":"impratio  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>impratio: Optional[float] = None\n</code></pre> <p>This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.integrator","title":"integrator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>integrator: Optional[Integrator] = None\n</code></pre> <p>This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.iterations","title":"iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.jacobian","title":"jacobian  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>jacobian: Optional[Jacobian] = None\n</code></pre> <p>The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ls_iterations","title":"ls_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.ls_tolerance","title":"ls_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the linesearch algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.magnetic","title":"magnetic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>magnetic: Optional[Vec3] = None\n</code></pre> <p>Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.noslip_iterations","title":"noslip_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.noslip_tolerance","title":"noslip_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the Noslip solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_friction","title":"o_friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_friction: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_margin","title":"o_margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_margin: Optional[float] = None\n</code></pre> <p>This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_solimp","title":"o_solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solimp: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.o_solref","title":"o_solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solref: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.sdf_initpoints","title":"sdf_initpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_initpoints: Optional[int] = None\n</code></pre> <p>Number of starting points used for finding contacts with Signed Distance Field collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.sdf_iterations","title":"sdf_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_iterations: Optional[int] = None\n</code></pre> <p>Number of iterations used for Signed Distance Field collisions (per initial point).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.sleep_tolerance","title":"sleep_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep_tolerance: Optional[float] = None\n</code></pre> <p>Velocity tolerance below which sleeping is allowed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.solver","title":"solver  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solver: Optional[Solver] = None\n</code></pre> <p>This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.viscosity","title":"viscosity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>viscosity: Optional[float] = None\n</code></pre> <p>Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>wind: Optional[Vec3] = None\n</code></pre> <p>Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Option.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh_attr\\plugin.py</code> Python<pre><code>class Plugin(XMLModel):\n    \"\"\"Associate this mesh with an engine plugin. Either plugin or instance are required.\"\"\"\n\n    tag = \"plugin\"\n\n    attributes = (\"plugin\", \"instance\")\n\n    plugin: Optional[str] = None\n    \"\"\"Plugin identifier, used for implicit plugin instantiation.\"\"\"\n    instance: Optional[str] = None  # TODO I think this was implemented poorly\n    \"\"\"Instance name, used for explicit plugin instantiation.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: Optional[str] = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Optional[str] = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size","title":"Size","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\size.py</code> Python<pre><code>class Size(XMLModel):\n    \"\"\"This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.\"\"\"\n\n    tag = \"size\"\n\n    attributes = (\n        \"memory\",\n        \"njmax\",\n        \"nconmax\",\n        \"nstack\",\n        \"nuserdata\",\n        \"nkey\",\n        \"nuser_body\",\n        \"nuser_jnt\",\n        \"nuser_geom\",\n        \"nuser_site\",\n        \"nuser_cam\",\n        \"nuser_tendon\",\n        \"nuser_actuator\",\n        \"nuser_sensor\",\n    )\n\n    memory: Optional[str] = None\n    \"\"\"This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.\"\"\"\n    njmax: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.\"\"\"\n    nconmax: Optional[int] = None\n    \"\"\"This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.\"\"\"\n    nstack: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.\"\"\"\n    nuserdata: Optional[int] = None\n    \"\"\"The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.\"\"\"\n    nkey: Optional[int] = None\n    \"\"\"The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.\"\"\"\n    nuser_body: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.\"\"\"\n    nuser_jnt: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each joint.\"\"\"\n    nuser_geom: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each geom.\"\"\"\n    nuser_site: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each site.\"\"\"\n    nuser_cam: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each camera.\"\"\"\n    nuser_tendon: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each tendon.\"\"\"\n    nuser_actuator: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each actuator.\"\"\"\n    nuser_sensor: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each sensor.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>memory: Optional[str] = None\n</code></pre> <p>This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nconmax","title":"nconmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nconmax: Optional[int] = None\n</code></pre> <p>This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.njmax","title":"njmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>njmax: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nkey","title":"nkey  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nkey: Optional[int] = None\n</code></pre> <p>The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nstack","title":"nstack  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nstack: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_actuator","title":"nuser_actuator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_actuator: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each actuator.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_body","title":"nuser_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_body: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_cam","title":"nuser_cam  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_cam: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_geom","title":"nuser_geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_geom: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_jnt","title":"nuser_jnt  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_jnt: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_sensor","title":"nuser_sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_sensor: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each sensor.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_site","title":"nuser_site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_site: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each site.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuser_tendon","title":"nuser_tendon  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_tendon: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each tendon.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.nuserdata","title":"nuserdata  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuserdata: Optional[int] = None\n</code></pre> <p>The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Size.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic","title":"Statistic","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\statistic.py</code> Python<pre><code>class Statistic(XMLModel):\n    \"\"\"This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.\"\"\"\n\n    tag = \"statistic\"\n\n    attributes = (\n        \"meaninertia\",\n        \"meanmass\",\n        \"meansize\",\n        \"extent\",\n        \"center\",\n    )\n\n    meanmass: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.\"\"\"\n    meaninertia: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.\"\"\"\n    meansize: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.\"\"\"\n    extent: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.\"\"\"\n    center: Optional[Vec3] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.center","title":"center  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>center: Optional[Vec3] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>extent: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.meaninertia","title":"meaninertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meaninertia: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.meanmass","title":"meanmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meanmass: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.meansize","title":"meansize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meansize: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Statistic.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\texture.py</code> Python<pre><code>class Texture(XMLModel):\n    \"\"\"This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.\n\n    The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.\n\n    Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.\n\n    The custom MuJoCo format is assumed to be a binary file containing the following data:\n    ```\n    (int32)   width\n    (int32)   height\n    (byte)    rgb_data[3*width*height]\n    ```\n    \"\"\"\n\n    tag = \"texture\"\n\n    attributes = _texture_attr\n\n    name: Optional[str] = None\n    \"\"\"As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.\"\"\"\n    type: Optional[Type] = None\n    \"\"\"This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:\n\n    The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:\n\n    1. Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.\n    2. Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.\n    3. Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.\n    4. Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.\n\n    The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.\n\n    The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.\"\"\"\n    colorspace: Optional[ColorSpace] = None\n    \"\"\"This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.\"\"\"\n    gridsize: Optional[Tuple[int, int]] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.\"\"\"\n    gridlayout: Optional[str] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.\"\"\"\n    fileright: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileleft: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileup: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filedown: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filefront: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileback: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: Optional[ColorSpace] = None\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: Optional[str] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: Optional[Tuple[int, int]] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[Type] = None\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody","title":"WorldBody","text":"<p>               Bases: <code>Body</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class WorldBody(Body):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"worldbody\"\n\n    attributes = ()\n    children = _world_body_children\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/#mujoco_mojo.mjcf.WorldBody.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/","title":"mujoco","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco","title":"Mujoco","text":"<p>               Bases: <code>XMLModel</code></p> <p>The unique top-level element, identifying the XML file as an MJCF model file.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco.py</code> Python<pre><code>class Mujoco(XMLModel):\n    \"\"\"The unique top-level element, identifying the XML file as an MJCF model file.\"\"\"\n\n    tag = \"mujoco\"\n\n    attributes = (\"model\",)\n    children = (\n        \"options\",\n        \"compilers\",\n        \"sizes\",\n        \"statistics\",\n        \"assets\",\n        \"worldbody\",\n        \"deformables\",\n        \"contacts\",\n        \"equalities\",\n        \"tendons\",\n        \"actuators\",\n        \"sensors\",\n        \"keyframes\",\n        \"visuals\",\n        \"defaults\",\n        \"customs\",\n        \"extensions\",\n    )\n\n    model: str = \"MuJoCo Model\"\n    \"\"\"The name of the model. This name is shown in the title bar of simulate.cc.\"\"\"\n\n    options: List[Option] = Field(default_factory=list)\n    compilers: List[Compiler] = Field(default_factory=list)\n    sizes: List[Size] = Field(default_factory=list)\n    statistics: List = Field(default_factory=list)\n    assets: List = Field(default_factory=list)\n    worldbody: Optional[WorldBody] = None\n    deformables: List = Field(default_factory=list)\n    contacts: List = Field(default_factory=list)\n    equalities: List = Field(default_factory=list)\n    tendons: List = Field(default_factory=list)\n    actuators: List = Field(default_factory=list)\n    sensors: List = Field(default_factory=list)\n    keyframes: List = Field(default_factory=list)\n    visuals: List = Field(default_factory=list)\n    defaults: List = Field(default_factory=list)\n    customs: List = Field(default_factory=list)\n    extensions: List = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>model: str = 'MuJoCo Model'\n</code></pre> <p>The name of the model. This name is shown in the title bar of simulate.cc.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco/#mujoco_mojo.mjcf.mujoco.Mujoco.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/","title":"mujoco_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body","title":"Body","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class Body(XMLModel):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"body\"\n\n    attributes = _body_attr\n    children = _body_children\n    __exclusive_groups__ = (frame_orientations,)\n\n    name: Optional[str] = None\n    \"\"\"Name of the body.\"\"\"\n    childclass: Optional[str] = None\n    \"\"\"If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.\"\"\"\n    mocap: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.\"\"\"\n    pos: Optional[Vec3] = None\n    \"The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).\"\n    quat: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    axisangle: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec6] = None\n    \"\"\"See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    gravcomp: Optional[float] = None\n    \"\"\"Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.\"\"\"\n    sleep: Optional[Sleep] = None\n    \"\"\"Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:\n\n    * A tree which is affected by actuators is not allowed to sleep (overridable).\n    * Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).\n    * Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).\n    * flexes are not allowed to sleep (not overridable).\n    * All other trees are allowed to sleep (overridable).\n\n    The policies never and allowed constitute user overrides of the automatic compiler policy.\n\n    The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.\n\n    See implementation notes for more details.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters. Has length of `nbody_user`\"\"\"\n\n    inertial: Optional[float] = None  # TODO\n    joints: List[float] = Field(default_factory=list)  # TODO\n    freejoints: Optional[List[float]] = Field(default_factory=list)  # TODO\n    geoms: List[Geom] = Field(default_factory=list)\n    sites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    cameras: Optional[List[float]] = Field(default_factory=list)  # TODO\n    lights: Optional[List[float]] = Field(default_factory=list)  # TODO\n    composites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    flexcomps: Optional[List[float]] = Field(default_factory=list)  # TODO\n    plugins: Optional[List[float]] = Field(default_factory=list)  # TODO\n    attaches: Optional[List[float]] = Field(default_factory=list)  # TODO\n    frames: Optional[List[float]] = Field(default_factory=list)  # TODO\n\n    bodies: List[Body] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Body.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler","title":"Compiler","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler.py</code> Python<pre><code>class Compiler(XMLModel):\n    \"\"\"This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.\"\"\"\n\n    tag = \"compiler\"\n\n    attributes = (\n        \"autolimits\",\n        \"boundmass\",\n        \"boundinertia\",\n        \"settotalmass\",\n        \"balanceinertia\",\n        \"strippath\",\n        \"coordinate\",\n        \"angle\",\n        \"fitaabb\",\n        \"eulerseq\",\n        \"meshdir\",\n        \"texturedir\",\n        \"discardvisual\",\n        \"usethread\",\n        \"fusestatic\",\n        \"inertiafromgeom\",\n        \"inertiagrouprange\",\n        \"saveinertial\",\n        \"assetdir\",\n        \"alignfree\",\n    )\n    children = (\"lengthrange\",)\n\n    autolimits: Optional[bool] = None\n    \"\"\"This attribute affects the behavior of attributes such as \"limited\" (on &lt;body-joint&gt; or &lt;tendon&gt;), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on &lt;actuator&gt;). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.\"\"\"\n    boundmass: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.\"\"\"\n    boundinertia: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.\"\"\"\n    settotalmass: Optional[float] = None\n    \"\"\"If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.\"\"\"\n    balanceinertia: Optional[bool] = None\n    \"\"\"A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.\"\"\"\n    strippath: Optional[bool] = None\n    \"\"\"When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.\"\"\"\n    coordinate: Optional[Coordinate] = None\n    \"\"\"In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.\"\"\"\n    angle: Optional[Angle] = None\n    \"\"\"This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.\"\"\"\n    fitaabb: Optional[bool] = None\n    \"\"\"The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).\"\"\"\n    eulerseq: Optional[str] = None\n    \"\"\"This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.\"\"\"\n    meshdir: Optional[str] = None\n    \"\"\"This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.\"\"\"\n    texturedir: Optional[str] = None\n    \"\"\"This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.\"\"\"\n    assetdir: Optional[str] = None\n    \"\"\"This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.\"\"\"\n    discardvisual: Optional[bool] = None\n    \"\"\"This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.\n\n    * All materials are discarded.\n    * All textures are discarded.\n    * All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.\n    * All meshes which are not referenced by any geom (in particular those discarded above) are discarded.\n\n    The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.\n    \"\"\"\n    usethread: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.\"\"\"\n    fusestatic: Optional[bool] = None\n    \"\"\"This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless\n\n    * They are referenced by another element in the model.\n    * They contain a site which is referenced by a force or torque sensor.\n\n    This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.\"\"\"\n    inertiafromgeom: Optional[InertiaFromGeom] = None\n    \"\"\"This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.\"\"\"\n    alignfree: Optional[bool] = None\n    \"\"\"This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.\"\"\"\n    inertiagrouprange: Optional[InertiaGroupRange] = None\n    \"\"\"This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.\"\"\"\n    saveinertial: Optional[bool] = None\n    \"\"\"If set to \"true\", the compiler will save explicit inertial clauses for all bodies.\"\"\"\n\n    lengthrange: Optional[LengthRange] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.alignfree","title":"alignfree  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>alignfree: Optional[bool] = None\n</code></pre> <p>This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>angle: Optional[Angle] = None\n</code></pre> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.assetdir","title":"assetdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>assetdir: Optional[str] = None\n</code></pre> <p>This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.autolimits","title":"autolimits  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autolimits: Optional[bool] = None\n</code></pre> <p>This attribute affects the behavior of attributes such as \"limited\" (on  or ), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on ). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.balanceinertia","title":"balanceinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>balanceinertia: Optional[bool] = None\n</code></pre> <p>A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.boundinertia","title":"boundinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundinertia: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.boundmass","title":"boundmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundmass: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.coordinate","title":"coordinate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>coordinate: Optional[Coordinate] = None\n</code></pre> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.discardvisual","title":"discardvisual  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>discardvisual: Optional[bool] = None\n</code></pre> <p>This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.</p> <ul> <li>All materials are discarded.</li> <li>All textures are discarded.</li> <li>All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.</li> <li>All meshes which are not referenced by any geom (in particular those discarded above) are discarded.</li> </ul> <p>The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.eulerseq","title":"eulerseq  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerseq: Optional[str] = None\n</code></pre> <p>This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.fitaabb","title":"fitaabb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitaabb: Optional[bool] = None\n</code></pre> <p>The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.fusestatic","title":"fusestatic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fusestatic: Optional[bool] = None\n</code></pre> <p>This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless</p> <ul> <li>They are referenced by another element in the model.</li> <li>They contain a site which is referenced by a force or torque sensor.</li> </ul> <p>This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.inertiafromgeom","title":"inertiafromgeom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiafromgeom: Optional[InertiaFromGeom] = None\n</code></pre> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.inertiagrouprange","title":"inertiagrouprange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiagrouprange: Optional[InertiaGroupRange] = None\n</code></pre> <p>This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.meshdir","title":"meshdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meshdir: Optional[str] = None\n</code></pre> <p>This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.saveinertial","title":"saveinertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>saveinertial: Optional[bool] = None\n</code></pre> <p>If set to \"true\", the compiler will save explicit inertial clauses for all bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.settotalmass","title":"settotalmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>settotalmass: Optional[float] = None\n</code></pre> <p>If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.strippath","title":"strippath  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>strippath: Optional[bool] = None\n</code></pre> <p>When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.texturedir","title":"texturedir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texturedir: Optional[str] = None\n</code></pre> <p>This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.usethread","title":"usethread  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>usethread: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Compiler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option_attr\\flag.py</code> Python<pre><code>class Flag(XMLModel):\n    \"\"\"This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.\"\"\"\n\n    tag = \"flag\"\n\n    attributes = (\n        \"constraint\",\n        \"equality\",\n        \"frictionloss\",\n        \"limit\",\n        \"contact\",\n        \"spring\",\n        \"damping\",\n        \"gravity\",\n        \"clampctrl\",\n        \"warmstart\",\n        \"filterparent\",\n        \"actuation\",\n        \"refsafe\",\n        \"sensor\",\n        \"midphase\",\n        \"eulerdamp\",\n        \"autoreset\",\n        \"nativeccd\",\n        \"island\",\n        \"override\",\n        \"energy\",\n        \"fwdinv\",\n        \"invdiscrete\",\n        \"multiccd\",\n        \"sleep\",\n    )\n\n    constraint: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.\"\"\"\n    equality: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to equality constraints.\"\"\"\n    frictionloss: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to friction loss constraints.\"\"\"\n    limit: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to joint and tendon limit constraints.\"\"\"\n    contact: Optional[EnableDisable] = None\n    \"\"\"This flag disables collision detection and all standard computations related to contact constraints.\"\"\"\n    spring: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    damping: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    gravity: Optional[EnableDisable] = None\n    \"\"\"This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.\"\"\"\n    clampctrl: Optional[EnableDisable] = None\n    \"\"\"This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.\"\"\"\n    warmstart: Optional[EnableDisable] = None\n    \"\"\"This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.\"\"\"\n    filterparent: Optional[EnableDisable] = None\n    \"\"\"This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.\"\"\"\n    actuation: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.\"\"\"\n    refsafe: Optional[EnableDisable] = None\n    \"\"\"This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.\"\"\"\n    sensor: Optional[EnableDisable] = None\n    \"\"\"This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.\"\"\"\n    midphase: Optional[EnableDisable] = None\n    \"\"\"This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.\"\"\"\n    nativeccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.\"\"\"\n    island: Optional[EnableDisable] = None\n    \"\"\"This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.\"\"\"\n    eulerdamp: Optional[EnableDisable] = None\n    \"\"\"This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.\"\"\"\n    autoreset: Optional[EnableDisable] = None\n    \"\"\"This flag disables the automatic resetting of the simulation state when numerical issues are detected.\"\"\"\n    override: Optional[EnableDisable] = None\n    \"\"\"This flag enables the Contact override mechanism.\"\"\"\n    energy: Optional[EnableDisable] = None\n    \"\"\"This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.\n\n    The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.\"\"\"\n    fwdinv: Optional[EnableDisable] = None\n    \"\"\"This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.\"\"\"\n    invdiscrete: Optional[EnableDisable] = None\n    \"\"\"This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.\"\"\"\n    multiccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.\"\"\"\n    sleep: Optional[EnableDisable] = None\n    \"\"\"This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[EnableDisable] = None\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\free_joint.py</code> Python<pre><code>class FreeJoint(XMLModel):\n    \"\"\"This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for\n\n    ``` xml\n    &lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n    ```\n\n    While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.\"\"\"\n\n    tag = \"joint\"\n    type: ClassVar[JointType] = JointType.FREE\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    align: Optional[Align] = None\n    \"\"\"When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.\n\n    Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.\n\n    Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Optional[Align] = None\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\hfield.py</code> Python<pre><code>class HField(XMLModel):\n    \"\"\"This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:\n\n    1. The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.\n\n    2. The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4*(2+nrow*ncol) bytes:\n        ```\n        (int32)   nrow\n        (int32)   ncol\n        (float32) data[nrow*ncol]\n        ```\n    3. The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.\n\n    Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.\n\n    The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.\n\n    For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.\n    \"\"\"\n\n    tag = \"hfield\"\n\n    attributes = (\n        \"name\",\n        \"content_type\",\n        \"file\",\n        \"nrow\",\n        \"ncol\",\n        \"elevation\",\n        \"size\",\n    )\n\n    name: Optional[str] = None\n    \"\"\"Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.\"\"\"\n    nrow: Optional[int] = None\n    \"\"\"This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.\"\"\"\n    ncol: Optional[int] = None\n    \"\"\"This attribute specifies the number of columns in the elevation data matrix.\"\"\"\n    elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None  # type: ignore\n    \"\"\"This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.\"\"\"\n    size: Vec4\n    \"\"\"The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.\"\"\"\n\n    @model_validator(mode=\"before\")\n    def coerce_elevation(self) -&gt; HField:\n        elev = self.elevation\n        nrow = self.nrow\n        ncol = self.ncol\n\n        if elev is None:\n            return self\n\n        elev = np.asarray(elev, dtype=np.float64)\n\n        if nrow is not None and ncol is not None:\n            expected_len = nrow * ncol\n            if elev.size != expected_len:\n                raise ValueError(\n                    f\"Elevation length {elev.size} does not match nrow*ncol={expected_len}\"\n                )\n\n        # Normalize\n        min_val = elev.min()\n        max_val = elev.max()\n        if max_val &gt; min_val:\n            elev = (elev - min_val) / (max_val - min_val)\n\n        self.elevation = elev\n        return self\n\n    @field_validator(\"nrow\", \"ncol\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v is not None and v &lt; 0:\n            raise ValueError(\"nrow and ncol must be non-negative\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: Optional[int] = None\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: Optional[int] = None\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\inertial.py</code> Python<pre><code>class Inertial(XMLModel):\n    \"\"\"This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.\"\"\"\n\n    tag = \"inertial\"\n\n    attributes = (\n        \"pos\",\n        \"quat\",\n        \"mass\",\n        \"diaginertia\",\n        \"axisangle\",\n        \"xyaxes\",\n        \"zaxis\",\n        \"euler\",\n        \"fullinertia\",\n    )\n    __exclusive_groups__ = (frame_orientations, (\"diaginertia\", \"fullinertia\"))\n\n    pos: Vec3\n    \"\"\"Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.\"\"\"\n    quat: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    axisangle: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    mass: float\n    \"\"\"Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.\"\"\"\n    diaginertia: Optional[Vec3] = None\n    \"\"\"Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.\"\"\"\n    fullinertia: Optional[Vec6] = None\n    \"\"\"Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.\"\"\"\n\n    @property\n    def using_diag(self) -&gt; bool:\n        if self.diaginertia is not None and self.fullinertia is None:\n            return True\n        if self.diaginertia is None and self.fullinertia is not None:\n            return False\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Neither diaginertia nor fullinertia were specified.\")\n        raise ValueError(\"Both diaginertia and fullinertia were specified (invalid).\")\n\n    @property\n    def inertia_matrix(self) -&gt; np.ndarray:\n        if self.using_diag:\n            d = self.diaginertia\n            assert d is not None\n            return np.diag(np.asarray(d))\n\n        f = np.asarray(self.fullinertia)\n        assert f is not None\n\n        return np.array(\n            [\n                [f[0], f[3], f[4]],\n                [f[3], f[1], f[5]],\n                [f[4], f[5], f[2]],\n            ],\n            dtype=np.float64,\n        )\n\n    @property\n    def i_xx(self) -&gt; float:\n        return float(self.inertia_matrix[0, 0])\n\n    @property\n    def i_yy(self) -&gt; float:\n        return float(self.inertia_matrix[1, 1])\n\n    @property\n    def i_zz(self) -&gt; float:\n        return float(self.inertia_matrix[2, 2])\n\n    @property\n    def i_xy(self) -&gt; float:\n        return float(self.inertia_matrix[0, 1])\n\n    @property\n    def i_xz(self) -&gt; float:\n        return float(self.inertia_matrix[0, 2])\n\n    @property\n    def i_yz(self) -&gt; float:\n        return float(self.inertia_matrix[1, 2])\n\n    @property\n    def i_yx(self) -&gt; float:\n        return self.i_xy\n\n    @property\n    def i_zx(self) -&gt; float:\n        return self.i_xz\n\n    @property\n    def i_zy(self) -&gt; float:\n        return self.i_yz\n\n    @field_validator(\"mass\")\n    @classmethod\n    def validate_mass(cls, v: float) -&gt; float:\n        if not np.isfinite(v):\n            raise ValueError(\"mass must be finite\")\n        if v &lt; 0:\n            raise ValueError(\"mass must be non-negative\")\n        return v\n\n    @field_validator(\"diaginertia\")\n    @classmethod\n    def validate_diaginertia(cls, v: Vec3 | None) -&gt; Vec3 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (3,):\n            raise ValueError(\"diaginertia must be length 3\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"diaginertia must be finite\")\n\n        if np.any(arr &lt;= 0):\n            raise ValueError(\"diaginertia values must be positive\")\n\n        return arr\n\n    @field_validator(\"fullinertia\")\n    @classmethod\n    def validate_fullinertia(cls, v: Vec6 | None) -&gt; Vec6 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (6,):\n            raise ValueError(\"fullinertia must have length 6\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"fullinertia must be finite\")\n\n        return arr\n\n    @model_validator(mode=\"after\")\n    def validate_inertia_physics(self) -&gt; Inertial:\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Either diaginertia or fullinertia must be specified\")\n\n        if self.diaginertia is not None and self.fullinertia is not None:\n            raise ValueError(\"Only one of diaginertia or fullinertia may be specified\")\n\n        M = self.inertia_matrix\n\n        # Symmetry sanity check (numerical)\n        if not np.allclose(M, M.T, atol=1e-12):\n            raise ValueError(\"Inertia matrix is not symmetric\")\n\n        # Eigenvalue check (MuJoCo uses this too)\n        eigvals = np.linalg.eigvalsh(M)\n\n        if np.any(eigvals &lt;= 0):\n            raise ValueError(\n                f\"Inertia matrix must be positive definite. Eigenvalues: {eigvals}\"\n            )\n\n        return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Optional[Vec3] = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Optional[Vec6] = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\joint.py</code> Python<pre><code>class Joint(XMLModel):\n    \"\"\"This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.\"\"\"\n\n    tag = \"joint\"\n\n    attributes = ()\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    type: Optional[JointType] = None\n    \"\"\"Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.\n\n    The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.\n\n    The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.\n\n    The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    pos: Optional[Vec3] = None\n    \"\"\"Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.\"\"\"\n    axis: Optional[Vec3] = None\n    \"\"\"This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.\"\"\"\n    springdamper: Optional[Vec2] = None\n    \"\"\"When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.\"\"\"\n    solreflimit: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solimplimit: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solreffriction: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    solimpfriction: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    stiffness: Optional[float] = None\n    \"\"\"Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.\"\"\"\n    range: Optional[Vec2] = None\n    \"\"\"The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.\n    Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.\"\"\"\n    limited: Optional[Limited] = None\n    \"\"\"This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.\"\"\"\n    actuatorfrcrange: Optional[Vec2] = None\n    \"\"\"Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    The compiler expects the first value to be smaller than the second value.\n    Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".\"\"\"\n    actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n    \"\"\"This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.\"\"\"\n    actuatorgravcomp: Optional[bool] = None\n    \"\"\"If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.\"\"\"\n    margin: Optional[float] = None\n    \"\"\"The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.\"\"\"\n    ref: Optional[float] = None\n    \"\"\"The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.\"\"\"\n    springref: Optional[float] = None\n    \"\"\"The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.\"\"\"\n    armature: Optional[float] = None\n    \"\"\"Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.\n\n    Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.\"\"\"\n    damping: Optional[float] = None\n    \"\"\"Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.\"\"\"\n    frictionloss: Optional[float] = None\n    \"\"\"Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Optional[Vec2] = None\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: Optional[bool] = None\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: Optional[float] = None\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[float] = None\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[float] = None\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Optional[Limited] = None\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: Optional[float] = None\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Optional[Vec2] = None\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: Optional[float] = None\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Optional[Vec2] = None\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: Optional[float] = None\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: Optional[float] = None\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[JointType] = None\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material_attr\\layer.py</code> Python<pre><code>class Layer(XMLModel):\n    \"\"\"If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.\"\"\"\n\n    tag = \"layer\"\n\n    attributes = (\n        \"texture\",\n        \"role\",\n    )\n\n    texture: str\n    \"\"\"Name of the texture, like the texture attribute.\"\"\"\n    role: str\n    \"\"\"Role of the texture. The valid values, expected number of channels, and the role semantics are:\n\n    | value     | channels | description                                                  |\n    |:----------|:---------|:-------------------------------------------------------------|\n    | rgb       | 3        | base color / albedo [red, green, blue]                       |\n    | normal    | 3        | bump map (surface normals)                                   |\n    | occlusion | 1        | ambient occlusion                                            |\n    | roughness | 1        | roughness                                                    |\n    | metallic  | 1        | metallicity                                                  |\n    | opacity   | 1        | opacity (alpha channel)                                      |\n    | emissive  | 4        | RGB light emmision intensity, exposure weight in 4th channel |\n    | orm       | 3        | packed 3 channel [occlusion, roughness, metallic]            |\n    | rgba      | 4        | packed 4 channel [red, green, blue, alpha]                   |\n    \"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: str\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: str\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler_attr\\lengthrange.py</code> Python<pre><code>class LengthRange(XMLModel):\n    \"\"\"This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".\"\"\"\n\n    attributes = (\n        \"mode\",\n        \"useexisting\",\n        \"uselimit\",\n        \"accel\",\n        \"maxforce\",\n        \"timeconst\",\n        \"timestep\",\n        \"inttotal\",\n        \"interval\",\n        \"tolrange\",\n    )\n\n    mode: Optional[Mode] = None\n    \"\"\"Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.\"\"\"\n    useexisting: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.\"\"\"\n    uselimit: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.\"\"\"\n    accel: Optional[float] = None\n    \"\"\"This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.\"\"\"\n    maxforce: Optional[float] = None\n    \"\"\"The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.\"\"\"\n    timeconst: Optional[float] = None\n    \"\"\"The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.\"\"\"\n    timestep: Optional[float] = None\n    \"\"\"The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.\"\"\"\n    inttotal: Optional[float] = None\n    \"\"\"The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.\"\"\"\n    interval: Optional[float] = None\n    \"\"\"The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.\"\"\"\n    tolrange: Optional[float] = None\n    \"\"\"This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: Optional[float] = None\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: Optional[float] = None\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: Optional[float] = None\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: Optional[float] = None\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: Optional[Mode] = None\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: Optional[float] = None\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: Optional[float] = None\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material.py</code> Python<pre><code>class Material(XMLModel):\n    \"\"\"This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.\"\"\"\n\n    tag = \"material\"\n\n    attributes = (\n        \"name\",\n        \"class_\",\n        \"texture\",\n        \"texrepeat\",\n        \"texuniform\",\n        \"emission\",\n        \"specular\",\n        \"shininess\",\n        \"reflectance\",\n        \"metallic\",\n        \"roughness\",\n        \"rgba\",\n    )\n\n    children = (\"layers\",)\n\n    name: str\n    \"\"\"Name of the material, used for referencing.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    texture: Optional[str] = None\n    \"\"\"If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.\"\"\"\n    texrepeat: Optional[Vec2] = None\n    \"\"\"This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.\"\"\"\n    texuniform: Optional[bool] = None\n    \"\"\"For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.\"\"\"\n    emission: Optional[float] = None\n    \"\"\"Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.\"\"\"\n    specular: Optional[float] = None\n    \"\"\"Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].\"\"\"\n    shininess: Optional[float] = None\n    \"\"\"Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.\"\"\"\n    reflectance: Optional[float] = None\n    \"\"\"This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.\"\"\"\n    metallic: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.\"\"\"\n    roughness: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.\"\"\"\n    rgba: Optional[Vec4] = None\n    \"\"\"Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.\"\"\"\n\n    layers: List[Layer] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: Optional[float] = None\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: Optional[float] = None\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Optional[Vec4] = None\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: Optional[float] = None\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Optional[float] = None\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Optional[Vec2] = None\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: Optional[str] = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: Optional[bool] = None\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class Mesh(XMLModel):\n    \"\"\"This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.\"\"\"\n\n    tag = \"mesh\"\n\n    attributes = _mesh_attr\n\n    name: Optional[str] = None\n    \"\"\"Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes (only scale in this case).\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.\"\"\"\n    scale: Optional[Vec3] = None\n    \"\"\"This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.\"\"\"\n    inertia: Optional[Inertia] = None\n    \"\"\"This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.\n\n    * convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.\n    * exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.\n    * legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.\n    * shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.\n    \"\"\"\n    smoothnormal: Optional[bool] = None\n    \"\"\"Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.\"\"\"\n    maxhullvert: Optional[int] = None\n    \"\"\"Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.\"\"\"\n    vertex: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.\"\"\"\n    normal: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.\"\"\"\n    texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n    \"\"\"Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.\"\"\"\n    face: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.\"\"\"\n    refpos: Optional[Vec3] = None\n    \"\"\"Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.\"\"\"\n    refquat: Optional[Vec4] = None\n    \"\"\"Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.\"\"\"\n    material: Optional[str] = None\n    \"\"\"Fallback material for mesh geoms that do not specify their own material.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone","title":"MeshCone","text":"<p>               Bases: <code>Mesh</code></p> <p>Cone mesh from top and bottom polygons.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshCone(Mesh):\n    \"\"\"\n    Cone mesh from top and bottom polygons.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"cone\"\n\n    attributes = _mesh_attr + (\"builtin\", \"nvert\", \"radius\")\n\n    nvert: int\n    \"\"\"integer &gt;= 3: The number of vertices in the polygon.\"\"\"\n    radius: float\n    \"\"\"real in [0, 1]: The radius of the top face.\"\"\"\n\n    @field_validator(\"nvert\")\n    @classmethod\n    def validate_nvert(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"nvert must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"radius must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.nvert","title":"nvert  <code>instance-attribute</code>","text":"Python<pre><code>nvert: int\n</code></pre> <p>integer &gt;= 3: The number of vertices in the polygon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in [0, 1]: The radius of the top face.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshCone.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere","title":"MeshHemisphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Quad-projected hemisphere.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshHemisphere(Mesh):\n    \"\"\"\n    Quad-projected hemisphere.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"hemisphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\")\n\n    resolution: int\n    \"\"\"integer in [0-10]: Equator discretization of one hemisphere quadrant.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 10:\n            raise ValueError(\"resolution must be in [0, 10]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer in [0-10]: Equator discretization of one hemisphere quadrant.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshHemisphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate","title":"MeshPlate","text":"<p>               Bases: <code>Mesh</code></p> <p>Rectangular plate mesh.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshPlate(Mesh):\n    \"\"\"\n    Rectangular plate mesh.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"plate\"\n\n    attributes = _mesh_attr + (\"builtin\", \"res_x\", \"res_y\")\n\n    res_x: int\n    \"\"\"integer &gt; 0: Horizontal resolution of the plate.\"\"\"\n    res_y: int\n    \"\"\"integer &gt; 0: Vertical resolution of the plate.\"\"\"\n\n    @field_validator(\"res_x\", \"res_y\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.res_x","title":"res_x  <code>instance-attribute</code>","text":"Python<pre><code>res_x: int\n</code></pre> <p>integer &gt; 0: Horizontal resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.res_y","title":"res_y  <code>instance-attribute</code>","text":"Python<pre><code>res_y: int\n</code></pre> <p>integer &gt; 0: Vertical resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshPlate.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere","title":"MeshSphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Repeated subdivisions of a unit icosahedron (\"icosphere\").</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSphere(Mesh):\n    \"\"\"\n    Repeated subdivisions of a unit icosahedron (\"icosphere\").\n    \"\"\"\n\n    builtin: ClassVar[str] = \"sphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"subdivision\")\n\n    subdivision: int\n    \"\"\"integer in [0-4]: The number of subdivisions to apply to icosahedron faces.\"\"\"\n\n    @field_validator(\"subdivision\")\n    @classmethod\n    def validate_subdivision(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 4:\n            raise ValueError(\"subdivision must be in [0, 4]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.subdivision","title":"subdivision  <code>instance-attribute</code>","text":"Python<pre><code>subdivision: int\n</code></pre> <p>integer in [0-4]: The number of subdivisions to apply to icosahedron faces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere","title":"MeshSupersphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Supersphere (superellipsoid) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSupersphere(Mesh):\n    \"\"\"\n    Supersphere (superellipsoid) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"supersphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"e\", \"n\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Longitude and latitude discretization.\"\"\"\n    e: float\n    \"\"\"real &gt;= 0: The 'east-west' exponent.\"\"\"\n    n: float\n    \"\"\"real &gt;= 0: The 'north-south' exponent.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"e\", \"n\")\n    @classmethod\n    def validate_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.e","title":"e  <code>instance-attribute</code>","text":"Python<pre><code>e: float\n</code></pre> <p>real &gt;= 0: The 'east-west' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.n","title":"n  <code>instance-attribute</code>","text":"Python<pre><code>n: float\n</code></pre> <p>real &gt;= 0: The 'north-south' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Longitude and latitude discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshSupersphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus","title":"MeshTorus","text":"<p>               Bases: <code>Mesh</code></p> <p>Supertorus (generalized torus) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshTorus(Mesh):\n    \"\"\"\n    Supertorus (generalized torus) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"torus\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"radius\", \"s\", \"t\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Discretization of both circumferences.\"\"\"\n    radius: float\n    \"\"\"real in (0, 1]: Minor radius of the torus.\"\"\"\n    s: float\n    \"\"\"real &gt; 0: The 'squareness' of minor sections.\"\"\"\n    t: float\n    \"\"\"real &gt; 0: The 'squareness' of major sections.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 1:\n            raise ValueError(\"radius must be in (0, 1]\")\n        return v\n\n    @field_validator(\"s\", \"t\")\n    @classmethod\n    def validate_positive(cls, v: float) -&gt; float:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in (0, 1]: Minor radius of the torus.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Discretization of both circumferences.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.s","title":"s  <code>instance-attribute</code>","text":"Python<pre><code>s: float\n</code></pre> <p>real &gt; 0: The 'squareness' of minor sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.t","title":"t  <code>instance-attribute</code>","text":"Python<pre><code>t: float\n</code></pre> <p>real &gt; 0: The 'squareness' of major sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshTorus.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge","title":"MeshWedge","text":"<p>               Bases: <code>Mesh</code></p> <p>Slice of a unit spherical shell.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshWedge(Mesh):\n    \"\"\"\n    Slice of a unit spherical shell.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"wedge\"\n\n    attributes = _mesh_attr + (\n        \"builtin\",\n        \"res_phi\",\n        \"res_theta\",\n        \"fov_phi\",\n        \"fov_theta\",\n        \"gamma\",\n    )\n\n    res_phi: int\n    \"\"\"integer &gt;= 0: Vertical resolution of the slice.\"\"\"\n    res_theta: int\n    \"\"\"integer &gt;= 0: Horizontal resolution of the slice.\"\"\"\n    fov_phi: float\n    \"\"\"real in (0, 180]: Horizontal field of view (degrees).\"\"\"\n    fov_theta: float\n    \"\"\"real in (0, 90): Vertical field of view (degrees).\"\"\"\n    gamma: float\n    \"\"\"real in [0, 1]: Foveal deformation of the discretization.\"\"\"\n\n    @field_validator(\"res_phi\", \"res_theta\")\n    @classmethod\n    def validate_non_negative(cls, v: int) -&gt; int:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n\n    @field_validator(\"fov_phi\")\n    @classmethod\n    def validate_fov_phi(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 180:\n            raise ValueError(\"fov_phi must be in (0, 180]\")\n        return v\n\n    @field_validator(\"fov_theta\")\n    @classmethod\n    def validate_fov_theta(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt; 90:\n            raise ValueError(\"fov_theta must be in (0, 90)\")\n        return v\n\n    @field_validator(\"gamma\")\n    @classmethod\n    def validate_gamma(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"gamma must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.fov_phi","title":"fov_phi  <code>instance-attribute</code>","text":"Python<pre><code>fov_phi: float\n</code></pre> <p>real in (0, 180]: Horizontal field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.fov_theta","title":"fov_theta  <code>instance-attribute</code>","text":"Python<pre><code>fov_theta: float\n</code></pre> <p>real in (0, 90): Vertical field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.gamma","title":"gamma  <code>instance-attribute</code>","text":"Python<pre><code>gamma: float\n</code></pre> <p>real in [0, 1]: Foveal deformation of the discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.res_phi","title":"res_phi  <code>instance-attribute</code>","text":"Python<pre><code>res_phi: int\n</code></pre> <p>integer &gt;= 0: Vertical resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.res_theta","title":"res_theta  <code>instance-attribute</code>","text":"Python<pre><code>res_theta: int\n</code></pre> <p>integer &gt;= 0: Horizontal resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.MeshWedge.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\model.py</code> Python<pre><code>class Model(XMLModel):\n    \"\"\"This element specifies other MJCF models which may be used for attachment in the current model.\"\"\"\n\n    tag = \"model\"\n\n    attributes = (\"name\", \"file\", \"content_type\")\n\n    name: Optional[str] = None\n    \"\"\"Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.\"\"\"\n    file: Path\n    \"\"\"The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"The file type to be loaded into a model. Currently only text/xml is supported.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option","title":"Option","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option.py</code> Python<pre><code>class Option(XMLModel):\n    \"\"\"This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.\"\"\"\n\n    tag = \"option\"\n\n    attributes = (\n        \"timestep\",\n        \"impratio\",\n        \"tolerance\",\n        \"ls_tolerance\",\n        \"noslip_tolerance\",\n        \"ccd_tolerance\",\n        \"sleep_tolerance\",\n        \"gravity\",\n        \"wind\",\n        \"magnetic\",\n        \"density\",\n        \"viscosity\",\n        \"o_margin\",\n        \"o_solref\",\n        \"o_solimp\",\n        \"o_friction\",\n        \"integrator\",\n        \"cone\",\n        \"jacobian\",\n        \"solver\",\n        \"iterations\",\n        \"ls_iterations\",\n        \"noslip_iterations\",\n        \"ccd_iterations\",\n        \"sdf_iterations\",\n        \"sdf_initpoints\",\n        \"actuatorgroupdisable\",\n    )\n    children = (\"flag\",)\n\n    timestep: Optional[float] = None\n    \"\"\"Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.\"\"\"\n    impratio: Optional[float] = None\n    \"\"\"This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.\"\"\"\n    gravity: Optional[Vec3] = None\n    \"\"\"Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.\"\"\"\n    wind: Optional[Vec3] = None\n    \"\"\"Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.\"\"\"\n    magnetic: Optional[Vec3] = None\n    \"\"\"Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.\"\"\"\n    density: Optional[float] = None\n    \"\"\"Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.\"\"\"\n    viscosity: Optional[float] = None\n    \"\"\"Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.\"\"\"\n    o_margin: Optional[float] = None\n    \"\"\"This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.\"\"\"\n    o_solref: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_solimp: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_friction: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    integrator: Optional[Integrator] = None\n    \"\"\"This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.\"\"\"\n    cone: Optional[Cone] = None\n    \"\"\"The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.\"\"\"\n    jacobian: Optional[Jacobian] = None\n    \"\"\"The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.\"\"\"\n    solver: Optional[Solver] = None\n    \"\"\"This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.\"\"\"\n    iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.\"\"\"\n    tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.\"\"\"\n    ls_iterations: Optional[int] = None\n    \"\"\"Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.\"\"\"\n    ls_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the linesearch algorithm.\"\"\"\n    noslip_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.\"\"\"\n    noslip_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the Noslip solver.\"\"\"\n    ccd_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.\"\"\"\n    ccd_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the convex collision algorithm.\"\"\"\n    sleep_tolerance: Optional[float] = None\n    \"\"\"Velocity tolerance below which sleeping is allowed.\"\"\"\n    sdf_iterations: Optional[int] = None\n    \"\"\"Number of iterations used for Signed Distance Field collisions (per initial point).\"\"\"\n    sdf_initpoints: Optional[int] = None\n    \"\"\"Number of starting points used for finding contacts with Signed Distance Field collisions.\"\"\"\n    actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n    \"\"\"List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.\"\"\"\n\n    flag: Optional[Flag] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.actuatorgroupdisable","title":"actuatorgroupdisable  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n</code></pre> <p>List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ccd_iterations","title":"ccd_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ccd_tolerance","title":"ccd_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the convex collision algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.cone","title":"cone  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cone: Optional[Cone] = None\n</code></pre> <p>The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: Optional[float] = None\n</code></pre> <p>Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[Vec3] = None\n</code></pre> <p>Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.impratio","title":"impratio  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>impratio: Optional[float] = None\n</code></pre> <p>This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.integrator","title":"integrator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>integrator: Optional[Integrator] = None\n</code></pre> <p>This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.iterations","title":"iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.jacobian","title":"jacobian  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>jacobian: Optional[Jacobian] = None\n</code></pre> <p>The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ls_iterations","title":"ls_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.ls_tolerance","title":"ls_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the linesearch algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.magnetic","title":"magnetic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>magnetic: Optional[Vec3] = None\n</code></pre> <p>Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.noslip_iterations","title":"noslip_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.noslip_tolerance","title":"noslip_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the Noslip solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_friction","title":"o_friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_friction: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_margin","title":"o_margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_margin: Optional[float] = None\n</code></pre> <p>This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_solimp","title":"o_solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solimp: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.o_solref","title":"o_solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solref: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.sdf_initpoints","title":"sdf_initpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_initpoints: Optional[int] = None\n</code></pre> <p>Number of starting points used for finding contacts with Signed Distance Field collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.sdf_iterations","title":"sdf_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_iterations: Optional[int] = None\n</code></pre> <p>Number of iterations used for Signed Distance Field collisions (per initial point).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.sleep_tolerance","title":"sleep_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep_tolerance: Optional[float] = None\n</code></pre> <p>Velocity tolerance below which sleeping is allowed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.solver","title":"solver  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solver: Optional[Solver] = None\n</code></pre> <p>This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.viscosity","title":"viscosity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>viscosity: Optional[float] = None\n</code></pre> <p>Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>wind: Optional[Vec3] = None\n</code></pre> <p>Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Option.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh_attr\\plugin.py</code> Python<pre><code>class Plugin(XMLModel):\n    \"\"\"Associate this mesh with an engine plugin. Either plugin or instance are required.\"\"\"\n\n    tag = \"plugin\"\n\n    attributes = (\"plugin\", \"instance\")\n\n    plugin: Optional[str] = None\n    \"\"\"Plugin identifier, used for implicit plugin instantiation.\"\"\"\n    instance: Optional[str] = None  # TODO I think this was implemented poorly\n    \"\"\"Instance name, used for explicit plugin instantiation.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: Optional[str] = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Optional[str] = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size","title":"Size","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\size.py</code> Python<pre><code>class Size(XMLModel):\n    \"\"\"This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.\"\"\"\n\n    tag = \"size\"\n\n    attributes = (\n        \"memory\",\n        \"njmax\",\n        \"nconmax\",\n        \"nstack\",\n        \"nuserdata\",\n        \"nkey\",\n        \"nuser_body\",\n        \"nuser_jnt\",\n        \"nuser_geom\",\n        \"nuser_site\",\n        \"nuser_cam\",\n        \"nuser_tendon\",\n        \"nuser_actuator\",\n        \"nuser_sensor\",\n    )\n\n    memory: Optional[str] = None\n    \"\"\"This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.\"\"\"\n    njmax: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.\"\"\"\n    nconmax: Optional[int] = None\n    \"\"\"This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.\"\"\"\n    nstack: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.\"\"\"\n    nuserdata: Optional[int] = None\n    \"\"\"The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.\"\"\"\n    nkey: Optional[int] = None\n    \"\"\"The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.\"\"\"\n    nuser_body: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.\"\"\"\n    nuser_jnt: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each joint.\"\"\"\n    nuser_geom: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each geom.\"\"\"\n    nuser_site: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each site.\"\"\"\n    nuser_cam: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each camera.\"\"\"\n    nuser_tendon: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each tendon.\"\"\"\n    nuser_actuator: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each actuator.\"\"\"\n    nuser_sensor: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each sensor.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>memory: Optional[str] = None\n</code></pre> <p>This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nconmax","title":"nconmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nconmax: Optional[int] = None\n</code></pre> <p>This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.njmax","title":"njmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>njmax: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nkey","title":"nkey  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nkey: Optional[int] = None\n</code></pre> <p>The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nstack","title":"nstack  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nstack: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_actuator","title":"nuser_actuator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_actuator: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each actuator.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_body","title":"nuser_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_body: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_cam","title":"nuser_cam  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_cam: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_geom","title":"nuser_geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_geom: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_jnt","title":"nuser_jnt  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_jnt: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_sensor","title":"nuser_sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_sensor: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each sensor.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_site","title":"nuser_site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_site: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuser_tendon","title":"nuser_tendon  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_tendon: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each tendon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.nuserdata","title":"nuserdata  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuserdata: Optional[int] = None\n</code></pre> <p>The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Size.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic","title":"Statistic","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\statistic.py</code> Python<pre><code>class Statistic(XMLModel):\n    \"\"\"This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.\"\"\"\n\n    tag = \"statistic\"\n\n    attributes = (\n        \"meaninertia\",\n        \"meanmass\",\n        \"meansize\",\n        \"extent\",\n        \"center\",\n    )\n\n    meanmass: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.\"\"\"\n    meaninertia: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.\"\"\"\n    meansize: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.\"\"\"\n    extent: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.\"\"\"\n    center: Optional[Vec3] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.center","title":"center  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>center: Optional[Vec3] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>extent: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.meaninertia","title":"meaninertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meaninertia: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.meanmass","title":"meanmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meanmass: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.meansize","title":"meansize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meansize: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Statistic.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\texture.py</code> Python<pre><code>class Texture(XMLModel):\n    \"\"\"This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.\n\n    The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.\n\n    Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.\n\n    The custom MuJoCo format is assumed to be a binary file containing the following data:\n    ```\n    (int32)   width\n    (int32)   height\n    (byte)    rgb_data[3*width*height]\n    ```\n    \"\"\"\n\n    tag = \"texture\"\n\n    attributes = _texture_attr\n\n    name: Optional[str] = None\n    \"\"\"As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.\"\"\"\n    type: Optional[Type] = None\n    \"\"\"This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:\n\n    The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:\n\n    1. Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.\n    2. Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.\n    3. Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.\n    4. Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.\n\n    The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.\n\n    The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.\"\"\"\n    colorspace: Optional[ColorSpace] = None\n    \"\"\"This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.\"\"\"\n    gridsize: Optional[Tuple[int, int]] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.\"\"\"\n    gridlayout: Optional[str] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.\"\"\"\n    fileright: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileleft: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileup: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filedown: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filefront: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileback: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: Optional[ColorSpace] = None\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: Optional[str] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: Optional[Tuple[int, int]] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[Type] = None\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody","title":"WorldBody","text":"<p>               Bases: <code>Body</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class WorldBody(Body):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"worldbody\"\n\n    attributes = ()\n    children = _world_body_children\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/#mujoco_mojo.mjcf.mujoco_attr.WorldBody.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/","title":"asset","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset","title":"Asset","text":"<p>               Bases: <code>XMLModel</code></p> <p>This is a grouping element for defining assets. It does not have attributes. Assets are created in the model so that they can be referenced from other model elements; recall the discussion of Assets in the Overview chapter. Assets opened from a file can be identified in two different ways: filename extensions or the content_type attribute. MuJoCo will attempt to open a file specified by the content type provided, and only defaults to the filename extension if no content_type attribute is specified. The content type is ignored if the asset isn't loaded from a file.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset.py</code> Python<pre><code>class Asset(XMLModel):\n    \"\"\"This is a grouping element for defining assets. It does not have attributes. Assets are created in the model so that they can be referenced from other model elements; recall the discussion of Assets in the Overview chapter. Assets opened from a file can be identified in two different ways: filename extensions or the content_type attribute. MuJoCo will attempt to open a file specified by the content type provided, and only defaults to the filename extension if no content_type attribute is specified. The content type is ignored if the asset isn't loaded from a file.\"\"\"\n\n    tag = \"asset\"\n\n    children = (\"meshes\", \"hfields\", \"skins\", \"textures\", \"materials\", \"models\")\n\n    meshes: Optional[List] = Field(default_factory=list)\n    hfields: Optional[List] = Field(default_factory=list)\n    skins: Optional[List] = Field(default_factory=list)\n    textures: Optional[List] = Field(default_factory=list)\n    materials: Optional[List] = Field(default_factory=list)\n    models: Optional[List] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset/#mujoco_mojo.mjcf.mujoco_attr.asset.Asset.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/","title":"body","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body","title":"Body","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class Body(XMLModel):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"body\"\n\n    attributes = _body_attr\n    children = _body_children\n    __exclusive_groups__ = (frame_orientations,)\n\n    name: Optional[str] = None\n    \"\"\"Name of the body.\"\"\"\n    childclass: Optional[str] = None\n    \"\"\"If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.\"\"\"\n    mocap: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.\"\"\"\n    pos: Optional[Vec3] = None\n    \"The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).\"\n    quat: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    axisangle: Optional[Vec4] = None\n    \"\"\"See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec6] = None\n    \"\"\"See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"See Frame orientations.\"\"\"\n    gravcomp: Optional[float] = None\n    \"\"\"Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.\"\"\"\n    sleep: Optional[Sleep] = None\n    \"\"\"Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:\n\n    * A tree which is affected by actuators is not allowed to sleep (overridable).\n    * Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).\n    * Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).\n    * flexes are not allowed to sleep (not overridable).\n    * All other trees are allowed to sleep (overridable).\n\n    The policies never and allowed constitute user overrides of the automatic compiler policy.\n\n    The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.\n\n    See implementation notes for more details.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters. Has length of `nbody_user`\"\"\"\n\n    inertial: Optional[float] = None  # TODO\n    joints: List[float] = Field(default_factory=list)  # TODO\n    freejoints: Optional[List[float]] = Field(default_factory=list)  # TODO\n    geoms: List[Geom] = Field(default_factory=list)\n    sites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    cameras: Optional[List[float]] = Field(default_factory=list)  # TODO\n    lights: Optional[List[float]] = Field(default_factory=list)  # TODO\n    composites: Optional[List[float]] = Field(default_factory=list)  # TODO\n    flexcomps: Optional[List[float]] = Field(default_factory=list)  # TODO\n    plugins: Optional[List[float]] = Field(default_factory=list)  # TODO\n    attaches: Optional[List[float]] = Field(default_factory=list)  # TODO\n    frames: Optional[List[float]] = Field(default_factory=list)  # TODO\n\n    bodies: List[Body] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.Body.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody","title":"WorldBody","text":"<p>               Bases: <code>Body</code></p> <p>This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body.py</code> Python<pre><code>class WorldBody(Body):\n    \"\"\"This element is used to construct the kinematic tree via nesting. The element worldbody is used for the top-level body, while the element body is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements inertial and joint, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as \"world\".\"\"\"\n\n    tag = \"worldbody\"\n\n    attributes = ()\n    children = _world_body_children\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.childclass","title":"childclass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>childclass: Optional[str] = None\n</code></pre> <p>If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body or frame with a childclass attribute is encountered along the chain of nested bodies and frames. Recall Default settings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.gravcomp","title":"gravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravcomp: Optional[float] = None\n</code></pre> <p>Gravity compensation force, specified as fraction of body weight. This attribute creates an upwards force applied to the body's center of mass, countering the force of gravity. As an example, a value of 1 creates an upward force equal to the body's weight and compensates for gravity exactly. Values greater than 1 will create a net upwards force or buoyancy effect.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.mocap","title":"mocap  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mocap: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_{pos,quat} at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the body.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>The 3D position of the body frame, in the parent coordinate frame. If undefined it defaults to (0,0,0).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec4] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[Sleep] = None\n</code></pre> <p>Sleep policy for the tree under this body. This attribute is only supported by moving bodies which are the root of a kinematic tree. For the default auto, the compiler will set the sleep policy as follows:</p> <ul> <li>A tree which is affected by actuators is not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which have non-zero stiffness and damping are not allowed to sleep (overridable).</li> <li>Trees which are connected by tendons which connect more than two trees are not allowed to sleep (not overridable).</li> <li>flexes are not allowed to sleep (not overridable).</li> <li>All other trees are allowed to sleep (overridable).</li> </ul> <p>The policies never and allowed constitute user overrides of the automatic compiler policy.</p> <p>The init sleep policy can only be specified by the user and means \"initialize this tree as asleep\". This policy is implemented in mj_resetData and mj_makeData and only applies to the default configuration. If a keyframe changes the configuration of (or assigns nonzero velocity to) a sleeping tree, it will be woken up. This policy is useful for very large models where waiting for the automatic sleeping mechanism to kick in can be expensive. Trees initialized as sleeping can be placed in unstable configurations like deep penetration or in mid-air, but will only move when woken up. Also note that this policy can fail. For example if a tree marked as sleep=\"init\" is in contact with a tree not marked as such (i.e., they are in the same island) then it is impossible to put the tree to sleep; such models will lead to a compilation error.</p> <p>See implementation notes for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters. Has length of <code>nbody_user</code></p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec6] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body/#mujoco_mojo.mjcf.mujoco_attr.body.WorldBody.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/","title":"compiler","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler","title":"Compiler","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler.py</code> Python<pre><code>class Compiler(XMLModel):\n    \"\"\"This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.\"\"\"\n\n    tag = \"compiler\"\n\n    attributes = (\n        \"autolimits\",\n        \"boundmass\",\n        \"boundinertia\",\n        \"settotalmass\",\n        \"balanceinertia\",\n        \"strippath\",\n        \"coordinate\",\n        \"angle\",\n        \"fitaabb\",\n        \"eulerseq\",\n        \"meshdir\",\n        \"texturedir\",\n        \"discardvisual\",\n        \"usethread\",\n        \"fusestatic\",\n        \"inertiafromgeom\",\n        \"inertiagrouprange\",\n        \"saveinertial\",\n        \"assetdir\",\n        \"alignfree\",\n    )\n    children = (\"lengthrange\",)\n\n    autolimits: Optional[bool] = None\n    \"\"\"This attribute affects the behavior of attributes such as \"limited\" (on &lt;body-joint&gt; or &lt;tendon&gt;), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on &lt;actuator&gt;). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.\"\"\"\n    boundmass: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.\"\"\"\n    boundinertia: Optional[float] = None\n    \"\"\"This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.\"\"\"\n    settotalmass: Optional[float] = None\n    \"\"\"If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.\"\"\"\n    balanceinertia: Optional[bool] = None\n    \"\"\"A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.\"\"\"\n    strippath: Optional[bool] = None\n    \"\"\"When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.\"\"\"\n    coordinate: Optional[Coordinate] = None\n    \"\"\"In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.\"\"\"\n    angle: Optional[Angle] = None\n    \"\"\"This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.\"\"\"\n    fitaabb: Optional[bool] = None\n    \"\"\"The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).\"\"\"\n    eulerseq: Optional[str] = None\n    \"\"\"This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.\"\"\"\n    meshdir: Optional[str] = None\n    \"\"\"This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.\"\"\"\n    texturedir: Optional[str] = None\n    \"\"\"This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.\"\"\"\n    assetdir: Optional[str] = None\n    \"\"\"This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.\"\"\"\n    discardvisual: Optional[bool] = None\n    \"\"\"This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.\n\n    * All materials are discarded.\n    * All textures are discarded.\n    * All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.\n    * All meshes which are not referenced by any geom (in particular those discarded above) are discarded.\n\n    The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.\n    \"\"\"\n    usethread: Optional[bool] = None\n    \"\"\"If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.\"\"\"\n    fusestatic: Optional[bool] = None\n    \"\"\"This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless\n\n    * They are referenced by another element in the model.\n    * They contain a site which is referenced by a force or torque sensor.\n\n    This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.\"\"\"\n    inertiafromgeom: Optional[InertiaFromGeom] = None\n    \"\"\"This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.\"\"\"\n    alignfree: Optional[bool] = None\n    \"\"\"This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.\"\"\"\n    inertiagrouprange: Optional[InertiaGroupRange] = None\n    \"\"\"This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.\"\"\"\n    saveinertial: Optional[bool] = None\n    \"\"\"If set to \"true\", the compiler will save explicit inertial clauses for all bodies.\"\"\"\n\n    lengthrange: Optional[LengthRange] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.alignfree","title":"alignfree  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>alignfree: Optional[bool] = None\n</code></pre> <p>This attribute toggles the default behaviour of an optimization that applies to bodies with a free joint and no child bodies. When true, the body frame and free joint will automatically be aligned with inertial frame, which leads to both faster and more stable simulation. See freejoint/align for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.angle","title":"angle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>angle: Optional[Angle] = None\n</code></pre> <p>This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to \"radian\" internally, regardless of the XML setting.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.assetdir","title":"assetdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>assetdir: Optional[str] = None\n</code></pre> <p>This attribute sets the values of both meshdir and texturedir above. Values in the latter attributes take precedence over assetdir.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.autolimits","title":"autolimits  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autolimits: Optional[bool] = None\n</code></pre> <p>This attribute affects the behavior of attributes such as \"limited\" (on  or ), \"forcelimited\", \"ctrllimited\", and \"actlimited\" (on ). If \"true\", these attributes are unnecessary and their value will be inferred from the presence of their corresponding \"range\" attribute. If \"false\", no such inference will happen: For a joint to be limited, both limited=\"true\" and range=\"min max\" must be specified. In this mode, it is an error to specify a range without a limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.balanceinertia","title":"balanceinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>balanceinertia: Optional[bool] = None\n</code></pre> <p>A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in a compile error. If this attribute is set to \"true\", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.boundinertia","title":"boundinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundinertia: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to boundmass above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.boundmass","title":"boundmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>boundmass: Optional[float] = None\n</code></pre> <p>This attribute imposes a lower bound on the mass of each body except for the world body. Setting this attribute to a value greater than 0 can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.coordinate","title":"coordinate  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>coordinate: Optional[Coordinate] = None\n</code></pre> <p>In previous versions, this attribute could be used to specify whether frame positions and orientations are expressed in local or global coordinates, but the \"global\" option has since been removed, and will cause an error to be generated. In order to convert older models which used the \"global\" option, load and save them in MuJoCo 2.3.3 or older.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.discardvisual","title":"discardvisual  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>discardvisual: Optional[bool] = None\n</code></pre> <p>This attribute instructs the compiler to discard all model elements which are purely visual and have no effect on the physics (with one exception, see below). This often enables smaller mjModel structs and faster simulation.</p> <ul> <li>All materials are discarded.</li> <li>All textures are discarded.</li> <li>All geoms with contype=conaffinity=0 are discarded, if they are not referenced in another MJCF element. If a discarded geom was used for inferring body inertia, an explicit inertial element is added to the body.</li> <li>All meshes which are not referenced by any geom (in particular those discarded above) are discarded.</li> </ul> <p>The resulting compiled model will have exactly the same dynamics as the original model. The only engine-level computation which might change is the output of raycasting computations, as used for example by rangefinder sensors, since raycasting reports distances to visual geoms. When visualizing models compiled with this flag, it is important to remember that collision geoms are often placed in a group which is invisible by default.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.eulerseq","title":"eulerseq  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerseq: Optional[str] = None\n</code></pre> <p>This attribute specifies the sequence of Euler rotations for all euler attributes of elements that have spatial frames, as explained in Frame orientations. This must be a string with exactly 3 characters from the set {x, y, z, X, Y, Z}. The character at position n determines the axis around which the n-th rotation is performed. Lower case letters denote axes that rotate with the frame (intrinsic), while upper case letters denote axes that remain fixed in the parent frame (extrinsic). The \"rpy\" convention used in URDF corresponds to \"XYZ\" in MJCF.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.fitaabb","title":"fitaabb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fitaabb: Optional[bool] = None\n</code></pre> <p>The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see geom below. If this attribute is \"true\", the fitting procedure uses the axis-aligned bounding box (AABB) of the mesh, choosing the smallest primitive whose AABB contains the mesh AABB. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom. The models used to generate the image on the right can be found here (fit inertia box) and here (fit aabb).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.fusestatic","title":"fusestatic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fusestatic: Optional[bool] = None\n</code></pre> <p>This attribute controls a compiler optimization feature where static bodies are fused with their parent, and any elements defined in those bodies are reassigned to the parent. Static bodies are fused with their parent unless</p> <ul> <li>They are referenced by another element in the model.</li> <li>They contain a site which is referenced by a force or torque sensor.</li> </ul> <p>This optimization is particularly useful when importing URDF models which often have many dummy bodies, but can also be used to optimize MJCF models. After optimization, the new model has identical kinematics and dynamics as the original but is faster to simulate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.inertiafromgeom","title":"inertiafromgeom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiafromgeom: Optional[InertiaFromGeom] = None\n</code></pre> <p>This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is \"false\", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the inertial element, or else a compile error will be generated. If this setting is \"true\", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the inertial element. The default setting \"auto\" means that masses and inertias are inferred automatically only when the inertial element is missing in the body definition. One reason to set this attribute to \"true\" instead of \"auto\" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.inertiagrouprange","title":"inertiagrouprange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertiagrouprange: Optional[InertiaGroupRange] = None\n</code></pre> <p>This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The group attribute of geom is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.meshdir","title":"meshdir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meshdir: Optional[str] = None\n</code></pre> <p>This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the strippath attribute described above is \"true\", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.saveinertial","title":"saveinertial  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>saveinertial: Optional[bool] = None\n</code></pre> <p>If set to \"true\", the compiler will save explicit inertial clauses for all bodies.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.settotalmass","title":"settotalmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>settotalmass: Optional[float] = None\n</code></pre> <p>If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function mj_setTotalmass.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.strippath","title":"strippath  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>strippath: Optional[bool] = None\n</code></pre> <p>When this attribute is \"true\", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.texturedir","title":"texturedir  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texturedir: Optional[str] = None\n</code></pre> <p>This attribute is used to instruct the compiler where to look for texture files. It works in the same way as meshdir above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.usethread","title":"usethread  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>usethread: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\", the model compiler will run in multi-threaded mode. Currently multi-threading is used for computing the length ranges of actuators and for parallel loading of meshes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler/#mujoco_mojo.mjcf.mujoco_attr.compiler.Compiler.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/","title":"option","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option","title":"Option","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option.py</code> Python<pre><code>class Option(XMLModel):\n    \"\"\"This element is in one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.\"\"\"\n\n    tag = \"option\"\n\n    attributes = (\n        \"timestep\",\n        \"impratio\",\n        \"tolerance\",\n        \"ls_tolerance\",\n        \"noslip_tolerance\",\n        \"ccd_tolerance\",\n        \"sleep_tolerance\",\n        \"gravity\",\n        \"wind\",\n        \"magnetic\",\n        \"density\",\n        \"viscosity\",\n        \"o_margin\",\n        \"o_solref\",\n        \"o_solimp\",\n        \"o_friction\",\n        \"integrator\",\n        \"cone\",\n        \"jacobian\",\n        \"solver\",\n        \"iterations\",\n        \"ls_iterations\",\n        \"noslip_iterations\",\n        \"ccd_iterations\",\n        \"sdf_iterations\",\n        \"sdf_initpoints\",\n        \"actuatorgroupdisable\",\n    )\n    children = (\"flag\",)\n\n    timestep: Optional[float] = None\n    \"\"\"Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.\"\"\"\n    impratio: Optional[float] = None\n    \"\"\"This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.\"\"\"\n    gravity: Optional[Vec3] = None\n    \"\"\"Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.\"\"\"\n    wind: Optional[Vec3] = None\n    \"\"\"Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.\"\"\"\n    magnetic: Optional[Vec3] = None\n    \"\"\"Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.\"\"\"\n    density: Optional[float] = None\n    \"\"\"Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.\"\"\"\n    viscosity: Optional[float] = None\n    \"\"\"Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.\"\"\"\n    o_margin: Optional[float] = None\n    \"\"\"This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.\"\"\"\n    o_solref: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_solimp: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    o_friction: Optional[Vec5] = None\n    \"\"\"These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.\"\"\"\n    integrator: Optional[Integrator] = None\n    \"\"\"This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.\"\"\"\n    cone: Optional[Cone] = None\n    \"\"\"The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.\"\"\"\n    jacobian: Optional[Jacobian] = None\n    \"\"\"The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.\"\"\"\n    solver: Optional[Solver] = None\n    \"\"\"This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.\"\"\"\n    iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.\"\"\"\n    tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.\"\"\"\n    ls_iterations: Optional[int] = None\n    \"\"\"Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.\"\"\"\n    ls_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the linesearch algorithm.\"\"\"\n    noslip_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.\"\"\"\n    noslip_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the Noslip solver.\"\"\"\n    ccd_iterations: Optional[int] = None\n    \"\"\"Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.\"\"\"\n    ccd_tolerance: Optional[float] = None\n    \"\"\"Tolerance threshold used for early termination of the convex collision algorithm.\"\"\"\n    sleep_tolerance: Optional[float] = None\n    \"\"\"Velocity tolerance below which sleeping is allowed.\"\"\"\n    sdf_iterations: Optional[int] = None\n    \"\"\"Number of iterations used for Signed Distance Field collisions (per initial point).\"\"\"\n    sdf_initpoints: Optional[int] = None\n    \"\"\"Number of starting points used for finding contacts with Signed Distance Field collisions.\"\"\"\n    actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n    \"\"\"List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.\"\"\"\n\n    flag: Optional[Flag] = None\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.actuatorgroupdisable","title":"actuatorgroupdisable  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgroupdisable: Optional[Set[ActuatorGroup]] = None\n</code></pre> <p>List of actuator groups to disable. Actuators whose group is in this list will produce no force. If they are stateful, their activation states will not be integrated. Internally this list is implemented as an integer bitfield, so values must be in the range 0 &lt;= group &lt;= 30. If not set, all actuator groups are enabled. See example model and associated screen-capture on the right.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ccd_iterations","title":"ccd_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the algorithm used for convex collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ccd_tolerance","title":"ccd_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ccd_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the convex collision algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.cone","title":"cone  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>cone: Optional[Cone] = None\n</code></pre> <p>The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.density","title":"density  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>density: Optional[float] = None\n</code></pre> <p>Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[Vec3] = None\n</code></pre> <p>Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.impratio","title":"impratio  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>impratio: Optional[float] = None\n</code></pre> <p>This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be \"harder\" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; it is not recommended to use high impratio values with pyramidal cones.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.integrator","title":"integrator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>integrator: Optional[Integrator] = None\n</code></pre> <p>This attribute selects the numerical integrator to be used. Currently the available integrators are the semi-implicit Euler method, the fixed-step 4-th order Runge Kutta method, the Implicit-in-velocity Euler method, and implicitfast, which drops the Coriolis and centrifugal terms. See Numerical Integration for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.iterations","title":"iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the constraint solver. When the warmstart attribute of flag is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.jacobian","title":"jacobian  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>jacobian: Optional[Jacobian] = None\n</code></pre> <p>The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ls_iterations","title":"ls_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of linesearch iterations performed by CG/Newton constraint solvers. Ensures that at most iterations times ls_iterations linesearch iterations are performed during each constraint solve.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.ls_tolerance","title":"ls_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ls_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the linesearch algorithm.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.magnetic","title":"magnetic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>magnetic: Optional[Vec3] = None\n</code></pre> <p>Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.noslip_iterations","title":"noslip_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_iterations: Optional[int] = None\n</code></pre> <p>Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.noslip_tolerance","title":"noslip_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>noslip_tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the Noslip solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_friction","title":"o_friction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_friction: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_margin","title":"o_margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_margin: Optional[float] = None\n</code></pre> <p>This attribute replaces the margin parameter of all active contact pairs when Contact override is enabled. Otherwise MuJoCo uses the element-specific margin attribute of geom or pair depending on how the contact pair was generated. See also Collision detection in the Computation chapter. The related gap parameter does not have a global override.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_solimp","title":"o_solimp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solimp: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.o_solref","title":"o_solref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>o_solref: Optional[Vec5] = None\n</code></pre> <p>These attributes replace the solref, solimp and friction parameters of all active contact pairs when contact override is enabled. See Solver parameters for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.sdf_initpoints","title":"sdf_initpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_initpoints: Optional[int] = None\n</code></pre> <p>Number of starting points used for finding contacts with Signed Distance Field collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.sdf_iterations","title":"sdf_iterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sdf_iterations: Optional[int] = None\n</code></pre> <p>Number of iterations used for Signed Distance Field collisions (per initial point).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.sleep_tolerance","title":"sleep_tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep_tolerance: Optional[float] = None\n</code></pre> <p>Velocity tolerance below which sleeping is allowed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.solver","title":"solver  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solver: Optional[Solver] = None\n</code></pre> <p>This attribute selects one of the constraint solver algorithms described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the Algorithms section above.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the Solver parameters; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.tolerance","title":"tolerance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolerance: Optional[float] = None\n</code></pre> <p>Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.viscosity","title":"viscosity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>viscosity: Optional[float] = None\n</code></pre> <p>Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the default Euler integrator handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity, or switching to the implicit or implicitfast integrators.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>wind: Optional[Vec3] = None\n</code></pre> <p>Velocity vector of the medium (i.e., wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall Passive forces in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option/#mujoco_mojo.mjcf.mujoco_attr.option.Option.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/","title":"size","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size","title":"Size","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\size.py</code> Python<pre><code>class Size(XMLModel):\n    \"\"\"This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.\"\"\"\n\n    tag = \"size\"\n\n    attributes = (\n        \"memory\",\n        \"njmax\",\n        \"nconmax\",\n        \"nstack\",\n        \"nuserdata\",\n        \"nkey\",\n        \"nuser_body\",\n        \"nuser_jnt\",\n        \"nuser_geom\",\n        \"nuser_site\",\n        \"nuser_cam\",\n        \"nuser_tendon\",\n        \"nuser_actuator\",\n        \"nuser_sensor\",\n    )\n\n    memory: Optional[str] = None\n    \"\"\"This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.\"\"\"\n    njmax: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.\"\"\"\n    nconmax: Optional[int] = None\n    \"\"\"This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.\"\"\"\n    nstack: Optional[int] = None\n    \"\"\"This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.\"\"\"\n    nuserdata: Optional[int] = None\n    \"\"\"The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.\"\"\"\n    nkey: Optional[int] = None\n    \"\"\"The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.\"\"\"\n    nuser_body: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.\"\"\"\n    nuser_jnt: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each joint.\"\"\"\n    nuser_geom: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each geom.\"\"\"\n    nuser_site: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each site.\"\"\"\n    nuser_cam: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each camera.\"\"\"\n    nuser_tendon: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each tendon.\"\"\"\n    nuser_actuator: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each actuator.\"\"\"\n    nuser_sensor: Optional[int] = None\n    \"\"\"The number of custom user parameters added to the definition of each sensor.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>memory: Optional[str] = None\n</code></pre> <p>This attribute specifies the size of memory allocated for dynamic arrays in the mjData.arena memory space, in bytes. The default setting of -1 instructs the compiler to guess how much space to allocate. Appending the digits with one of the letters {K, M, G, T, P, E} sets the unit to be {kilo, mega, giga, tera, peta, exa}-byte, respectively. Thus \"16M\" means \"allocate 16 megabytes of arena memory\". See the Memory allocation section for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nconmax","title":"nconmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nconmax: Optional[int] = None\n</code></pre> <p>This attribute specifies the maximum number of contacts that will be generated at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. This is a deprecated legacy attribute which prior to version 2.3.0 affected memory allocation. It is kept for backwards compatibillity and debugging purposes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.njmax","title":"njmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>njmax: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum allowed number of constraints. Currently it means \"allocate as much memory as would have previously been required for this number of constraints\". Specifying both njmax and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nkey","title":"nkey  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nkey: Optional[int] = None\n</code></pre> <p>The number of key frames allocated in mjModel is the larger of this value and the number of key elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nstack","title":"nstack  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nstack: Optional[int] = None\n</code></pre> <p>This is a deprecated legacy attribute. In versions prior to 2.3.0, it determined the maximum size of the stack. After version 2.3.0, if nstack is specified, then the size of mjData.narena is nstack * sizeof(mjtNum) bytes, plus an additional space for the constraint solver. Specifying both nstack and memory leads to an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_actuator","title":"nuser_actuator  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_actuator: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each actuator.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_body","title":"nuser_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_body: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each body. See also User parameters. The parameter values are set via the user attribute of the body element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_cam","title":"nuser_cam  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_cam: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each camera.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_geom","title":"nuser_geom  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_geom: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each geom.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_jnt","title":"nuser_jnt  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_jnt: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_sensor","title":"nuser_sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_sensor: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each sensor.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_site","title":"nuser_site  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_site: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each site.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuser_tendon","title":"nuser_tendon  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuser_tendon: Optional[int] = None\n</code></pre> <p>The number of custom user parameters added to the definition of each tendon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.nuserdata","title":"nuserdata  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nuserdata: Optional[int] = None\n</code></pre> <p>The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/size/#mujoco_mojo.mjcf.mujoco_attr.size.Size.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/","title":"statistic","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic","title":"Statistic","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\statistic.py</code> Python<pre><code>class Statistic(XMLModel):\n    \"\"\"This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.\"\"\"\n\n    tag = \"statistic\"\n\n    attributes = (\n        \"meaninertia\",\n        \"meanmass\",\n        \"meansize\",\n        \"extent\",\n        \"center\",\n    )\n\n    meanmass: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.\"\"\"\n    meaninertia: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.\"\"\"\n    meansize: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.\"\"\"\n    extent: Optional[float] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.\"\"\"\n    center: Optional[Vec3] = None\n    \"\"\"If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.center","title":"center  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>center: Optional[Vec3] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.extent","title":"extent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>extent: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the map element above. When the model is first loaded, the free camera's initial distance from the center (see below) is 1.5 times the extent. Must be strictly positive.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.meaninertia","title":"meaninertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meaninertia: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.meanmass","title":"meanmass  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meanmass: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.meansize","title":"meansize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>meansize: Optional[float] = None\n</code></pre> <p>If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. At runtime this value multiplies the attributes of the scale element above, and acts as their length unit. If specific lengths are desired, it can be convenient to set meansize to a round number like 1 or 0.01 so that scale values are in recognized length units. This is the only semantic of meansize and setting it has no other side-effect. The automatically computed value is heuristic, representing the average body radius. The heuristic is based on geom sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/statistic/#mujoco_mojo.mjcf.mujoco_attr.statistic.Statistic.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/","title":"asset_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\hfield.py</code> Python<pre><code>class HField(XMLModel):\n    \"\"\"This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:\n\n    1. The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.\n\n    2. The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4*(2+nrow*ncol) bytes:\n        ```\n        (int32)   nrow\n        (int32)   ncol\n        (float32) data[nrow*ncol]\n        ```\n    3. The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.\n\n    Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.\n\n    The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.\n\n    For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.\n    \"\"\"\n\n    tag = \"hfield\"\n\n    attributes = (\n        \"name\",\n        \"content_type\",\n        \"file\",\n        \"nrow\",\n        \"ncol\",\n        \"elevation\",\n        \"size\",\n    )\n\n    name: Optional[str] = None\n    \"\"\"Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.\"\"\"\n    nrow: Optional[int] = None\n    \"\"\"This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.\"\"\"\n    ncol: Optional[int] = None\n    \"\"\"This attribute specifies the number of columns in the elevation data matrix.\"\"\"\n    elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None  # type: ignore\n    \"\"\"This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.\"\"\"\n    size: Vec4\n    \"\"\"The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.\"\"\"\n\n    @model_validator(mode=\"before\")\n    def coerce_elevation(self) -&gt; HField:\n        elev = self.elevation\n        nrow = self.nrow\n        ncol = self.ncol\n\n        if elev is None:\n            return self\n\n        elev = np.asarray(elev, dtype=np.float64)\n\n        if nrow is not None and ncol is not None:\n            expected_len = nrow * ncol\n            if elev.size != expected_len:\n                raise ValueError(\n                    f\"Elevation length {elev.size} does not match nrow*ncol={expected_len}\"\n                )\n\n        # Normalize\n        min_val = elev.min()\n        max_val = elev.max()\n        if max_val &gt; min_val:\n            elev = (elev - min_val) / (max_val - min_val)\n\n        self.elevation = elev\n        return self\n\n    @field_validator(\"nrow\", \"ncol\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v is not None and v &lt; 0:\n            raise ValueError(\"nrow and ncol must be non-negative\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: Optional[int] = None\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: Optional[int] = None\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material_attr\\layer.py</code> Python<pre><code>class Layer(XMLModel):\n    \"\"\"If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.\"\"\"\n\n    tag = \"layer\"\n\n    attributes = (\n        \"texture\",\n        \"role\",\n    )\n\n    texture: str\n    \"\"\"Name of the texture, like the texture attribute.\"\"\"\n    role: str\n    \"\"\"Role of the texture. The valid values, expected number of channels, and the role semantics are:\n\n    | value     | channels | description                                                  |\n    |:----------|:---------|:-------------------------------------------------------------|\n    | rgb       | 3        | base color / albedo [red, green, blue]                       |\n    | normal    | 3        | bump map (surface normals)                                   |\n    | occlusion | 1        | ambient occlusion                                            |\n    | roughness | 1        | roughness                                                    |\n    | metallic  | 1        | metallicity                                                  |\n    | opacity   | 1        | opacity (alpha channel)                                      |\n    | emissive  | 4        | RGB light emmision intensity, exposure weight in 4th channel |\n    | orm       | 3        | packed 3 channel [occlusion, roughness, metallic]            |\n    | rgba      | 4        | packed 4 channel [red, green, blue, alpha]                   |\n    \"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: str\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: str\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material.py</code> Python<pre><code>class Material(XMLModel):\n    \"\"\"This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.\"\"\"\n\n    tag = \"material\"\n\n    attributes = (\n        \"name\",\n        \"class_\",\n        \"texture\",\n        \"texrepeat\",\n        \"texuniform\",\n        \"emission\",\n        \"specular\",\n        \"shininess\",\n        \"reflectance\",\n        \"metallic\",\n        \"roughness\",\n        \"rgba\",\n    )\n\n    children = (\"layers\",)\n\n    name: str\n    \"\"\"Name of the material, used for referencing.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    texture: Optional[str] = None\n    \"\"\"If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.\"\"\"\n    texrepeat: Optional[Vec2] = None\n    \"\"\"This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.\"\"\"\n    texuniform: Optional[bool] = None\n    \"\"\"For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.\"\"\"\n    emission: Optional[float] = None\n    \"\"\"Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.\"\"\"\n    specular: Optional[float] = None\n    \"\"\"Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].\"\"\"\n    shininess: Optional[float] = None\n    \"\"\"Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.\"\"\"\n    reflectance: Optional[float] = None\n    \"\"\"This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.\"\"\"\n    metallic: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.\"\"\"\n    roughness: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.\"\"\"\n    rgba: Optional[Vec4] = None\n    \"\"\"Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.\"\"\"\n\n    layers: List[Layer] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: Optional[float] = None\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: Optional[float] = None\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Optional[Vec4] = None\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: Optional[float] = None\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Optional[float] = None\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Optional[Vec2] = None\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: Optional[str] = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: Optional[bool] = None\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class Mesh(XMLModel):\n    \"\"\"This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.\"\"\"\n\n    tag = \"mesh\"\n\n    attributes = _mesh_attr\n\n    name: Optional[str] = None\n    \"\"\"Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes (only scale in this case).\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.\"\"\"\n    scale: Optional[Vec3] = None\n    \"\"\"This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.\"\"\"\n    inertia: Optional[Inertia] = None\n    \"\"\"This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.\n\n    * convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.\n    * exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.\n    * legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.\n    * shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.\n    \"\"\"\n    smoothnormal: Optional[bool] = None\n    \"\"\"Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.\"\"\"\n    maxhullvert: Optional[int] = None\n    \"\"\"Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.\"\"\"\n    vertex: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.\"\"\"\n    normal: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.\"\"\"\n    texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n    \"\"\"Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.\"\"\"\n    face: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.\"\"\"\n    refpos: Optional[Vec3] = None\n    \"\"\"Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.\"\"\"\n    refquat: Optional[Vec4] = None\n    \"\"\"Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.\"\"\"\n    material: Optional[str] = None\n    \"\"\"Fallback material for mesh geoms that do not specify their own material.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone","title":"MeshCone","text":"<p>               Bases: <code>Mesh</code></p> <p>Cone mesh from top and bottom polygons.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshCone(Mesh):\n    \"\"\"\n    Cone mesh from top and bottom polygons.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"cone\"\n\n    attributes = _mesh_attr + (\"builtin\", \"nvert\", \"radius\")\n\n    nvert: int\n    \"\"\"integer &gt;= 3: The number of vertices in the polygon.\"\"\"\n    radius: float\n    \"\"\"real in [0, 1]: The radius of the top face.\"\"\"\n\n    @field_validator(\"nvert\")\n    @classmethod\n    def validate_nvert(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"nvert must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"radius must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.nvert","title":"nvert  <code>instance-attribute</code>","text":"Python<pre><code>nvert: int\n</code></pre> <p>integer &gt;= 3: The number of vertices in the polygon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in [0, 1]: The radius of the top face.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshCone.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere","title":"MeshHemisphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Quad-projected hemisphere.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshHemisphere(Mesh):\n    \"\"\"\n    Quad-projected hemisphere.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"hemisphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\")\n\n    resolution: int\n    \"\"\"integer in [0-10]: Equator discretization of one hemisphere quadrant.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 10:\n            raise ValueError(\"resolution must be in [0, 10]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer in [0-10]: Equator discretization of one hemisphere quadrant.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshHemisphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate","title":"MeshPlate","text":"<p>               Bases: <code>Mesh</code></p> <p>Rectangular plate mesh.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshPlate(Mesh):\n    \"\"\"\n    Rectangular plate mesh.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"plate\"\n\n    attributes = _mesh_attr + (\"builtin\", \"res_x\", \"res_y\")\n\n    res_x: int\n    \"\"\"integer &gt; 0: Horizontal resolution of the plate.\"\"\"\n    res_y: int\n    \"\"\"integer &gt; 0: Vertical resolution of the plate.\"\"\"\n\n    @field_validator(\"res_x\", \"res_y\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.res_x","title":"res_x  <code>instance-attribute</code>","text":"Python<pre><code>res_x: int\n</code></pre> <p>integer &gt; 0: Horizontal resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.res_y","title":"res_y  <code>instance-attribute</code>","text":"Python<pre><code>res_y: int\n</code></pre> <p>integer &gt; 0: Vertical resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshPlate.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere","title":"MeshSphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Repeated subdivisions of a unit icosahedron (\"icosphere\").</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSphere(Mesh):\n    \"\"\"\n    Repeated subdivisions of a unit icosahedron (\"icosphere\").\n    \"\"\"\n\n    builtin: ClassVar[str] = \"sphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"subdivision\")\n\n    subdivision: int\n    \"\"\"integer in [0-4]: The number of subdivisions to apply to icosahedron faces.\"\"\"\n\n    @field_validator(\"subdivision\")\n    @classmethod\n    def validate_subdivision(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 4:\n            raise ValueError(\"subdivision must be in [0, 4]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.subdivision","title":"subdivision  <code>instance-attribute</code>","text":"Python<pre><code>subdivision: int\n</code></pre> <p>integer in [0-4]: The number of subdivisions to apply to icosahedron faces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere","title":"MeshSupersphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Supersphere (superellipsoid) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSupersphere(Mesh):\n    \"\"\"\n    Supersphere (superellipsoid) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"supersphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"e\", \"n\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Longitude and latitude discretization.\"\"\"\n    e: float\n    \"\"\"real &gt;= 0: The 'east-west' exponent.\"\"\"\n    n: float\n    \"\"\"real &gt;= 0: The 'north-south' exponent.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"e\", \"n\")\n    @classmethod\n    def validate_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.e","title":"e  <code>instance-attribute</code>","text":"Python<pre><code>e: float\n</code></pre> <p>real &gt;= 0: The 'east-west' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.n","title":"n  <code>instance-attribute</code>","text":"Python<pre><code>n: float\n</code></pre> <p>real &gt;= 0: The 'north-south' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Longitude and latitude discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshSupersphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus","title":"MeshTorus","text":"<p>               Bases: <code>Mesh</code></p> <p>Supertorus (generalized torus) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshTorus(Mesh):\n    \"\"\"\n    Supertorus (generalized torus) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"torus\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"radius\", \"s\", \"t\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Discretization of both circumferences.\"\"\"\n    radius: float\n    \"\"\"real in (0, 1]: Minor radius of the torus.\"\"\"\n    s: float\n    \"\"\"real &gt; 0: The 'squareness' of minor sections.\"\"\"\n    t: float\n    \"\"\"real &gt; 0: The 'squareness' of major sections.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 1:\n            raise ValueError(\"radius must be in (0, 1]\")\n        return v\n\n    @field_validator(\"s\", \"t\")\n    @classmethod\n    def validate_positive(cls, v: float) -&gt; float:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in (0, 1]: Minor radius of the torus.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Discretization of both circumferences.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.s","title":"s  <code>instance-attribute</code>","text":"Python<pre><code>s: float\n</code></pre> <p>real &gt; 0: The 'squareness' of minor sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.t","title":"t  <code>instance-attribute</code>","text":"Python<pre><code>t: float\n</code></pre> <p>real &gt; 0: The 'squareness' of major sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshTorus.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge","title":"MeshWedge","text":"<p>               Bases: <code>Mesh</code></p> <p>Slice of a unit spherical shell.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshWedge(Mesh):\n    \"\"\"\n    Slice of a unit spherical shell.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"wedge\"\n\n    attributes = _mesh_attr + (\n        \"builtin\",\n        \"res_phi\",\n        \"res_theta\",\n        \"fov_phi\",\n        \"fov_theta\",\n        \"gamma\",\n    )\n\n    res_phi: int\n    \"\"\"integer &gt;= 0: Vertical resolution of the slice.\"\"\"\n    res_theta: int\n    \"\"\"integer &gt;= 0: Horizontal resolution of the slice.\"\"\"\n    fov_phi: float\n    \"\"\"real in (0, 180]: Horizontal field of view (degrees).\"\"\"\n    fov_theta: float\n    \"\"\"real in (0, 90): Vertical field of view (degrees).\"\"\"\n    gamma: float\n    \"\"\"real in [0, 1]: Foveal deformation of the discretization.\"\"\"\n\n    @field_validator(\"res_phi\", \"res_theta\")\n    @classmethod\n    def validate_non_negative(cls, v: int) -&gt; int:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n\n    @field_validator(\"fov_phi\")\n    @classmethod\n    def validate_fov_phi(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 180:\n            raise ValueError(\"fov_phi must be in (0, 180]\")\n        return v\n\n    @field_validator(\"fov_theta\")\n    @classmethod\n    def validate_fov_theta(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt; 90:\n            raise ValueError(\"fov_theta must be in (0, 90)\")\n        return v\n\n    @field_validator(\"gamma\")\n    @classmethod\n    def validate_gamma(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"gamma must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.fov_phi","title":"fov_phi  <code>instance-attribute</code>","text":"Python<pre><code>fov_phi: float\n</code></pre> <p>real in (0, 180]: Horizontal field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.fov_theta","title":"fov_theta  <code>instance-attribute</code>","text":"Python<pre><code>fov_theta: float\n</code></pre> <p>real in (0, 90): Vertical field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.gamma","title":"gamma  <code>instance-attribute</code>","text":"Python<pre><code>gamma: float\n</code></pre> <p>real in [0, 1]: Foveal deformation of the discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.res_phi","title":"res_phi  <code>instance-attribute</code>","text":"Python<pre><code>res_phi: int\n</code></pre> <p>integer &gt;= 0: Vertical resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.res_theta","title":"res_theta  <code>instance-attribute</code>","text":"Python<pre><code>res_theta: int\n</code></pre> <p>integer &gt;= 0: Horizontal resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.MeshWedge.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\model.py</code> Python<pre><code>class Model(XMLModel):\n    \"\"\"This element specifies other MJCF models which may be used for attachment in the current model.\"\"\"\n\n    tag = \"model\"\n\n    attributes = (\"name\", \"file\", \"content_type\")\n\n    name: Optional[str] = None\n    \"\"\"Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.\"\"\"\n    file: Path\n    \"\"\"The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"The file type to be loaded into a model. Currently only text/xml is supported.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh_attr\\plugin.py</code> Python<pre><code>class Plugin(XMLModel):\n    \"\"\"Associate this mesh with an engine plugin. Either plugin or instance are required.\"\"\"\n\n    tag = \"plugin\"\n\n    attributes = (\"plugin\", \"instance\")\n\n    plugin: Optional[str] = None\n    \"\"\"Plugin identifier, used for implicit plugin instantiation.\"\"\"\n    instance: Optional[str] = None  # TODO I think this was implemented poorly\n    \"\"\"Instance name, used for explicit plugin instantiation.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: Optional[str] = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Optional[str] = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\texture.py</code> Python<pre><code>class Texture(XMLModel):\n    \"\"\"This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.\n\n    The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.\n\n    Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.\n\n    The custom MuJoCo format is assumed to be a binary file containing the following data:\n    ```\n    (int32)   width\n    (int32)   height\n    (byte)    rgb_data[3*width*height]\n    ```\n    \"\"\"\n\n    tag = \"texture\"\n\n    attributes = _texture_attr\n\n    name: Optional[str] = None\n    \"\"\"As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.\"\"\"\n    type: Optional[Type] = None\n    \"\"\"This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:\n\n    The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:\n\n    1. Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.\n    2. Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.\n    3. Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.\n    4. Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.\n\n    The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.\n\n    The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.\"\"\"\n    colorspace: Optional[ColorSpace] = None\n    \"\"\"This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.\"\"\"\n    gridsize: Optional[Tuple[int, int]] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.\"\"\"\n    gridlayout: Optional[str] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.\"\"\"\n    fileright: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileleft: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileup: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filedown: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filefront: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileback: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: Optional[ColorSpace] = None\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: Optional[str] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: Optional[Tuple[int, int]] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[Type] = None\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/","title":"hfield","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField","title":"HField","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:</p> <ol> <li> <p>The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.</p> </li> <li> <p>The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4(2+nrowncol) bytes:     </p>Text Only<pre><code>(int32)   nrow\n(int32)   ncol\n(float32) data[nrow*ncol]\n</code></pre><p></p> </li> <li>The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.</li> </ol> <p>Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.</p> <p>The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.</p> <p>For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\hfield.py</code> Python<pre><code>class HField(XMLModel):\n    \"\"\"This element creates a height field asset, which can then be referenced from geoms with type \"hfield\". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:\n\n    1. The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.\n\n    2. The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4*(2+nrow*ncol) bytes:\n        ```\n        (int32)   nrow\n        (int32)   ncol\n        (float32) data[nrow*ncol]\n        ```\n    3. The elevation data can be left undefined at compile time. This is done by specifying the attributes nrow and ncol. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.\n\n    Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.\n\n    The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the size attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.\n\n    For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 50 (mjMAXCONPAIR); any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.\n    \"\"\"\n\n    tag = \"hfield\"\n\n    attributes = (\n        \"name\",\n        \"content_type\",\n        \"file\",\n        \"nrow\",\n        \"ncol\",\n        \"elevation\",\n        \"size\",\n    )\n\n    name: Optional[str] = None\n    \"\"\"Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.\"\"\"\n    nrow: Optional[int] = None\n    \"\"\"This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.\"\"\"\n    ncol: Optional[int] = None\n    \"\"\"This attribute specifies the number of columns in the elevation data matrix.\"\"\"\n    elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None  # type: ignore\n    \"\"\"This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.\"\"\"\n    size: Vec4\n    \"\"\"The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.\"\"\"\n\n    @model_validator(mode=\"before\")\n    def coerce_elevation(self) -&gt; HField:\n        elev = self.elevation\n        nrow = self.nrow\n        ncol = self.ncol\n\n        if elev is None:\n            return self\n\n        elev = np.asarray(elev, dtype=np.float64)\n\n        if nrow is not None and ncol is not None:\n            expected_len = nrow * ncol\n            if elev.size != expected_len:\n                raise ValueError(\n                    f\"Elevation length {elev.size} does not match nrow*ncol={expected_len}\"\n                )\n\n        # Normalize\n        min_val = elev.min()\n        max_val = elev.max()\n        if max_val &gt; min_val:\n            elev = (elev - min_val) / (max_val - min_val)\n\n        self.elevation = elev\n        return self\n\n    @field_validator(\"nrow\", \"ncol\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v is not None and v &lt; 0:\n            raise ValueError(\"nrow and ncol must be non-negative\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be overloaded. Currently image/png and image/vnd.mujoco.hfield are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>elevation: Optional[NDArray[Shape[\"0\"], float | int]] = None\n</code></pre> <p>This attribute specifies the elevation data matrix. Values are automatically normalized to lie between 0 and 1 by first subtracting the minimum value and then dividing by the (maximum-minimum) difference, if not 0. If not provided, values are set to 0.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, the elevation data is loaded from the given file. If the file extension is \".png\", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting nrow or ncol below to non-zero values results is compile error, even if these settings are consistent with the file contents.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.ncol","title":"ncol  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ncol: Optional[int] = None\n</code></pre> <p>This attribute specifies the number of columns in the elevation data matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.nrow","title":"nrow  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nrow: Optional[int] = None\n</code></pre> <p>This attribute and the next are used to allocate a height field in mjModel. If the elevation attribute is not set, the elevation data is set to 0. This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.size","title":"size  <code>instance-attribute</code>","text":"Python<pre><code>size: Vec4\n</code></pre> <p>The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or \"radius\") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a \"base\" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being \"under\" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example on the right is the MATLAB \"peaks\" surface saved in our custom height field format, and loaded as an asset with size = \"1 1 1 0.1\". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/hfield/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.hfield.HField.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/","title":"material","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material","title":"Material","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material.py</code> Python<pre><code>class Material(XMLModel):\n    \"\"\"This element creates a material asset. It can be referenced from skins, geoms, sites and tendons to set their appearance. Note that all these elements also have a local rgba attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.\"\"\"\n\n    tag = \"material\"\n\n    attributes = (\n        \"name\",\n        \"class_\",\n        \"texture\",\n        \"texrepeat\",\n        \"texuniform\",\n        \"emission\",\n        \"specular\",\n        \"shininess\",\n        \"reflectance\",\n        \"metallic\",\n        \"roughness\",\n        \"rgba\",\n    )\n\n    children = (\"layers\",)\n\n    name: str\n    \"\"\"Name of the material, used for referencing.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    texture: Optional[str] = None\n    \"\"\"If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.\"\"\"\n    texrepeat: Optional[Vec2] = None\n    \"\"\"This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.\"\"\"\n    texuniform: Optional[bool] = None\n    \"\"\"For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.\"\"\"\n    emission: Optional[float] = None\n    \"\"\"Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.\"\"\"\n    specular: Optional[float] = None\n    \"\"\"Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].\"\"\"\n    shininess: Optional[float] = None\n    \"\"\"Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.\"\"\"\n    reflectance: Optional[float] = None\n    \"\"\"This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.\"\"\"\n    metallic: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.\"\"\"\n    roughness: Optional[float] = None\n    \"\"\"This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.\"\"\"\n    rgba: Optional[Vec4] = None\n    \"\"\"Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.\"\"\"\n\n    layers: List[Layer] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.emission","title":"emission  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>emission: Optional[float] = None\n</code></pre> <p>Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.metallic","title":"metallic  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>metallic: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform metallicity coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this metallic value should be multiplied by the metallic texture sampled value to obtain the final metallicity of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.name","title":"name  <code>instance-attribute</code>","text":"Python<pre><code>name: str\n</code></pre> <p>Name of the material, used for referencing.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.reflectance","title":"reflectance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>reflectance: Optional[float] = None\n</code></pre> <p>This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.rgba","title":"rgba  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgba: Optional[Vec4] = None\n</code></pre> <p>Color and transparency of the material. All components should be in the range [0 1]. Note that the texture color (if assigned) and the color specified here are multiplied component-wise. Thus the default value of \"1 1 1 1\" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local rgba attribute, the local definition has precedence. Note that this \"local\" definition could in fact come from a defaults class. The remaining material properties always apply.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.roughness","title":"roughness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>roughness: Optional[float] = None\n</code></pre> <p>This attribute corresponds to uniform roughness coefficient applied to the entire material. This attribute has no effect in MuJoCo's native renderer, but it can be useful when rendering scenes with a physically-based renderer. In this case, if a non-negative value is specified, this roughness value should be multiplied by the roughness texture sampled value to obtain the final roughness of the material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.shininess","title":"shininess  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>shininess: Optional[float] = None\n</code></pre> <p>Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.specular","title":"specular  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>specular: Optional[float] = None\n</code></pre> <p>Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.texrepeat","title":"texrepeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texrepeat: Optional[Vec2] = None\n</code></pre> <p>This attribute applies to textures of type \"2d\". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.texture","title":"texture  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texture: Optional[str] = None\n</code></pre> <p>If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the texture element and then referenced here. The texture referenced here is used for specifying the RGB values. For advanced rendering (e.g., Physics-Based Rendering), more texture types need to be specified (e.g., roughness, metallic). In this case, this texture attribute should be omitted, and the texture types should be specified using layer child elements. Note however that the built-in renderer does not support PBR properties, so these advanced rendering features are only available when using an external renderer.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.texuniform","title":"texuniform  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texuniform: Optional[bool] = None\n</code></pre> <p>For cube textures, this attribute controls how cube mapping is applied. The default value \"false\" means apply cube mapping directly, using the actual size of the object. The value \"true\" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with texrepeat above. Let texrepeat be N. The default value \"false\" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value \"true\" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material.Material.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/","title":"mesh","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh","title":"Mesh","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class Mesh(XMLModel):\n    \"\"\"This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is mesh the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see the geom element below.\"\"\"\n\n    tag = \"mesh\"\n\n    attributes = _mesh_attr\n\n    name: Optional[str] = None\n    \"\"\"Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes (only scale in this case).\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.\"\"\"\n    scale: Optional[Vec3] = None\n    \"\"\"This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.\"\"\"\n    inertia: Optional[Inertia] = None\n    \"\"\"This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.\n\n    * convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.\n    * exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.\n    * legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.\n    * shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.\n    \"\"\"\n    smoothnormal: Optional[bool] = None\n    \"\"\"Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.\"\"\"\n    maxhullvert: Optional[int] = None\n    \"\"\"Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.\"\"\"\n    vertex: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.\"\"\"\n    normal: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.\"\"\"\n    texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n    \"\"\"Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.\"\"\"\n    face: Optional[Tuple[Tuple[float, float, float], ...]] = None\n    \"\"\"Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.\"\"\"\n    refpos: Optional[Vec3] = None\n    \"\"\"Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.\"\"\"\n    refquat: Optional[Vec4] = None\n    \"\"\"Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.\"\"\"\n    material: Optional[str] = None\n    \"\"\"Fallback material for mesh geoms that do not specify their own material.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.Mesh.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone","title":"MeshCone","text":"<p>               Bases: <code>Mesh</code></p> <p>Cone mesh from top and bottom polygons.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshCone(Mesh):\n    \"\"\"\n    Cone mesh from top and bottom polygons.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"cone\"\n\n    attributes = _mesh_attr + (\"builtin\", \"nvert\", \"radius\")\n\n    nvert: int\n    \"\"\"integer &gt;= 3: The number of vertices in the polygon.\"\"\"\n    radius: float\n    \"\"\"real in [0, 1]: The radius of the top face.\"\"\"\n\n    @field_validator(\"nvert\")\n    @classmethod\n    def validate_nvert(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"nvert must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"radius must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.nvert","title":"nvert  <code>instance-attribute</code>","text":"Python<pre><code>nvert: int\n</code></pre> <p>integer &gt;= 3: The number of vertices in the polygon.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in [0, 1]: The radius of the top face.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshCone.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere","title":"MeshHemisphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Quad-projected hemisphere.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshHemisphere(Mesh):\n    \"\"\"\n    Quad-projected hemisphere.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"hemisphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\")\n\n    resolution: int\n    \"\"\"integer in [0-10]: Equator discretization of one hemisphere quadrant.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 10:\n            raise ValueError(\"resolution must be in [0, 10]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer in [0-10]: Equator discretization of one hemisphere quadrant.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshHemisphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate","title":"MeshPlate","text":"<p>               Bases: <code>Mesh</code></p> <p>Rectangular plate mesh.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshPlate(Mesh):\n    \"\"\"\n    Rectangular plate mesh.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"plate\"\n\n    attributes = _mesh_attr + (\"builtin\", \"res_x\", \"res_y\")\n\n    res_x: int\n    \"\"\"integer &gt; 0: Horizontal resolution of the plate.\"\"\"\n    res_y: int\n    \"\"\"integer &gt; 0: Vertical resolution of the plate.\"\"\"\n\n    @field_validator(\"res_x\", \"res_y\")\n    @classmethod\n    def validate_positive(cls, v: int) -&gt; int:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.res_x","title":"res_x  <code>instance-attribute</code>","text":"Python<pre><code>res_x: int\n</code></pre> <p>integer &gt; 0: Horizontal resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.res_y","title":"res_y  <code>instance-attribute</code>","text":"Python<pre><code>res_y: int\n</code></pre> <p>integer &gt; 0: Vertical resolution of the plate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshPlate.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere","title":"MeshSphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Repeated subdivisions of a unit icosahedron (\"icosphere\").</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSphere(Mesh):\n    \"\"\"\n    Repeated subdivisions of a unit icosahedron (\"icosphere\").\n    \"\"\"\n\n    builtin: ClassVar[str] = \"sphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"subdivision\")\n\n    subdivision: int\n    \"\"\"integer in [0-4]: The number of subdivisions to apply to icosahedron faces.\"\"\"\n\n    @field_validator(\"subdivision\")\n    @classmethod\n    def validate_subdivision(cls, v: int) -&gt; int:\n        if not 0 &lt;= v &lt;= 4:\n            raise ValueError(\"subdivision must be in [0, 4]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.subdivision","title":"subdivision  <code>instance-attribute</code>","text":"Python<pre><code>subdivision: int\n</code></pre> <p>integer in [0-4]: The number of subdivisions to apply to icosahedron faces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere","title":"MeshSupersphere","text":"<p>               Bases: <code>Mesh</code></p> <p>Supersphere (superellipsoid) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshSupersphere(Mesh):\n    \"\"\"\n    Supersphere (superellipsoid) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"supersphere\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"e\", \"n\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Longitude and latitude discretization.\"\"\"\n    e: float\n    \"\"\"real &gt;= 0: The 'east-west' exponent.\"\"\"\n    n: float\n    \"\"\"real &gt;= 0: The 'north-south' exponent.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"e\", \"n\")\n    @classmethod\n    def validate_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.e","title":"e  <code>instance-attribute</code>","text":"Python<pre><code>e: float\n</code></pre> <p>real &gt;= 0: The 'east-west' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.n","title":"n  <code>instance-attribute</code>","text":"Python<pre><code>n: float\n</code></pre> <p>real &gt;= 0: The 'north-south' exponent.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Longitude and latitude discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshSupersphere.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus","title":"MeshTorus","text":"<p>               Bases: <code>Mesh</code></p> <p>Supertorus (generalized torus) shape.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshTorus(Mesh):\n    \"\"\"\n    Supertorus (generalized torus) shape.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"torus\"\n\n    attributes = _mesh_attr + (\"builtin\", \"resolution\", \"radius\", \"s\", \"t\")\n\n    resolution: int\n    \"\"\"integer &gt;= 3: Discretization of both circumferences.\"\"\"\n    radius: float\n    \"\"\"real in (0, 1]: Minor radius of the torus.\"\"\"\n    s: float\n    \"\"\"real &gt; 0: The 'squareness' of minor sections.\"\"\"\n    t: float\n    \"\"\"real &gt; 0: The 'squareness' of major sections.\"\"\"\n\n    @field_validator(\"resolution\")\n    @classmethod\n    def validate_resolution(cls, v: int) -&gt; int:\n        if v &lt; 3:\n            raise ValueError(\"resolution must be &gt;= 3\")\n        return v\n\n    @field_validator(\"radius\")\n    @classmethod\n    def validate_radius(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 1:\n            raise ValueError(\"radius must be in (0, 1]\")\n        return v\n\n    @field_validator(\"s\", \"t\")\n    @classmethod\n    def validate_positive(cls, v: float) -&gt; float:\n        if v &lt;= 0:\n            raise ValueError(\"must be &gt; 0\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.radius","title":"radius  <code>instance-attribute</code>","text":"Python<pre><code>radius: float\n</code></pre> <p>real in (0, 1]: Minor radius of the torus.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.resolution","title":"resolution  <code>instance-attribute</code>","text":"Python<pre><code>resolution: int\n</code></pre> <p>integer &gt;= 3: Discretization of both circumferences.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.s","title":"s  <code>instance-attribute</code>","text":"Python<pre><code>s: float\n</code></pre> <p>real &gt; 0: The 'squareness' of minor sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.t","title":"t  <code>instance-attribute</code>","text":"Python<pre><code>t: float\n</code></pre> <p>real &gt; 0: The 'squareness' of major sections.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshTorus.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge","title":"MeshWedge","text":"<p>               Bases: <code>Mesh</code></p> <p>Slice of a unit spherical shell.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh.py</code> Python<pre><code>class MeshWedge(Mesh):\n    \"\"\"\n    Slice of a unit spherical shell.\n    \"\"\"\n\n    builtin: ClassVar[str] = \"wedge\"\n\n    attributes = _mesh_attr + (\n        \"builtin\",\n        \"res_phi\",\n        \"res_theta\",\n        \"fov_phi\",\n        \"fov_theta\",\n        \"gamma\",\n    )\n\n    res_phi: int\n    \"\"\"integer &gt;= 0: Vertical resolution of the slice.\"\"\"\n    res_theta: int\n    \"\"\"integer &gt;= 0: Horizontal resolution of the slice.\"\"\"\n    fov_phi: float\n    \"\"\"real in (0, 180]: Horizontal field of view (degrees).\"\"\"\n    fov_theta: float\n    \"\"\"real in (0, 90): Vertical field of view (degrees).\"\"\"\n    gamma: float\n    \"\"\"real in [0, 1]: Foveal deformation of the discretization.\"\"\"\n\n    @field_validator(\"res_phi\", \"res_theta\")\n    @classmethod\n    def validate_non_negative(cls, v: int) -&gt; int:\n        if v &lt; 0:\n            raise ValueError(\"must be &gt;= 0\")\n        return v\n\n    @field_validator(\"fov_phi\")\n    @classmethod\n    def validate_fov_phi(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt;= 180:\n            raise ValueError(\"fov_phi must be in (0, 180]\")\n        return v\n\n    @field_validator(\"fov_theta\")\n    @classmethod\n    def validate_fov_theta(cls, v: float) -&gt; float:\n        if not 0 &lt; v &lt; 90:\n            raise ValueError(\"fov_theta must be in (0, 90)\")\n        return v\n\n    @field_validator(\"gamma\")\n    @classmethod\n    def validate_gamma(cls, v: float) -&gt; float:\n        if not 0 &lt;= v &lt;= 1:\n            raise ValueError(\"gamma must be in [0, 1]\")\n        return v\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes (only scale in this case).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME type) of the file to be loaded. Any filename extensions will be overloaded. Currently model/vnd.mujoco.msh, model/obj, and model/stl are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.face","title":"face  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>face: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Faces of the mesh. Each face is a sequence of 3 vertex indices, in counter-clockwise order. The indices must be integers between 0 and nvert-1.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>The file from which the mesh will be loaded. The path is determined as described in the meshdir attribute of compiler. The file extension must be \"stl\", \"msh\", or \"obj\" (not case sensitive) specifying the file type. If the file name is omitted, the vertex attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.fov_phi","title":"fov_phi  <code>instance-attribute</code>","text":"Python<pre><code>fov_phi: float\n</code></pre> <p>real in (0, 180]: Horizontal field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.fov_theta","title":"fov_theta  <code>instance-attribute</code>","text":"Python<pre><code>fov_theta: float\n</code></pre> <p>real in (0, 90): Vertical field of view (degrees).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.gamma","title":"gamma  <code>instance-attribute</code>","text":"Python<pre><code>gamma: float\n</code></pre> <p>real in [0, 1]: Foveal deformation of the discretization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.inertia","title":"inertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inertia: Optional[Inertia] = None\n</code></pre> <p>This attribute controls how the mesh is used when mass and inertia are inferred from geometry. The current default value legacy will be changed to convex in a future release.</p> <ul> <li>convex: Use the mesh's convex hull to compute volume and inertia, assuming uniform density.</li> <li>exact: Compute volume and inertia exactly, even for non-convex meshes. This algorithm requires a well-oriented, watertight mesh and will error otherwise.</li> <li>legacy: Use the legacy algorithm, leads to volume overcounting for non-convex meshes. Though currently the default to avoid breakages, it is not recommended.</li> <li>shell: Assume mass is concentrated on the surface of the mesh. Use the mesh's surface to compute the inertia, assuming uniform surface density.</li> </ul>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.material","title":"material  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>material: Optional[str] = None\n</code></pre> <p>Fallback material for mesh geoms that do not specify their own material.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.maxhullvert","title":"maxhullvert  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxhullvert: Optional[int] = None\n</code></pre> <p>Maximum number of vertices in a mesh's convex hull. Currently this is implemented by asking qhull to terminate after maxhullvert vertices. The default value of -1 means \"unlimited\". Positive values must be larger than 3.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.normal","title":"normal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>normal: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D normal data. If specified, the number of normals must equal the number of vertices. The model compiler normalizes the normals automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.refpos","title":"refpos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refpos: Optional[Vec3] = None\n</code></pre> <p>Reference position relative to which the 3D vertex coordinates are defined. This vector is subtracted from the positions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.refquat","title":"refquat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refquat: Optional[Vec4] = None\n</code></pre> <p>Reference orientation relative to which the 3D vertex coordinates and normals are defined. The conjugate of this quaternion is used to rotate the positions and normals. The model compiler normalizes the quaternion automatically.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.res_phi","title":"res_phi  <code>instance-attribute</code>","text":"Python<pre><code>res_phi: int\n</code></pre> <p>integer &gt;= 0: Vertical resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.res_theta","title":"res_theta  <code>instance-attribute</code>","text":"Python<pre><code>res_theta: int\n</code></pre> <p>integer &gt;= 0: Horizontal resolution of the slice.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.scale","title":"scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>scale: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.smoothnormal","title":"smoothnormal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>smoothnormal: Optional[bool] = None\n</code></pre> <p>Controls the automatic generation of vertex normals when normals are not given explicitly. If true, smooth normals are generated by averaging the face normals at each vertex, with weight proportional to the face area. If false, faces at large angles relative to the average normal are excluded from the average. In this way, sharp edges (as in cube edges) are not smoothed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.texcoord","title":"texcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>texcoord: Optional[Tuple[Tuple[float, float], ...]] = None\n</code></pre> <p>Vertex 2D texture coordinates, which are numbers between 0 and 1. If specified, the number of texture coordinate pairs must equal the number of vertices.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.vertex","title":"vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vertex: Optional[Tuple[Tuple[float, float, float], ...]] = (\n    None\n)\n</code></pre> <p>Vertex 3D position data. You can specify position data in the XML using this attribute, or using a binary file, but not both.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh.MeshWedge.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/","title":"model","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model","title":"Model","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies other MJCF models which may be used for attachment in the current model.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\model.py</code> Python<pre><code>class Model(XMLModel):\n    \"\"\"This element specifies other MJCF models which may be used for attachment in the current model.\"\"\"\n\n    tag = \"model\"\n\n    attributes = (\"name\", \"file\", \"content_type\")\n\n    name: Optional[str] = None\n    \"\"\"Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.\"\"\"\n    file: Path\n    \"\"\"The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"The file type to be loaded into a model. Currently only text/xml is supported.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>The file type to be loaded into a model. Currently only text/xml is supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.file","title":"file  <code>instance-attribute</code>","text":"Python<pre><code>file: Path\n</code></pre> <p>The file from which the sub-model will be loaded. Note that the sub-model must be a valid MJCF model.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the sub-model, used for referencing in attach. If unspecified, the model name is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/model/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.model.Model.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/","title":"texture","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture","title":"Texture","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.</p> <p>The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.</p> <p>Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.</p> <p>The custom MuJoCo format is assumed to be a binary file containing the following data: </p>Text Only<pre><code>(int32)   width\n(int32)   height\n(byte)    rgb_data[3*width*height]\n</code></pre><p></p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\texture.py</code> Python<pre><code>class Texture(XMLModel):\n    \"\"\"This element creates a texture asset, which is then referenced from a material asset, which is finally referenced from a model element that needs to be textured.\n\n    The texture data can be loaded from files or can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture. Provisions are provided for loading cube and skybox textures from individual image files.\n\n    Currently, three file formats are supported for loading textures: PNG, KTX, and a custom MuJoCo texture format. The loader will use the extension of the file name to determine which format to use, defaulting to the custom format if the extension is not recognized. Alternatively, the content_type attribute can be used to specify the format explicitly. Only image/png, image/ktx, or image/vnd.mujoco.texture are supported.\n\n    The custom MuJoCo format is assumed to be a binary file containing the following data:\n    ```\n    (int32)   width\n    (int32)   height\n    (byte)    rgb_data[3*width*height]\n    ```\n    \"\"\"\n\n    tag = \"texture\"\n\n    attributes = _texture_attr\n\n    name: Optional[str] = None\n    \"\"\"As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.\"\"\"\n    type: Optional[Type] = None\n    \"\"\"This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:\n\n    The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:\n\n    1. Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.\n    2. Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.\n    3. Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.\n    4. Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.\n\n    The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.\n\n    The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.\"\"\"\n    colorspace: Optional[ColorSpace] = None\n    \"\"\"This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.\"\"\"\n    content_type: Optional[str] = None\n    \"\"\"If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.\"\"\"\n    file: Optional[Path] = None\n    \"\"\"If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.\"\"\"\n    gridsize: Optional[Tuple[int, int]] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.\"\"\"\n    gridlayout: Optional[str] = None\n    \"\"\"When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.\"\"\"\n    fileright: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileleft: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileup: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filedown: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    filefront: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n    fileback: Optional[Path] = None\n    \"\"\"These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: Optional[ColorSpace] = None\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: Optional[str] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: Optional[Tuple[int, int]] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[Type] = None\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.Texture.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural","title":"TextureProcedural","text":"<p>               Bases: <code>Texture</code></p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\texture.py</code> Python<pre><code>class TextureProcedural(Texture):\n    attributes = _texture_attr + (\n        \"builtin\",\n        \"rgb1\",\n        \"rgb2\",\n        \"mark\",\n        \"markrgb\",\n        \"random\",\n        \"width\",\n        \"height\",\n        \"hflip\",\n        \"vflip\",\n        \"nchannel\",\n    )\n\n    builtin: TextureProcedural\n    \"\"\"This and the remaining attributes control the generation of procedural textures. If the value of this attribute is different from \"none\", the texture is treated as procedural and any file names are ignored. The keywords have the following meaning:\n    * gradient\n        * Generates a color gradient from rgb1 to rgb2. The interpolation in color space is done through a sigmoid function. For cube and skybox textures the gradient is along the +Y axis, i.e., from top to bottom for skybox rendering.\n    * checker\n        * Generates a 2-by-2 checker pattern with alternating colors given by rgb1 and rgb2. This is suitable for rendering ground planes and also for marking objects with rotational symmetries. Note that 2d textures can be scaled so as to repeat the pattern as many times as necessary. For cube and skybox textures, the checker pattern is painted on each side of the cube.\n    * flat\n        * Fills the entire texture with rgb1, except for the bottom face of cube and skybox textures which is filled with rgb2.\"\"\"\n    rgb1: Optional[Vec3] = None\n    \"\"\"The first color used for procedural texture generation. This color is also used to fill missing sides of cube and skybox textures loaded from files. The components of this and all other RGB(A) vectors should be in the range [0 1].\"\"\"\n    rgb2: Optional[Vec3] = None\n    \"\"\"The second color used for procedural texture generation.\"\"\"\n    mark: Optional[Mark] = None\n    \"\"\"Procedural textures can be marked with the markrgb color, on top of the colors determined by the builtin type. \"edge\" means that the edges of all texture images are marked. \"cross\" means that a cross is marked in the middle of each image. \"random\" means that randomly chosen pixels are marked. All markings are one-pixel wide, thus the markings appear larger and more diffuse on smaller textures.\"\"\"\n    markrgb: Optional[Vec3] = None\n    \"\"\"The color used for procedural texture markings.\"\"\"\n    random: Optional[float] = None\n    \"\"\"When the mark attribute is set to \"random\", this attribute determines the probability of turning on each pixel. Note that larger textures have more pixels, and the probability here is applied independently to each pixel - thus the texture size and probability need to be adjusted jointly. Together with a gradient skybox texture, this can create the appearance of a night sky with stars. The random number generator is initialized with a fixed seed.\"\"\"\n    width: Optional[int] = None\n    \"\"\"The width of a procedural texture, i.e., the number of columns in the image. Larger values usually result in higher quality images, although in some cases (e.g. checker patterns) small values are sufficient. For textures loaded from files, this attribute is ignored.\"\"\"\n    height: Optional[int] = None\n    \"\"\"The height of the procedural texture, i.e., the number of rows in the image. For cube and skybox textures, this attribute is ignored and the height is set to 6 times the width. For textures loaded from files, this attribute is ignored.\"\"\"\n    hflip: Optional[bool] = None\n    \"\"\"If true, images loaded from file are flipped in the horizontal direction. Does not affect procedural textures.\"\"\"\n    vflip: Optional[bool] = None\n    \"\"\"If true, images loaded from file are flipped in the vertical direction. Does not affect procedural textures.\"\"\"\n    nchannel: Optional[int] = None\n    \"\"\"The number of channels in the texture image file. This allows loading 4-channel textures (RGBA) or single-channel textures (e.g., for Physics-Based Rendering properties such as roughness or metallic).\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.builtin","title":"builtin  <code>instance-attribute</code>","text":"Python<pre><code>builtin: TextureProcedural\n</code></pre> <p>This and the remaining attributes control the generation of procedural textures. If the value of this attribute is different from \"none\", the texture is treated as procedural and any file names are ignored. The keywords have the following meaning: * gradient     * Generates a color gradient from rgb1 to rgb2. The interpolation in color space is done through a sigmoid function. For cube and skybox textures the gradient is along the +Y axis, i.e., from top to bottom for skybox rendering. * checker     * Generates a 2-by-2 checker pattern with alternating colors given by rgb1 and rgb2. This is suitable for rendering ground planes and also for marking objects with rotational symmetries. Note that 2d textures can be scaled so as to repeat the pattern as many times as necessary. For cube and skybox textures, the checker pattern is painted on each side of the cube. * flat     * Fills the entire texture with rgb1, except for the bottom face of cube and skybox textures which is filled with rgb2.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.colorspace","title":"colorspace  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>colorspace: Optional[ColorSpace] = None\n</code></pre> <p>This attribute determines the color space of the texture. The default value auto means that the color space will be determined from the image file itself. If no color space is defined in the file, then linear is assumed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>content_type: Optional[str] = None\n</code></pre> <p>If the file attribute is specified, then this sets the Media Type (formerly known as MIME types) of the file to be loaded. Any filename extensions will be ignored. Currently image/png, image/ktx, and image/vnd.mujoco.texture are supported.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>file: Optional[Path] = None\n</code></pre> <p>If this attribute is specified, and the builtin attribute below is set to \"none\", the texture data is loaded from a single file. See the texturedir attribute of compiler regarding the file path.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.fileback","title":"fileback  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileback: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.filedown","title":"filedown  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filedown: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.filefront","title":"filefront  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filefront: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.fileleft","title":"fileleft  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileleft: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.fileright","title":"fileright  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileright: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.fileup","title":"fileup  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fileup: Optional[Path] = None\n</code></pre> <p>These attributes are used to load the six sides of a cube or skybox texture from separate files, but only if the file attribute is omitted and the builtin attribute is set to \"none\". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the rgb1 attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows: Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.gridlayout","title":"gridlayout  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridlayout: Optional[str] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, and the grid size is different from \"1 1\", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the rgb1 attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using gridsize = \"3 4\" and gridlayout = \".U..LFRB.D..\" The full-resolution image file without the markings can be downloaded here.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.gridsize","title":"gridsize  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gridsize: Optional[Tuple[int, int]] = None\n</code></pre> <p>When a cube or skybox texture is loaded from a single file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting \"1 1\" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.height","title":"height  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>height: Optional[int] = None\n</code></pre> <p>The height of the procedural texture, i.e., the number of rows in the image. For cube and skybox textures, this attribute is ignored and the height is set to 6 times the width. For textures loaded from files, this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.hflip","title":"hflip  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>hflip: Optional[bool] = None\n</code></pre> <p>If true, images loaded from file are flipped in the horizontal direction. Does not affect procedural textures.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.mark","title":"mark  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mark: Optional[Mark] = None\n</code></pre> <p>Procedural textures can be marked with the markrgb color, on top of the colors determined by the builtin type. \"edge\" means that the edges of all texture images are marked. \"cross\" means that a cross is marked in the middle of each image. \"random\" means that randomly chosen pixels are marked. All markings are one-pixel wide, thus the markings appear larger and more diffuse on smaller textures.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.markrgb","title":"markrgb  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>markrgb: Optional[Vec3] = None\n</code></pre> <p>The color used for procedural texture markings.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the file attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not \"skybox\", the compiler will generate an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.nchannel","title":"nchannel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nchannel: Optional[int] = None\n</code></pre> <p>The number of channels in the texture image file. This allows loading 4-channel textures (RGBA) or single-channel textures (e.g., for Physics-Based Rendering properties such as roughness or metallic).</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.random","title":"random  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>random: Optional[float] = None\n</code></pre> <p>When the mark attribute is set to \"random\", this attribute determines the probability of turning on each pixel. Note that larger textures have more pixels, and the probability here is applied independently to each pixel - thus the texture size and probability need to be adjusted jointly. Together with a gradient skybox texture, this can create the appearance of a night sky with stars. The random number generator is initialized with a fixed seed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.rgb1","title":"rgb1  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgb1: Optional[Vec3] = None\n</code></pre> <p>The first color used for procedural texture generation. This color is also used to fill missing sides of cube and skybox textures loaded from files. The components of this and all other RGB(A) vectors should be in the range [0 1].</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.rgb2","title":"rgb2  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>rgb2: Optional[Vec3] = None\n</code></pre> <p>The second color used for procedural texture generation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[Type] = None\n</code></pre> <p>This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:</p> <p>The cube type has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the texuniform attribute of material, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data:</p> <ol> <li>Single file (PNG or custom) specified with the file attribute, containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.</li> <li>Single file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the gridsize and gridlayout attributes.</li> <li>Six separate files specified with the attributes fileright, fileleft etc, each containing one square image.</li> <li>Procedural texture generated internally. The type of procedural texture is determined by the builtin attribute. The texture data also depends on a number of parameters documented below.</li> </ol> <p>The skybox type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.</p> <p>The 2d type maps a 2D image to a 3D object using texture coordinates (a.k.a UV coordinates). However, UV coordinates are only available for meshes. For primitive geoms, the texture is mapped to the object surface using the local XY coordinates of the geom, effectively projecting the texture along the Z axis. This sort of mapping is only suitable for planes and height fields, since their top surfaces always face the Z axis. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the texrepeat attribute of material. The data can be loaded from a single file or created procedurally.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.vflip","title":"vflip  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>vflip: Optional[bool] = None\n</code></pre> <p>If true, images loaded from file are flipped in the vertical direction. Does not affect procedural textures.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>width: Optional[int] = None\n</code></pre> <p>The width of a procedural texture, i.e., the number of columns in the image. Larger values usually result in higher quality images, although in some cases (e.g. checker patterns) small values are sufficient. For textures loaded from files, this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/texture/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.texture.TextureProcedural.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/","title":"material_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material_attr\\layer.py</code> Python<pre><code>class Layer(XMLModel):\n    \"\"\"If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.\"\"\"\n\n    tag = \"layer\"\n\n    attributes = (\n        \"texture\",\n        \"role\",\n    )\n\n    texture: str\n    \"\"\"Name of the texture, like the texture attribute.\"\"\"\n    role: str\n    \"\"\"Role of the texture. The valid values, expected number of channels, and the role semantics are:\n\n    | value     | channels | description                                                  |\n    |:----------|:---------|:-------------------------------------------------------------|\n    | rgb       | 3        | base color / albedo [red, green, blue]                       |\n    | normal    | 3        | bump map (surface normals)                                   |\n    | occlusion | 1        | ambient occlusion                                            |\n    | roughness | 1        | roughness                                                    |\n    | metallic  | 1        | metallicity                                                  |\n    | opacity   | 1        | opacity (alpha channel)                                      |\n    | emissive  | 4        | RGB light emmision intensity, exposure weight in 4th channel |\n    | orm       | 3        | packed 3 channel [occlusion, roughness, metallic]            |\n    | rgba      | 4        | packed 4 channel [red, green, blue, alpha]                   |\n    \"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: str\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: str\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/","title":"layer","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer","title":"Layer","text":"<p>               Bases: <code>XMLModel</code></p> <p>If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\material_attr\\layer.py</code> Python<pre><code>class Layer(XMLModel):\n    \"\"\"If multiple textures are needed to specify the appearance of a material, the texture attribute cannot be used, and layer child elements must be used instead. Specifying both the texture attribute and layer child elements is an error.\"\"\"\n\n    tag = \"layer\"\n\n    attributes = (\n        \"texture\",\n        \"role\",\n    )\n\n    texture: str\n    \"\"\"Name of the texture, like the texture attribute.\"\"\"\n    role: str\n    \"\"\"Role of the texture. The valid values, expected number of channels, and the role semantics are:\n\n    | value     | channels | description                                                  |\n    |:----------|:---------|:-------------------------------------------------------------|\n    | rgb       | 3        | base color / albedo [red, green, blue]                       |\n    | normal    | 3        | bump map (surface normals)                                   |\n    | occlusion | 1        | ambient occlusion                                            |\n    | roughness | 1        | roughness                                                    |\n    | metallic  | 1        | metallicity                                                  |\n    | opacity   | 1        | opacity (alpha channel)                                      |\n    | emissive  | 4        | RGB light emmision intensity, exposure weight in 4th channel |\n    | orm       | 3        | packed 3 channel [occlusion, roughness, metallic]            |\n    | rgba      | 4        | packed 4 channel [red, green, blue, alpha]                   |\n    \"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.role","title":"role  <code>instance-attribute</code>","text":"Python<pre><code>role: str\n</code></pre> <p>Role of the texture. The valid values, expected number of channels, and the role semantics are:</p> value channels description rgb 3 base color / albedo [red, green, blue] normal 3 bump map (surface normals) occlusion 1 ambient occlusion roughness 1 roughness metallic 1 metallicity opacity 1 opacity (alpha channel) emissive 4 RGB light emmision intensity, exposure weight in 4th channel orm 3 packed 3 channel [occlusion, roughness, metallic] rgba 4 packed 4 channel [red, green, blue, alpha]"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.texture","title":"texture  <code>instance-attribute</code>","text":"Python<pre><code>texture: str\n</code></pre> <p>Name of the texture, like the texture attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/material_attr/layer/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.material_attr.layer.Layer.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/","title":"mesh_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh_attr\\plugin.py</code> Python<pre><code>class Plugin(XMLModel):\n    \"\"\"Associate this mesh with an engine plugin. Either plugin or instance are required.\"\"\"\n\n    tag = \"plugin\"\n\n    attributes = (\"plugin\", \"instance\")\n\n    plugin: Optional[str] = None\n    \"\"\"Plugin identifier, used for implicit plugin instantiation.\"\"\"\n    instance: Optional[str] = None  # TODO I think this was implemented poorly\n    \"\"\"Instance name, used for explicit plugin instantiation.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: Optional[str] = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Optional[str] = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/","title":"plugin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.plugin.Plugin","title":"Plugin","text":"<p>               Bases: <code>XMLModel</code></p> <p>Associate this mesh with an engine plugin. Either plugin or instance are required.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\asset_attr\\mesh_attr\\plugin.py</code> Python<pre><code>class Plugin(XMLModel):\n    \"\"\"Associate this mesh with an engine plugin. Either plugin or instance are required.\"\"\"\n\n    tag = \"plugin\"\n\n    attributes = (\"plugin\", \"instance\")\n\n    plugin: Optional[str] = None\n    \"\"\"Plugin identifier, used for implicit plugin instantiation.\"\"\"\n    instance: Optional[str] = None  # TODO I think this was implemented poorly\n    \"\"\"Instance name, used for explicit plugin instantiation.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.plugin.Plugin.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.plugin.Plugin.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.plugin.Plugin.instance","title":"instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>instance: Optional[str] = None\n</code></pre> <p>Instance name, used for explicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.plugin.Plugin.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>plugin: Optional[str] = None\n</code></pre> <p>Plugin identifier, used for implicit plugin instantiation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.plugin.Plugin.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/asset_attr/mesh_attr/plugin/#mujoco_mojo.mjcf.mujoco_attr.asset_attr.mesh_attr.plugin.Plugin.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/","title":"body_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\free_joint.py</code> Python<pre><code>class FreeJoint(XMLModel):\n    \"\"\"This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for\n\n    ``` xml\n    &lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n    ```\n\n    While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.\"\"\"\n\n    tag = \"joint\"\n    type: ClassVar[JointType] = JointType.FREE\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    align: Optional[Align] = None\n    \"\"\"When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.\n\n    Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.\n\n    Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Optional[Align] = None\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\inertial.py</code> Python<pre><code>class Inertial(XMLModel):\n    \"\"\"This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.\"\"\"\n\n    tag = \"inertial\"\n\n    attributes = (\n        \"pos\",\n        \"quat\",\n        \"mass\",\n        \"diaginertia\",\n        \"axisangle\",\n        \"xyaxes\",\n        \"zaxis\",\n        \"euler\",\n        \"fullinertia\",\n    )\n    __exclusive_groups__ = (frame_orientations, (\"diaginertia\", \"fullinertia\"))\n\n    pos: Vec3\n    \"\"\"Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.\"\"\"\n    quat: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    axisangle: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    mass: float\n    \"\"\"Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.\"\"\"\n    diaginertia: Optional[Vec3] = None\n    \"\"\"Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.\"\"\"\n    fullinertia: Optional[Vec6] = None\n    \"\"\"Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.\"\"\"\n\n    @property\n    def using_diag(self) -&gt; bool:\n        if self.diaginertia is not None and self.fullinertia is None:\n            return True\n        if self.diaginertia is None and self.fullinertia is not None:\n            return False\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Neither diaginertia nor fullinertia were specified.\")\n        raise ValueError(\"Both diaginertia and fullinertia were specified (invalid).\")\n\n    @property\n    def inertia_matrix(self) -&gt; np.ndarray:\n        if self.using_diag:\n            d = self.diaginertia\n            assert d is not None\n            return np.diag(np.asarray(d))\n\n        f = np.asarray(self.fullinertia)\n        assert f is not None\n\n        return np.array(\n            [\n                [f[0], f[3], f[4]],\n                [f[3], f[1], f[5]],\n                [f[4], f[5], f[2]],\n            ],\n            dtype=np.float64,\n        )\n\n    @property\n    def i_xx(self) -&gt; float:\n        return float(self.inertia_matrix[0, 0])\n\n    @property\n    def i_yy(self) -&gt; float:\n        return float(self.inertia_matrix[1, 1])\n\n    @property\n    def i_zz(self) -&gt; float:\n        return float(self.inertia_matrix[2, 2])\n\n    @property\n    def i_xy(self) -&gt; float:\n        return float(self.inertia_matrix[0, 1])\n\n    @property\n    def i_xz(self) -&gt; float:\n        return float(self.inertia_matrix[0, 2])\n\n    @property\n    def i_yz(self) -&gt; float:\n        return float(self.inertia_matrix[1, 2])\n\n    @property\n    def i_yx(self) -&gt; float:\n        return self.i_xy\n\n    @property\n    def i_zx(self) -&gt; float:\n        return self.i_xz\n\n    @property\n    def i_zy(self) -&gt; float:\n        return self.i_yz\n\n    @field_validator(\"mass\")\n    @classmethod\n    def validate_mass(cls, v: float) -&gt; float:\n        if not np.isfinite(v):\n            raise ValueError(\"mass must be finite\")\n        if v &lt; 0:\n            raise ValueError(\"mass must be non-negative\")\n        return v\n\n    @field_validator(\"diaginertia\")\n    @classmethod\n    def validate_diaginertia(cls, v: Vec3 | None) -&gt; Vec3 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (3,):\n            raise ValueError(\"diaginertia must be length 3\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"diaginertia must be finite\")\n\n        if np.any(arr &lt;= 0):\n            raise ValueError(\"diaginertia values must be positive\")\n\n        return arr\n\n    @field_validator(\"fullinertia\")\n    @classmethod\n    def validate_fullinertia(cls, v: Vec6 | None) -&gt; Vec6 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (6,):\n            raise ValueError(\"fullinertia must have length 6\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"fullinertia must be finite\")\n\n        return arr\n\n    @model_validator(mode=\"after\")\n    def validate_inertia_physics(self) -&gt; Inertial:\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Either diaginertia or fullinertia must be specified\")\n\n        if self.diaginertia is not None and self.fullinertia is not None:\n            raise ValueError(\"Only one of diaginertia or fullinertia may be specified\")\n\n        M = self.inertia_matrix\n\n        # Symmetry sanity check (numerical)\n        if not np.allclose(M, M.T, atol=1e-12):\n            raise ValueError(\"Inertia matrix is not symmetric\")\n\n        # Eigenvalue check (MuJoCo uses this too)\n        eigvals = np.linalg.eigvalsh(M)\n\n        if np.any(eigvals &lt;= 0):\n            raise ValueError(\n                f\"Inertia matrix must be positive definite. Eigenvalues: {eigvals}\"\n            )\n\n        return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Optional[Vec3] = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Optional[Vec6] = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\joint.py</code> Python<pre><code>class Joint(XMLModel):\n    \"\"\"This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.\"\"\"\n\n    tag = \"joint\"\n\n    attributes = ()\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    type: Optional[JointType] = None\n    \"\"\"Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.\n\n    The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.\n\n    The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.\n\n    The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    pos: Optional[Vec3] = None\n    \"\"\"Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.\"\"\"\n    axis: Optional[Vec3] = None\n    \"\"\"This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.\"\"\"\n    springdamper: Optional[Vec2] = None\n    \"\"\"When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.\"\"\"\n    solreflimit: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solimplimit: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solreffriction: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    solimpfriction: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    stiffness: Optional[float] = None\n    \"\"\"Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.\"\"\"\n    range: Optional[Vec2] = None\n    \"\"\"The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.\n    Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.\"\"\"\n    limited: Optional[Limited] = None\n    \"\"\"This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.\"\"\"\n    actuatorfrcrange: Optional[Vec2] = None\n    \"\"\"Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    The compiler expects the first value to be smaller than the second value.\n    Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".\"\"\"\n    actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n    \"\"\"This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.\"\"\"\n    actuatorgravcomp: Optional[bool] = None\n    \"\"\"If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.\"\"\"\n    margin: Optional[float] = None\n    \"\"\"The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.\"\"\"\n    ref: Optional[float] = None\n    \"\"\"The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.\"\"\"\n    springref: Optional[float] = None\n    \"\"\"The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.\"\"\"\n    armature: Optional[float] = None\n    \"\"\"Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.\n\n    Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.\"\"\"\n    damping: Optional[float] = None\n    \"\"\"Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.\"\"\"\n    frictionloss: Optional[float] = None\n    \"\"\"Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Optional[Vec2] = None\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: Optional[bool] = None\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: Optional[float] = None\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[float] = None\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[float] = None\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Optional[Limited] = None\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: Optional[float] = None\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Optional[Vec2] = None\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: Optional[float] = None\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Optional[Vec2] = None\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: Optional[float] = None\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: Optional[float] = None\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[JointType] = None\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/#mujoco_mojo.mjcf.mujoco_attr.body_attr.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/attach/","title":"attach","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/camera/","title":"camera","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/composite/","title":"composite","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/flexcomp/","title":"flexcomp","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/frame/","title":"frame","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/","title":"free_joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint","title":"FreeJoint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for</p> XML<pre><code>&lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n</code></pre> <p>While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\free_joint.py</code> Python<pre><code>class FreeJoint(XMLModel):\n    \"\"\"This element creates a free joint whose only attributes are name and group. The freejoint element is an XML shortcut for\n\n    ``` xml\n    &lt;joint type=\"free\" stiffness=\"0\" damping=\"0\" frictionloss=\"0\" armature=\"0\"/&gt;\n    ```\n\n    While this joint can evidently be created with the joint element, default joint settings could affect it. This is usually undesirable as physical free bodies do not have nonzero stiffness, damping, friction or armature. To avoid this complication, the freejoint element was introduced, ensuring joint defaults are not inherited. If the XML model is saved, it will appear as a regular joint of type free.\"\"\"\n\n    tag = \"joint\"\n    type: ClassVar[JointType] = JointType.FREE\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    align: Optional[Align] = None\n    \"\"\"When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.\n\n    Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.\n\n    Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.align","title":"align  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>align: Optional[Align] = None\n</code></pre> <p>When set to true, the body frame and free joint will automatically be aligned with inertial frame. When set to false, no alignment will occur. When set to auto, the compiler's alignfree global attribute will be respected.</p> <p>Inertial frame alignment is an optimization only applies to bodies with a free joint and no child bodies (\"simple free bodies\"). The alignment diagonalizes the 6x6 inertia matrix and minimizes bias forces, leading to faster and more stable simulation. While this behaviour is a strict improvement, it modifies the semantics of the free joint, making qpos and qvel values saved in older versions (for example, in keyframes) invalid.</p> <p>Note that the align attribute is never saved to XML. Instead, the pose of simple free bodies and their children will be modified such that the body frame and inertial frame are aligned.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.attributes","title":"attributes  <code>class-attribute</code>","text":"Python<pre><code>attributes: tuple[str, ...] = ()\n</code></pre> <p>Attributes of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/free_joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.free_joint.FreeJoint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/geom/","title":"geom","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/","title":"inertial","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial","title":"Inertial","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\inertial.py</code> Python<pre><code>class Inertial(XMLModel):\n    \"\"\"This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.\"\"\"\n\n    tag = \"inertial\"\n\n    attributes = (\n        \"pos\",\n        \"quat\",\n        \"mass\",\n        \"diaginertia\",\n        \"axisangle\",\n        \"xyaxes\",\n        \"zaxis\",\n        \"euler\",\n        \"fullinertia\",\n    )\n    __exclusive_groups__ = (frame_orientations, (\"diaginertia\", \"fullinertia\"))\n\n    pos: Vec3\n    \"\"\"Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.\"\"\"\n    quat: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    axisangle: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    xyaxes: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    zaxis: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    euler: Optional[Vec3] = None\n    \"\"\"Orientation of the inertial frame. See Frame orientations.\"\"\"\n    mass: float\n    \"\"\"Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.\"\"\"\n    diaginertia: Optional[Vec3] = None\n    \"\"\"Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.\"\"\"\n    fullinertia: Optional[Vec6] = None\n    \"\"\"Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.\"\"\"\n\n    @property\n    def using_diag(self) -&gt; bool:\n        if self.diaginertia is not None and self.fullinertia is None:\n            return True\n        if self.diaginertia is None and self.fullinertia is not None:\n            return False\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Neither diaginertia nor fullinertia were specified.\")\n        raise ValueError(\"Both diaginertia and fullinertia were specified (invalid).\")\n\n    @property\n    def inertia_matrix(self) -&gt; np.ndarray:\n        if self.using_diag:\n            d = self.diaginertia\n            assert d is not None\n            return np.diag(np.asarray(d))\n\n        f = np.asarray(self.fullinertia)\n        assert f is not None\n\n        return np.array(\n            [\n                [f[0], f[3], f[4]],\n                [f[3], f[1], f[5]],\n                [f[4], f[5], f[2]],\n            ],\n            dtype=np.float64,\n        )\n\n    @property\n    def i_xx(self) -&gt; float:\n        return float(self.inertia_matrix[0, 0])\n\n    @property\n    def i_yy(self) -&gt; float:\n        return float(self.inertia_matrix[1, 1])\n\n    @property\n    def i_zz(self) -&gt; float:\n        return float(self.inertia_matrix[2, 2])\n\n    @property\n    def i_xy(self) -&gt; float:\n        return float(self.inertia_matrix[0, 1])\n\n    @property\n    def i_xz(self) -&gt; float:\n        return float(self.inertia_matrix[0, 2])\n\n    @property\n    def i_yz(self) -&gt; float:\n        return float(self.inertia_matrix[1, 2])\n\n    @property\n    def i_yx(self) -&gt; float:\n        return self.i_xy\n\n    @property\n    def i_zx(self) -&gt; float:\n        return self.i_xz\n\n    @property\n    def i_zy(self) -&gt; float:\n        return self.i_yz\n\n    @field_validator(\"mass\")\n    @classmethod\n    def validate_mass(cls, v: float) -&gt; float:\n        if not np.isfinite(v):\n            raise ValueError(\"mass must be finite\")\n        if v &lt; 0:\n            raise ValueError(\"mass must be non-negative\")\n        return v\n\n    @field_validator(\"diaginertia\")\n    @classmethod\n    def validate_diaginertia(cls, v: Vec3 | None) -&gt; Vec3 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (3,):\n            raise ValueError(\"diaginertia must be length 3\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"diaginertia must be finite\")\n\n        if np.any(arr &lt;= 0):\n            raise ValueError(\"diaginertia values must be positive\")\n\n        return arr\n\n    @field_validator(\"fullinertia\")\n    @classmethod\n    def validate_fullinertia(cls, v: Vec6 | None) -&gt; Vec6 | None:\n        if v is None:\n            return v\n\n        arr = np.asarray(v, dtype=np.float64)\n\n        if arr.shape != (6,):\n            raise ValueError(\"fullinertia must have length 6\")\n\n        if not np.all(np.isfinite(arr)):\n            raise ValueError(\"fullinertia must be finite\")\n\n        return arr\n\n    @model_validator(mode=\"after\")\n    def validate_inertia_physics(self) -&gt; Inertial:\n        if self.diaginertia is None and self.fullinertia is None:\n            raise ValueError(\"Either diaginertia or fullinertia must be specified\")\n\n        if self.diaginertia is not None and self.fullinertia is not None:\n            raise ValueError(\"Only one of diaginertia or fullinertia may be specified\")\n\n        M = self.inertia_matrix\n\n        # Symmetry sanity check (numerical)\n        if not np.allclose(M, M.T, atol=1e-12):\n            raise ValueError(\"Inertia matrix is not symmetric\")\n\n        # Eigenvalue check (MuJoCo uses this too)\n        eigvals = np.linalg.eigvalsh(M)\n\n        if np.any(eigvals &lt;= 0):\n            raise ValueError(\n                f\"Inertia matrix must be positive definite. Eigenvalues: {eigvals}\"\n            )\n\n        return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.axisangle","title":"axisangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axisangle: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.diaginertia","title":"diaginertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>diaginertia: Optional[Vec3] = None\n</code></pre> <p>Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.euler","title":"euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>euler: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.fullinertia","title":"fullinertia  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fullinertia: Optional[Vec6] = None\n</code></pre> <p>Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e., if M is not positive definite) a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.mass","title":"mass  <code>instance-attribute</code>","text":"Python<pre><code>mass: float\n</code></pre> <p>Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.pos","title":"pos  <code>instance-attribute</code>","text":"Python<pre><code>pos: Vec3\n</code></pre> <p>Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the inertial element itself disables the automatic inference mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.quat","title":"quat  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>quat: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.xyaxes","title":"xyaxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>xyaxes: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.zaxis","title":"zaxis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>zaxis: Optional[Vec3] = None\n</code></pre> <p>Orientation of the inertial frame. See Frame orientations.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/inertial/#mujoco_mojo.mjcf.mujoco_attr.body_attr.inertial.Inertial.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/","title":"joint","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint","title":"Joint","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\body_attr\\joint.py</code> Python<pre><code>class Joint(XMLModel):\n    \"\"\"This element creates a joint. As explained in Kinematic tree, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.\"\"\"\n\n    tag = \"joint\"\n\n    attributes = ()\n\n    name: Optional[str] = None\n    \"\"\"Name of the joint.\"\"\"\n    class_: Optional[str] = None\n    \"\"\"Defaults class for setting unspecified attributes.\"\"\"\n    type: Optional[JointType] = None\n    \"\"\"Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.\n\n    The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.\n\n    The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.\n\n    The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.\"\"\"\n    group: Optional[int] = None\n    \"\"\"Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.\"\"\"\n    pos: Optional[Vec3] = None\n    \"\"\"Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.\"\"\"\n    axis: Optional[Vec3] = None\n    \"\"\"This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.\"\"\"\n    springdamper: Optional[Vec2] = None\n    \"\"\"When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.\"\"\"\n    solreflimit: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solimplimit: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating joint limits. See Solver parameters.\"\"\"\n    solreffriction: Optional[Vec2] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    solimpfriction: Optional[Vec5] = None\n    \"\"\"Constraint solver parameters for simulating dry friction. See Solver parameters.\"\"\"\n    stiffness: Optional[float] = None\n    \"\"\"Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.\"\"\"\n    range: Optional[Vec2] = None\n    \"\"\"The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information.\n    Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.\"\"\"\n    limited: Optional[Limited] = None\n    \"\"\"This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.\"\"\"\n    actuatorfrcrange: Optional[Vec2] = None\n    \"\"\"Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    The compiler expects the first value to be smaller than the second value.\n    Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".\"\"\"\n    actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n    \"\"\"This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints.\n    This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.\"\"\"\n    actuatorgravcomp: Optional[bool] = None\n    \"\"\"If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.\"\"\"\n    margin: Optional[float] = None\n    \"\"\"The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.\"\"\"\n    ref: Optional[float] = None\n    \"\"\"The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.\"\"\"\n    springref: Optional[float] = None\n    \"\"\"The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.\"\"\"\n    armature: Optional[float] = None\n    \"\"\"Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.\n\n    Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.\"\"\"\n    damping: Optional[float] = None\n    \"\"\"Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.\"\"\"\n    frictionloss: Optional[float] = None\n    \"\"\"Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.\"\"\"\n    user: Optional[VecN] = None\n    \"\"\"See User parameters.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.actuatorfrclimited","title":"actuatorfrclimited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrclimited: Optional[ActuatorFrcLimited] = None\n</code></pre> <p>This attribute specifies whether actuator forces acting on the joint should be clamped. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. This attribute interacts with the actuatorfrcrange attribute. If this attribute is \"false\", actuator force clamping is disabled. If it is \"true\", actuator force clamping is enabled. If this attribute is \"auto\", and autolimits is set in compiler, actuator force clamping will be enabled if actuatorfrcrange is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.actuatorfrcrange","title":"actuatorfrcrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorfrcrange: Optional[Vec2] = None\n</code></pre> <p>Range for clamping total actuator forces acting on this joint. See Force limits for details. It is available only for scalar joints (hinge and slider) and ignored for ball and free joints. The compiler expects the first value to be smaller than the second value. Setting this attribute without specifying actuatorfrclimited is an error if compiler-autolimits is \"false\".</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.actuatorgravcomp","title":"actuatorgravcomp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuatorgravcomp: Optional[bool] = None\n</code></pre> <p>If this flag is enabled, gravity compensation applied to this joint is added to actuator forces (mjData.qfrc_actuator) rather than passive forces (mjData.qfrc_passive). Notionally, this means that gravity compensation is the result of a control system rather than natural buoyancy. In practice, enabling this flag is useful when joint-level actuator force clamping is used. In this case, the total actuation force applied on a joint, including gravity compensation, is guaranteed to not exceed the specified limits. See Force limits and actuatorfrcrange for more details on this type of force limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.armature","title":"armature  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>armature: Optional[float] = None\n</code></pre> <p>Additional inertia associated with movement of the joint that is not due to body mass. This added inertia is usually due to a rotor (a.k.a armature) spinning faster than the joint itself due to a geared transmission. In the illustration, we compare (left) a 2-dof system with an armature body (purple box), coupled with a gear ratio of 33 to the pendulum using a joint equality constraint, and (right) a simple 1-dof pendulum with an equivalent armature. Because the gear ratio appears twice, multiplying both forces and lengths, the effect is known as \"reflected inertia\" and the equivalent value is the inertia of the spinning body multiplied by the square of the gear ratio, in this case 9=329=32. The value applies to all degrees of freedom created by this joint.</p> <p>Besides increasing the realism of joints with geared transmission, positive armature significantly improves simulation stability, even for small values, and is a recommended possible fix when encountering stability issues.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.axis","title":"axis  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>axis: Optional[Vec3] = None\n</code></pre> <p>This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.class_","title":"class_  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>class_: Optional[str] = None\n</code></pre> <p>Defaults class for setting unspecified attributes.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[float] = None\n</code></pre> <p>Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See Integration in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[float] = None\n</code></pre> <p>Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>group: Optional[int] = None\n</code></pre> <p>Integer group to which the joint belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.limited","title":"limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limited: Optional[Limited] = None\n</code></pre> <p>This attribute specifies if the joint has limits. It interacts with the range attribute. If this attribute is \"false\", joint limits are disabled. If this attribute is \"true\", joint limits are enabled. If this attribute is \"auto\", and autolimits is set in compiler, joint limits will be enabled if range is defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.margin","title":"margin  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>margin: Optional[float] = None\n</code></pre> <p>The distance threshold below which limits become active. Recall that the Constraint solver normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with solreflimit and solimplimit can be used to model a soft joint limit.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>name: Optional[str] = None\n</code></pre> <p>Name of the joint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.pos","title":"pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>pos: Optional[Vec3] = None\n</code></pre> <p>Position of the joint, specified in the frame of the body where the joint is defined. For free joints this attribute is ignored.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.range","title":"range  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>range: Optional[Vec2] = None\n</code></pre> <p>The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the angle attribute of compiler. For ball joints, the limit is imposed on the angle of rotation (relative to the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the Limit section in the Computation chapter for more information. Setting this attribute without specifying limited is an error if autolimits is \"false\" in compiler.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>ref: Optional[float] = None\n</code></pre> <p>The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. Note that the initial configuration itself is unmodified, only the value of the joint at this configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors is discussed in the Kinematic tree section in the Overview chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solimpfriction","title":"solimpfriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimpfriction: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solimplimit","title":"solimplimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solimplimit: Optional[Vec5] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solreffriction","title":"solreffriction  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreffriction: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating dry friction. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.solreflimit","title":"solreflimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>solreflimit: Optional[Vec2] = None\n</code></pre> <p>Constraint solver parameters for simulating joint limits. See Solver parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.springdamper","title":"springdamper  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springdamper: Optional[Vec2] = None\n</code></pre> <p>When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.springref","title":"springref  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>springref: Optional[float] = None\n</code></pre> <p>The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the ref attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because tendons can also have springs.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.stiffness","title":"stiffness  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>stiffness: Optional[float] = None\n</code></pre> <p>Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by springref below. The spring force is computed along with the other passive forces.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>type: Optional[JointType] = None\n</code></pre> <p>Type of the joint. The keywords have the following meaning: The free type creates a free \"joint\" with three translational degrees of freedom followed by three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.</p> <p>The ball type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the pos attribute. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.</p> <p>The slide type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.</p> <p>The hinge type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contain only hinge and free joints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>user: Optional[VecN] = None\n</code></pre> <p>See User parameters.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/joint/#mujoco_mojo.mjcf.mujoco_attr.body_attr.joint.Joint.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/light/","title":"light","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/plugin/","title":"plugin","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/body_attr/site/","title":"site","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/","title":"compiler_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler_attr\\lengthrange.py</code> Python<pre><code>class LengthRange(XMLModel):\n    \"\"\"This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".\"\"\"\n\n    attributes = (\n        \"mode\",\n        \"useexisting\",\n        \"uselimit\",\n        \"accel\",\n        \"maxforce\",\n        \"timeconst\",\n        \"timestep\",\n        \"inttotal\",\n        \"interval\",\n        \"tolrange\",\n    )\n\n    mode: Optional[Mode] = None\n    \"\"\"Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.\"\"\"\n    useexisting: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.\"\"\"\n    uselimit: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.\"\"\"\n    accel: Optional[float] = None\n    \"\"\"This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.\"\"\"\n    maxforce: Optional[float] = None\n    \"\"\"The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.\"\"\"\n    timeconst: Optional[float] = None\n    \"\"\"The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.\"\"\"\n    timestep: Optional[float] = None\n    \"\"\"The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.\"\"\"\n    inttotal: Optional[float] = None\n    \"\"\"The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.\"\"\"\n    interval: Optional[float] = None\n    \"\"\"The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.\"\"\"\n    tolrange: Optional[float] = None\n    \"\"\"This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: Optional[float] = None\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: Optional[float] = None\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: Optional[float] = None\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: Optional[float] = None\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: Optional[Mode] = None\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: Optional[float] = None\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: Optional[float] = None\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/","title":"lengthrange","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange","title":"LengthRange","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\compiler_attr\\lengthrange.py</code> Python<pre><code>class LengthRange(XMLModel):\n    \"\"\"This element controls the computation of actuator length ranges. For an overview of this functionality see Length range section. Note that if this element is omitted the defaults shown below still apply. In order to disable length range computations altogether, include this element and set mode=\"none\".\"\"\"\n\n    attributes = (\n        \"mode\",\n        \"useexisting\",\n        \"uselimit\",\n        \"accel\",\n        \"maxforce\",\n        \"timeconst\",\n        \"timestep\",\n        \"inttotal\",\n        \"interval\",\n        \"tolrange\",\n    )\n\n    mode: Optional[Mode] = None\n    \"\"\"Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.\"\"\"\n    useexisting: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.\"\"\"\n    uselimit: Optional[bool] = None\n    \"\"\"If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.\"\"\"\n    accel: Optional[float] = None\n    \"\"\"This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.\"\"\"\n    maxforce: Optional[float] = None\n    \"\"\"The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.\"\"\"\n    timeconst: Optional[float] = None\n    \"\"\"The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.\"\"\"\n    timestep: Optional[float] = None\n    \"\"\"The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.\"\"\"\n    inttotal: Optional[float] = None\n    \"\"\"The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.\"\"\"\n    interval: Optional[float] = None\n    \"\"\"The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.\"\"\"\n    tolrange: Optional[float] = None\n    \"\"\"This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.accel","title":"accel  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>accel: Optional[float] = None\n</code></pre> <p>This attribute scales the forces applied to the simulation in order to push each actuator to its smallest and largest length. The force magnitude is computed so that the resulting joint-space acceleration vector has norm equal to this attribute.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>interval: Optional[float] = None\n</code></pre> <p>The time interval at the end of the simulation over which length data is collected and analyzed. The maximum (or respectively minimum) length achieved during this interval is recorded. The difference between the maximum and minimum is also recorded and is used as a measure of divergence. If the simulation settles, this difference will be small. If it is not small, this could be because the simulation has not yet settled - in which case the above attributes should be adjusted - or because the model does not have sufficient joint and tendon limits and so the actuator range is effectively unlimited. Both of these conditions cause the same compiler error. Recall that contacts are disabled in this simulation, so joint and tendon limits as well as overall geometry are the only things that can prevent actuators from having infinite length.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.inttotal","title":"inttotal  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>inttotal: Optional[float] = None\n</code></pre> <p>The total time interval (in seconds) for running the internal simulation, for each actuator and actuator direction. Each simulation is initialized at qpos0. It is expected to settle after inttotal time has passed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.maxforce","title":"maxforce  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>maxforce: Optional[float] = None\n</code></pre> <p>The force computed via the accel attribute above can be very large when the actuator has very small moments. Such a force will still produce reasonable acceleration (by construction) but large numbers could cause numerical issues. Although we have never observed such issues, the present attribute is provided as a safeguard. Setting it to a value larger than 0 limits the norm of the force being applied during simulation. The default setting of 0 disables this safeguard.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>mode: Optional[Mode] = None\n</code></pre> <p>Determines the type of actuators to which length range computation is applied. \"none\" disables this functionality. \"all\" applies it to all actuators. \"muscle\" applies it to actuators whose gaintype or biastype is set to \"muscle\". \"muscleuser\" applies it to actuators whose gaintype or biastype is set to either \"muscle\" or \"user\". The default is \"muscle\" because MuJoCo's muscle model requires actuator length ranges to be defined.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.tag","title":"tag  <code>class-attribute</code>","text":"Python<pre><code>tag: str\n</code></pre> <p>Tag name of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.timeconst","title":"timeconst  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timeconst: Optional[float] = None\n</code></pre> <p>The simulation is damped in a non-physical way so as to push the actuators to their limits without the risk of instabilities. This is done by simply scaling down the joint velocity at each time step. In the absence of new accelerations, such scaling will decrease the velocity exponentially. The timeconst attribute specifies the time constant of this exponential decrease, in seconds.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.timestep","title":"timestep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>timestep: Optional[float] = None\n</code></pre> <p>The timestep used for the internal simulation. Setting this to 0 will cause the model timestep to be used. The latter is not the default because models that can go unstable usually have small timesteps, while the simulation here is artificially damped and very stable. To speed up the length range computation, users can attempt to increase this value.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.tolrange","title":"tolrange  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>tolrange: Optional[float] = None\n</code></pre> <p>This determines the threshold for detecting divergence and generating a compiler error. The range of actuator lengths observed during interval is divided by the overall range computed via simulation. If that value is larger than tolrange, a compiler error is generated. So one way to suppress compiler errors is to simply make this attribute larger, but in that case the results could be inaccurate.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.useexisting","title":"useexisting  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>useexisting: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the length range for a given actuator is already defined in the model, the existing value will be used and the automatic computation will be skipped. The range is considered defined if the first number is smaller than the second number. The only reason to set this attribute to \"false\" is to force re-computation of actuator length ranges - which is needed when the model geometry is modified. Note that the automatic computation relies on simulation and can be slow, so saving the model and using the existing values when possible is recommended.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.uselimit","title":"uselimit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>uselimit: Optional[bool] = None\n</code></pre> <p>If this attribute is \"true\" and the actuator is attached to a joint or a tendon which has limits defined, these limits will be copied into the actuator length range and the automatic computation will be skipped. This may seem like a good idea but note that in complex models the feasible range of tendon actuators depends on the entire model, and may be smaller than the user-defined limits for that tendon. So the safer approach is to set this to \"false\", and let the automatic computation discover the feasible range.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/compiler_attr/lengthrange/#mujoco_mojo.mjcf.mujoco_attr.compiler_attr.lengthrange.LengthRange.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/","title":"option_attr","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option_attr\\flag.py</code> Python<pre><code>class Flag(XMLModel):\n    \"\"\"This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.\"\"\"\n\n    tag = \"flag\"\n\n    attributes = (\n        \"constraint\",\n        \"equality\",\n        \"frictionloss\",\n        \"limit\",\n        \"contact\",\n        \"spring\",\n        \"damping\",\n        \"gravity\",\n        \"clampctrl\",\n        \"warmstart\",\n        \"filterparent\",\n        \"actuation\",\n        \"refsafe\",\n        \"sensor\",\n        \"midphase\",\n        \"eulerdamp\",\n        \"autoreset\",\n        \"nativeccd\",\n        \"island\",\n        \"override\",\n        \"energy\",\n        \"fwdinv\",\n        \"invdiscrete\",\n        \"multiccd\",\n        \"sleep\",\n    )\n\n    constraint: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.\"\"\"\n    equality: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to equality constraints.\"\"\"\n    frictionloss: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to friction loss constraints.\"\"\"\n    limit: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to joint and tendon limit constraints.\"\"\"\n    contact: Optional[EnableDisable] = None\n    \"\"\"This flag disables collision detection and all standard computations related to contact constraints.\"\"\"\n    spring: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    damping: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    gravity: Optional[EnableDisable] = None\n    \"\"\"This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.\"\"\"\n    clampctrl: Optional[EnableDisable] = None\n    \"\"\"This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.\"\"\"\n    warmstart: Optional[EnableDisable] = None\n    \"\"\"This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.\"\"\"\n    filterparent: Optional[EnableDisable] = None\n    \"\"\"This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.\"\"\"\n    actuation: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.\"\"\"\n    refsafe: Optional[EnableDisable] = None\n    \"\"\"This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.\"\"\"\n    sensor: Optional[EnableDisable] = None\n    \"\"\"This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.\"\"\"\n    midphase: Optional[EnableDisable] = None\n    \"\"\"This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.\"\"\"\n    nativeccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.\"\"\"\n    island: Optional[EnableDisable] = None\n    \"\"\"This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.\"\"\"\n    eulerdamp: Optional[EnableDisable] = None\n    \"\"\"This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.\"\"\"\n    autoreset: Optional[EnableDisable] = None\n    \"\"\"This flag disables the automatic resetting of the simulation state when numerical issues are detected.\"\"\"\n    override: Optional[EnableDisable] = None\n    \"\"\"This flag enables the Contact override mechanism.\"\"\"\n    energy: Optional[EnableDisable] = None\n    \"\"\"This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.\n\n    The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.\"\"\"\n    fwdinv: Optional[EnableDisable] = None\n    \"\"\"This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.\"\"\"\n    invdiscrete: Optional[EnableDisable] = None\n    \"\"\"This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.\"\"\"\n    multiccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.\"\"\"\n    sleep: Optional[EnableDisable] = None\n    \"\"\"This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[EnableDisable] = None\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/#mujoco_mojo.mjcf.mujoco_attr.option_attr.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/","title":"flag","text":""},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag","title":"Flag","text":"<p>               Bases: <code>XMLModel</code></p> <p>This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.</p> Source code in <code>src\\mujoco_mojo\\mjcf\\mujoco_attr\\option_attr\\flag.py</code> Python<pre><code>class Flag(XMLModel):\n    \"\"\"This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are \"enable\" for flags corresponding to standard features, and \"disable\" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.\"\"\"\n\n    tag = \"flag\"\n\n    attributes = (\n        \"constraint\",\n        \"equality\",\n        \"frictionloss\",\n        \"limit\",\n        \"contact\",\n        \"spring\",\n        \"damping\",\n        \"gravity\",\n        \"clampctrl\",\n        \"warmstart\",\n        \"filterparent\",\n        \"actuation\",\n        \"refsafe\",\n        \"sensor\",\n        \"midphase\",\n        \"eulerdamp\",\n        \"autoreset\",\n        \"nativeccd\",\n        \"island\",\n        \"override\",\n        \"energy\",\n        \"fwdinv\",\n        \"invdiscrete\",\n        \"multiccd\",\n        \"sleep\",\n    )\n\n    constraint: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.\"\"\"\n    equality: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to equality constraints.\"\"\"\n    frictionloss: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to friction loss constraints.\"\"\"\n    limit: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to joint and tendon limit constraints.\"\"\"\n    contact: Optional[EnableDisable] = None\n    \"\"\"This flag disables collision detection and all standard computations related to contact constraints.\"\"\"\n    spring: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    damping: Optional[EnableDisable] = None\n    \"\"\"This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.\"\"\"\n    gravity: Optional[EnableDisable] = None\n    \"\"\"This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.\"\"\"\n    clampctrl: Optional[EnableDisable] = None\n    \"\"\"This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.\"\"\"\n    warmstart: Optional[EnableDisable] = None\n    \"\"\"This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.\"\"\"\n    filterparent: Optional[EnableDisable] = None\n    \"\"\"This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.\"\"\"\n    actuation: Optional[EnableDisable] = None\n    \"\"\"This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.\"\"\"\n    refsafe: Optional[EnableDisable] = None\n    \"\"\"This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.\"\"\"\n    sensor: Optional[EnableDisable] = None\n    \"\"\"This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.\"\"\"\n    midphase: Optional[EnableDisable] = None\n    \"\"\"This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.\"\"\"\n    nativeccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.\"\"\"\n    island: Optional[EnableDisable] = None\n    \"\"\"This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.\"\"\"\n    eulerdamp: Optional[EnableDisable] = None\n    \"\"\"This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.\"\"\"\n    autoreset: Optional[EnableDisable] = None\n    \"\"\"This flag disables the automatic resetting of the simulation state when numerical issues are detected.\"\"\"\n    override: Optional[EnableDisable] = None\n    \"\"\"This flag enables the Contact override mechanism.\"\"\"\n    energy: Optional[EnableDisable] = None\n    \"\"\"This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.\n\n    The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.\"\"\"\n    fwdinv: Optional[EnableDisable] = None\n    \"\"\"This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.\"\"\"\n    invdiscrete: Optional[EnableDisable] = None\n    \"\"\"This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.\"\"\"\n    multiccd: Optional[EnableDisable] = None\n    \"\"\"This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.\"\"\"\n    sleep: Optional[EnableDisable] = None\n    \"\"\"This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.\"\"\"\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.__exclusive_groups__","title":"__exclusive_groups__  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>__exclusive_groups__: tuple[tuple[str, ...], ...] = ()\n</code></pre> <p>Attributes which if defined simultaneously will result in an error.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.actuation","title":"actuation  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>actuation: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.autoreset","title":"autoreset  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>autoreset: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the automatic resetting of the simulation state when numerical issues are detected.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.children","title":"children  <code>class-attribute</code>","text":"Python<pre><code>children: tuple[str, ...] = ()\n</code></pre> <p>Children of the XML tag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.clampctrl","title":"clampctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>clampctrl: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.constraint","title":"constraint  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>constraint: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to \"enable\" for a given computation to be performed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>contact: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables collision detection and all standard computations related to contact constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.damping","title":"damping  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>damping: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon dampers. If passive spring forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>energy: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the computation of potential and kinetic energy in mjData.energy[0, 1] respectively, and displayed in the simulate GUI info overlay. Potential energy includes the gravitational component summed over all bodies and energy stored in passive springs in joints, tendons and flexes. Note that potential and kinetic energy in constraints is not accounted for.</p> <p>The extra computation (also triggered by potential and kinetic energy sensors) adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.equality","title":"equality  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>equality: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to equality constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.eulerdamp","title":"eulerdamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>eulerdamp: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables implicit integration with respect to joint damping in the Euler integrator. See the Numerical Integration section for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.filterparent","title":"filterparent  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>filterparent: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact selection in the Computation chapter.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.frictionloss","title":"frictionloss  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>frictionloss: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to friction loss constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.fwdinv","title":"fwdinv  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>fwdinv: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.gravity","title":"gravity  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>gravity: Optional[EnableDisable] = None\n</code></pre> <p>This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.invdiscrete","title":"invdiscrete  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>invdiscrete: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discrete-time inverse dynamics with mj_inverse for all integrators other than RK4. Recall from the numerical integration section that the one-step integrators (Euler, implicit and implicitfast), modify the mass matrix M -&gt; M-hD. This implies that finite-differenced accelerations (v_(t+h)-v_t)/h will not correspond to the continuous-time acceleration mjData.qacc. When this flag is enabled, mj_inverse will interpret qacc as having been computed from the difference of two sequential velocities, and undo the above modification.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.island","title":"island  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>island: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables discovery and construction of constraint islands: disjoint sets of constraints and degrees-of-freedom that do not interact and can be solved independently. Islanding is not yet supported by the PGS solver. See Constraint islands for more details. The mjVIS_ISLAND enables island visualization.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>limit: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all standard computations related to joint and tendon limit constraints.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.midphase","title":"midphase  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>midphase: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables the mid-phase collision filtering using a static AABB bounding volume hierarchy (a BVH binary tree). If disabled, all geoms pairs that are allowed to collide are checked for collisions.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.multiccd","title":"multiccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>multiccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables multiple-contact collision detection for geom pairs that use a general-purpose convex-convex collider e.g., mesh-mesh collisions. This can be useful when the contacting geoms have a flat surface and the single contact point generated by the convex-convex collider cannot accurately capture the surface contact, leading to instabilities that typically manifest as sliding or wobbling. The implementation of this feature depends on the selected convex collision pipeline, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.nativeccd","title":"nativeccd  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>nativeccd: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the native convex collision detection pipeline instead of using the libccd library, see convex collisions for more details.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.override","title":"override  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>override: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables the Contact override mechanism.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.refsafe","title":"refsafe  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>refsafe: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.sensor","title":"sensor  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sensor: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables all computations related to sensors. When disabled, sensor values will remain constant, either zeros if disabled at the start of simulation, or, if disabled at runtime, whatever value was last computed.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.sleep","title":"sleep  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>sleep: Optional[EnableDisable] = None\n</code></pre> <p>This flag enables sleeping. Disabling this flag when some trees are sleeping will wake them.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.spring","title":"spring  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>spring: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables passive joint and tendon springs. If passive damper forces are also disabled, all passive forces are disabled, including gravity compensation, fluid forces, forces computed by the mjcb_passive callback, and forces computed by plugins when passed the mjPLUGIN_PASSIVE capability flag.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.warmstart","title":"warmstart  <code>class-attribute</code> <code>instance-attribute</code>","text":"Python<pre><code>warmstart: Optional[EnableDisable] = None\n</code></pre> <p>This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e., the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.</p>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.__pydantic_init_subclass__","title":"__pydantic_init_subclass__  <code>classmethod</code>","text":"Python<pre><code>__pydantic_init_subclass__(**kwargs)\n</code></pre> <p>Validates that XML attribute and child names exist on the model.</p> <p>This runs after Pydantic has finished building model fields and ensures that all entries in <code>attributes</code> and <code>children</code> reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@classmethod\ndef __pydantic_init_subclass__(cls, **kwargs):\n    \"\"\"\n    Validates that XML attribute and child names exist on the model.\n\n    This runs after Pydantic has finished building model fields and ensures that all entries in `attributes` and `children` reference actual fields or class variables. Errors are raised at class definition time to prevent invalid XML schemas from being created.\n    \"\"\"\n    super().__pydantic_init_subclass__(**kwargs)\n\n    # Pydantic fields (includes inherited)\n    model_fields = set(cls.model_fields.keys())\n\n    # Class-level attributes (ClassVars, constants, etc)\n    class_vars = set(vars(cls).keys())\n\n    valid_names = model_fields | class_vars\n\n    # Validate attributes\n    for name in cls.attributes:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: attribute '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n\n    # Validate children\n    for name in cls.children:\n        if name not in valid_names:\n            raise TypeError(\n                f\"{cls.__name__}: child '{name}' is not defined \"\n                f\"as a field or class variable\"\n            )\n</code></pre>"},{"location":"reference/mujoco_mojo/mjcf/mujoco_attr/option_attr/flag/#mujoco_mojo.mjcf.mujoco_attr.option_attr.flag.Flag.enforce_exclusive_groups","title":"enforce_exclusive_groups","text":"Python<pre><code>enforce_exclusive_groups() -&gt; XMLModel\n</code></pre> <p>Ensures that only one attribute in each exclusive group is set.</p> Source code in <code>src\\mujoco_mojo\\base.py</code> Python<pre><code>@model_validator(mode=\"after\")\ndef enforce_exclusive_groups(self) -&gt; XMLModel:\n    \"\"\"\n    Ensures that only one attribute in each exclusive group is set.\n    \"\"\"\n    for group in self.__exclusive_groups__:\n        count = sum(getattr(self, field) is not None for field in group)\n        if count &gt; 1:\n            raise ValueError(\n                f\"{type(self).__name__}: Only one of {group} may be specified\"\n            )\n    return self\n</code></pre>"}]}